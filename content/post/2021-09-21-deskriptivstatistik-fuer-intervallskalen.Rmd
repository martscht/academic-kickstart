---
title: "Deskriptivstatistik für Intervallskalen"
categories: [BSc2]
date: '2020-09-24'
featured: no
header:
  caption: '[Courtesy of pxhere](https://pxhere.com/en/photo/1227907)'
  image: /header/descriptive_post.jpg
lastmod: '2020-09-24T20:54:18+02:00'
projects: []
slug: deskriptiv-intervall
subtitle: ''
summary: ''
tags: 
  - R 
  - Deskriprivstatistik
authors: [nehler, buchholz]
---



```{r setup, cache = FALSE, echo = FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(error = TRUE)
library(knitr)
```


<details><summary>Kernfragen dieser Lehreinheit</summary>

* Was ist der Befehl um den **Mittelwert** zu bestimmen?
* Wie kann die **empirische Varianz** bestimmt werden? Wie unterscheidet sich diese von der mit `var()` bestimmten Varianz?
* Wie können Variablen **zentriert und standardisiert** werden?
* Welche Möglichkeiten gibt es, negativ formulierte Items zu **rekodieren**?
* Mit welchen Befehlen können in R **Skalenwerte** für Fragebögenitems erstellt werden?
</details>

***

## Wiederholung aus der Vorlesung: Skalenniveaus

Skala | Aussage | Transformation | Zentrale Lage | Dispersion |
--- | ------------ | -------- | ---------- | ----------------- |
Nominal | Äquivalenz | eineindeutig | Modus | Relativer Informationsgehalt |
Ordinal | Ordnung | monoton | Median | Interquartilsbereich |
Intervall | Verhältnis von Differenzen | positiv linear | Mittelwert | Standardabweichung, Varianz |
Verhältnis | Verhältnisse | Ähnlichkeit | ... | ... |
Absolut | absoluter Wert | Identität | ... | ... |


***

## Vorbereitende Schritte

Den Datensatz haben wir bereits über diesen [<i class="fas fa-download"></i> Link heruntergeladen](/post/fb21.rda) und können ihn über den lokalen Speicherort einladen oder Sie können Ihn direkt mittels des folgenden Befehls aus dem Internet in das Environment bekommen:

```{r}
load(url('https://pandar.netlify.app/post/fb21.rda'))  # Daten laden
names(fb21)        # Namen der Variablen
dim(fb21)          # Anzahl Zeile und Spalten
```



***

## Mindestens intervallskalierte Variablen

### Klassische mindestens intervallskalierte Variablen

* Behaviorale Maße: Reaktionszeiten, Bearbeitungsdauer, Anzahl von Fehlern, ...
* Biologische Maße: Hautleitfähigkeit, Stimmhöhe, Anzahl der Sakkaden, ...
* Neurophysiologische Maße: EEG-Daten, Durchblutung von Hirnregionen, ...


### Konstruierte mindestens intervallskalierte Variablen

* Fragebogendaten werden meist ordinalskaliert erhoben (einzelne Items)
* Um Intervallskalenniveau zu erreichen, werden Items zu Skalenwerten verrechnet (Summe oder Mittelwert)
* Erzeugt viele mögliche Ausprägungen und wird als intervallskaliert behandelt


**Beispiel: Lebenszufriedenheit**

![](/post/fb_swls.png)

Der Mittelwert pro Person über alle 5 Items ist in der Spalte `lz` zu finden. Dies ist also der Skalenwert für die Lebenszufriedenheit jeder einzelnen Person.

```{r}
fb21$lz
```

## Deskriptivstatistik für mindestens intervallskalierte Variablen

* Verfahren sind "rückwärtskompatibel", d.h. alle Berechnungen, die auf nominalskalierte und ordinalskalierte Variablen anwendbar sind, lassen sich auch auf mindestens intervallskalierte Variablen anwenden
* Quantile, IQA und Median können weiterhin bestimmt werden

```{r}
# Minimum & Maximum
range(fb21$lz, na.rm=T)

# Quartile
quantile(fb21$lz, c(.25, .5, .75), na.rm=T)

#Box-Whisker Plot
boxplot(fb21$lz)
```

## Histogramme

* Zusammenfassung von Werten in Klassen (Kategorien, Intervalle)  
* Häufigkeitsverteilung für die kategorisierten Daten erstellen (sekundäre Häufigkeitsverteilung)  
* Achtung! Die Anzahl der Kategorien kann den Eindruck der Daten beeinflussen:  

```{r}
# Histogramm
hist(fb21$lz)

# Histogramm (20 Kategorien)
hist(fb21$lz,
     breaks = 20)

# Histogramm (ungleiche Kategorien)
hist(fb21$lz,
     breaks = c(1, 3, 3.3, 3.6, 3.9, 4.5, 5, 7))
```

## Mittelwert

Betrachten wir nun, wie ihn `R` das Maß der zentralen Tendenz für mindestens intervallskalierte Daten per Funktion bestimmt werden kann. In der Vorlesung haben Sie die Formel zur Bestimmung kennen gelernt.

**Formel:** ${x} = \frac{\sum_{m = 1}^n x_m}{n} = \frac{1}{n} \sum_{m = 1}^n x_m$

In `R` ist die Funktion zum Glück sehr intuitiv benannt. Dabei muss auch hier beachtet werden, dass fehlende Werte über `na.rm = T` ausgeschlossen werden

```{r}
# Arithmetisches Mittel
mean(fb21$lz, na.rm = TRUE)
```

## Varianz

Für die Varianz haben Sie in der Vorlesung folgende Formel kennen gelernt:

**Formel:** $s^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n}$

Wollen wir diese nun per Hand bestimmen, könnte folgender Code das für uns erledigen:

```{r}
# Händische Varianzberechnung
sum((fb21$lz - mean(fb21$lz, na.rm = TRUE))^2, na.rm = TRUE) / (nrow(fb21)-2)
```

Achtung! Wir benötigen für die Varianzberechnung `n` (s. Formel)! Wir nutzen hier `nrow(fb21)-2`, weil `nrow(fb21)` nicht das richtige n anzeigt (zwei Personen haben einen fehlenden Wert, daher die Anzahl an Zeilen minus der zwei fehlenden Werte = n)


**Kleiner Diskurs zu fehlenden Werten:**

```{r echo=F,warning=F, fig.align='center',cache=FALSE}
library("RXKCD")
invisible(getXKCD(851))
```

Um zu prüfen, ob und wie viele fehlende Werte eine Variable hat, lässt sich z. B. folgende Syntax verwenden:

```{r}
is.na(fb21$lz) |> sum()
```

Um die Länge einer Variablen ohne fehlende Werte (also die Anzahl an Beobachtungen auf einer Variablen) zu bestimmen, lässt sich z. B. folgende Syntax verwenden:

```{r}
na.omit(fb21$lz) |> length() # mit Pipe
length(na.omit(fb21$lz))     # ohne Pipe
```

Zur händischen Varianzberechnung können wir daher auch folgende Syntax verwenden:

```{r}
# Händische Varianzberechnung
sum((fb21$lz - mean(fb21$lz, na.rm = TRUE))^2, na.rm = TRUE) / (length(na.omit(fb21$lz)))
```


## Verschiedene Varianzschätzer

Sie haben sich eventuell schon gewundert, warum wir eine so bekannten Wert wie die Varianz per Hand bestimmen müssen. Mit der ersten Intuition findet man bereits eine Funktion für die Berechenung `var`. Folgendes Ergebnis liefert R, wenn wir die R-Funktion `var()` zur Berechnung der Varianz verwenden:
```{r}
# R-interne Varianzberechnung
var(fb21$lz, na.rm = TRUE)
```

Warum erhalten wir hier einen abweichenden Wert im Vergleich zu unserer händischen Varianzberechnung?

Die meisten Programme berechnen nicht die empirische Varianz, sondern einen Schätzer der Populationsvarianz:

**Empirische Varianz**

$s^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n}$

**Schätzer der Populationsvarianz**

$\hat{\sigma}^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n - 1}$

Ein enger Zusammenhang zwischen Populationsvarianz und empirischer Varianz ist bereits nur durch Ansicht der Formeln erkenntlich. Eine Erklärung über diesen wird es erst im weiteren Verlauf der Vorlesung geben. Wir wollen uns nun darauf konzentrieren, wie wir technisch den Wert, den wir durch `var()` erhalten, für unsere Zwecke nutzen können.

Um in R die empirische Varianz mithilfe der `var()`-Funktion zu berechnen, kann man die Populationsvarianz nutzen. Multipliziert man sie mit $\frac{n - 1}{n}$, erhält man die empirische Varianz.

```{r}
# Umrechnung der Varianzen
var(fb21$lz, na.rm = TRUE) * (nrow(fb21) - 1) / nrow(fb21)
```

Achtung! Dies funktioniert in unserem Fall wieder nicht, da die Verwendung von `nrow(fb21)`  - wie oben bereits angemerkt - nicht sinnvoll ist: `nrow(fb21)` ist nicht gleich n (es kommt `NA` `r sum(is.na(fb21$lz))` Mal vor), daher besser:

```{r}
# Umrechnung der Varianzen
var(fb21$lz, na.rm = TRUE) * (length(na.omit(fb21$lz)) - 1) / (length(na.omit(fb21$lz)))
```

Alternativ, wenn man die fehlenden Werte händisch abzieht:
```{r}
# Umrechnung der Varianzen
var(fb21$lz, na.rm = TRUE) * (112 - 1) / 112
```


## Standardabweichung

Auch bei der Standardabweichung bestimmt R den Populationsschätzer $\hat{\sigma}_{X}$.

$\hat{\sigma}_{X} = \sqrt{\hat{\sigma}^2_{X}} = \sqrt{\frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n - 1}}$


```{r}
# Standardabweichung in R
sd(fb21$lz, na.rm = TRUE) # Populationsschaetzer
```


In der Vorlesung hingegen haben Sie die empirische Standardabweichung kennen gelernt.

$s_{X} = \sqrt{s^2_{X}} = \sqrt{\frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n}}$

Wir müssten das Ergebnis also wieder mit einem Faktor ($\sqrt{\frac{n - 1}{n}}$) multiplizieren, um die emprische Standardabweichung zu erhalten. 

```{r}
# Umrechnung der Standardabweichung
sd(fb21$lz, na.rm = TRUE) * sqrt((112 - 1) / 112)
```

Alternativ kann diese natürlich auch komplett händisch berechnet werden. Dafür können wir einfach den bereits geschriebenen Code für die empirische Varianz nehmen und aus dem Ergebnis die Wurzel ziehen.

```{r}
# Händische Berechnung der empirischen Standardabweichung
(sum((fb21$lz - mean(fb21$lz, na.rm = TRUE))^2,
    na.rm = TRUE) / (length(na.omit(fb21$lz)))) |> sqrt()
```

***

## Zentrierung und Standardisierung

In der Vorlesung haben Sie gelernt, dass eine Variable zentriert oder standardisiert werden kann. Die Zentrierung sorgt für einen Mittelwert von 0, während die Standardisierung zusätzlich die Varianz auf 1 setzt. Die Variablenzentrierung und -standardisierung lässt sich in R per Hand berechnen...

```{r}
# Zentrierung
lz_c <- fb21$lz - mean(fb21$lz, na.rm = TRUE)
head(lz_c)    # erste 6 zentrierte Werte

# Standardisierung
lz_z <- lz_c / sd(fb21$lz, na.rm = TRUE)
head(lz_z)    # erste 6 standardisierte Werte
```

...oder mit Hilfe bereits existierender Funktionen:

```{r}
## Befehl zum Standardisieren
lz_z <- scale(fb21$lz)
## Befehl zum Zentrieren (ohne Standardisierung)
lz_c <- scale(fb21$lz,
              scale = FALSE) # unterbindet Standardisierung
```

***

## Skalenwerte

### Wiederholung: Konstruierte mindestens intervallskalierte Variablen

* Fragebogendaten werden meist ordinalskaliert erhoben (einzelne Items)
* Um Intervallskalenniveau zu erreichen werden Items zu Skalenwerten verrechnet (Summe oder Mittelwert)
* Erzeugt viele mögliche Ausprägungen und wird als intervallskaliert behandelt

### Positive & Negative Items

Viele Fragebögen enthalten sowohl positiv als auch negativ formulierte Items,

* ...um die Befragung abwechslungsreich zu gestalten
* ...um das psychologische Konstrukt umfassender zu erheben
* ...um Antworttendenzen leichter identifizieren zu können

Vor der Skalenbildung müssen alle Items in eine Richtung gebracht werden: Das wird auch als **Rekodierung** bezeichnet.

**Beispiel: Fragebogen zur Prokrastionationstendenz**

* Skala soll bei hohen Werten höhere Prokrastinationstendenz darstellen    
* Negativ formulierte Items müssen invertiert werden    
* Invertierte Items sind 2, 3, 5, 7 und 8 
* Mögliche Werte von 1 bis 4     
* Hierzu kennen Sie bereits zwei Möglichkeiten (mit den Befehlen und R-Kenntnissen aus den bisherigen Sitzungen...)    

## Rekodierung
**Variante 1: Lineare Transformation**
```{r}
fb21$prok2_r <- -1 * (fb21$prok2 - 5)
head(fb21$prok2)     # erste 6 Werte ohne Transformation
head(fb21$prok2_r)   # erste 6 Werte mit Transformation
```

* Allgemeine Form: $-1 \cdot (x_m - x_{\max} - 1)$   
* Vorteil: schnell und einfach umsetzbar   
* Nachteil: nur für Invertierung sinnvoll, nicht allgemeiner anwendbar   

*Quizfrage*: Ist dies eine zulässige Transformation für ordinalskalierte Variablen (wie Items)?  
*Antwort*: Ja, denn die Ordnungsrelation bleibt hierbei erhalten!  

**Variante 2: Logische Filter**
```{r}
fb21$prok3_r[fb21$prok3 == 1] <- 4
fb21$prok3_r[fb21$prok3 == 2] <- 3
fb21$prok3_r[fb21$prok3 == 3] <- 2
fb21$prok3_r[fb21$prok3 == 4] <- 1

head(fb21$prok3)
head(fb21$prok3_r)
```

* Durch logische Filter Personen auswählen, die auf Originalvariable den relevanten Wert haben  
* Auf rekodierter Variable neuen Wert zuweisen  
* Vorteil: extrem flexibel, jede Transformation möglich  
* Nachteil: umständlich zu schreiben  

Um Code zu sparen, invertieren wir also die restlichen Items mittels der linearen Transformation.

```{r}
fb21$prok5_r <- -1 * (fb21$prok5 - 5)
fb21$prok7_r <- -1 * (fb21$prok7 - 5)
fb21$prok8_r <- -1 * (fb21$prok8 - 5)
```

## Skalenwerte erstellen

Skalenwerte werden zumeist als Summen oder Mittelwerte der Items erstellt. Dafür kann man beispielsweise sich alle Daten in einen eigenen kleinen Datensatz ablegen. Dieser Datensatz kann genutzt werden, um den Skalenwert wieder im Original abzulegen. Jede Person repräsentiert eine Zeile - `rowMeans` berechnet den Mittelwert der Zeilen. Somit erhält jede Person einen eigenen Mittelwert über die Einträge. Führen wir das ganze beispielsweise für den Skalenwert zur Prokrastinationstendenz durch, das mit den 10 Items erhoben wurde. Wichtig ist hier auch, dass wir die rekodierten Items nehmen, da diese ja die "korrekte Richtung" aufweisen.

```{r}
# Datensatz der relevanten Variablen
prokrastination <- fb21[, c('prok1', 'prok2_r', 'prok3_r',
                            'prok4', 'prok5_r', 'prok6', 
                            'prok7_r', 'prok8_r', 'prok9', 
                            'prok10')]
# Skalenwert in Originaldatensatz erstellen
fb21$prok_ges <- rowMeans(prokrastination)
head(fb21$prok_ges)
```

Natürlich kann die Erstellung auch in einem Befehl passieren - beispielsweise durch Verwendung der Pipe. Es gibt aber auch noch viele andere Optionen zur Skalenbildung - es wird (wie eigentlich fast immer) nur ein Ausschnitt der Möglichkeiten gezeigt.

```{r}
# Direkter Befehle
fb21$prok_ges <- fb21[, c('prok1', 'prok2_r', 'prok3_r',
                          'prok4', 'prok5_r', 'prok6',
                          'prok7_r', 'prok8_r', 'prok9', 
                          'prok10')] |> rowMeans()
head(fb21$prok_ges)
```

## Nützliche Funktionen in diesem Zusammenhang:

* `rowMeans()` Mittelwert für jede Zeile (über Variablen)  
* `colMeans()` Mittelwert für jede Spalte (über Personen)  
* `rowSums()` Summe für jede Zeile (über Variablen)  
* `colSums()` Summe für jede Spalte (über Personen)  

***
