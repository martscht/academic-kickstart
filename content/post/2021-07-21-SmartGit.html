---
title: SmartGit
date: '2021-08-01'
slug: smartgit
categories:
  - "gitintro"
tags: []
subtitle: ''
summary: ''
authors: [nehler, rouchi]
featured: no
header:
  image: ""
  caption: ""
projects: []
publishDate: '2021-08-12'
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<div id="warum-smartgit" class="section level1">
<h1>Warum SmartGit?</h1>
<p>Da das Terminal nicht die beste optische Repräsentation aller Möglichkeiten von <code>git</code> bietet, wollen wir uns in diesem Tutorial mit <code>SmartGit</code> beschäftigen. Dieses bietet uns eine benutzerfreundlichere, anschaulichere Oberfläche, mit der wir problemlos <code>git</code>-Befehle ausführen können. Wir wollen uns hierbei zunächst anschauen, wie unsere bereits gelernten Befehle in <code>SmartGit</code> funktionieren. Anschließend werden wir noch weitere Möglichkeiten und Befehle kennen lernen.</p>
<div id="einführung" class="section level2">
<h2>Einführung</h2>
<p><code>SmartGit</code> ist wie bereits erwähnt eine grafische Oberfläche für die Verwendung von <code>git</code> auf dem lokalen Rechner - aber auch in der Verbindung mit <code>remote repositories</code>. Das Programm existiert bereits seit 2009 und wurde stets weiterentwickelt, wodurch eine reibungslose Funktionsweise sichergestellt ist. Durch Ausführen von <code>git</code>-Befehlen via Klick wird die Arbeit beschleunigt. Andere Befehle werden sogar automatisiert durchgeführt. Ein großer Vorteil von <code>SmartGit</code> ist dabei, dass es mit mehreren Orten für <code>remote repositories</code> wie <code>GitHub</code>, <code>BitBucket</code> oder <code>GitLab</code> integrativ arbeiten kann, wobei wir uns im Tutorial weiterhin nur mit <code>GitHub</code> beschäftigen werden.</p>
</div>
</div>
<div id="setup" class="section level1">
<h1>Setup</h1>
<p>Damit ihr <code>SmartGit</code> auf euren Rechnern verwenden könnt, müsst ihr zunächst das Programm herunterladen. Dies könnt ihr <a href="https://www.syntevo.com/smartgit/">hier</a> für verschiedene Betriebssysteme machen. Auf der Website gibt es auch <strong>Installation Instructions</strong> für die verschiedenen Betriebssystem.</p>
<!-- Für unser Beispiel mit dem Praktikums-Ordner, den wir bereits im ersten Teil lokal erstellt und im zweiten Teil auf `GitHub` hochgeladen haben, möchten wir dieses bereits bestehende `repository` in unser `SmartGit` laden. Deswegen wählen wir hier die zweite Option. -->
<p>Bei den Einstellungen für <code>SmartGit</code> müsst ihr den Nutzungsbedingungen zustimmen und unter <code>License type</code> außerdem auswählen, dass ihr das Programm für “Non-commercial use only”, also wissenschaftliche Zwecke verwendet, sodass ihr nicht für die Nutzung zahlen müsst.</p>
<p><img src="/post/smartgit_license.png" /></p>
<p>Dies muss in einem zweiten Fenster noch einmal bestätigt werden. Als nächstes müsst ihr euch unter <code>User Information</code> einen Nutzernamen geben sowie eine E-Mail-Adresse angeben, über die ihr euer <code>SmartGit</code> konfiguriert. <code>SmartGit</code> sollte die Informationen aus eurer eigenen Konfiguration auf dem lokalen PC ziehen können und daher bereits anzeigen, welche E-Mail und welcher Name hinterlegt sind. Ansonsten gebt ihr am besten selbst Nutzernamen und die E-Mail-Adresse an, mit denen ihr <code>Git</code> auf dem Rechner konfiguriert habt!</p>
<p><img src="/post/smartgit_information.png" /></p>
<p>Jetzt müsst ihr noch die Option <strong>Use SmartGit as SSH client</strong> auswählen. Dies ist für den Start der Arbeit mit <code>SmartGit</code> empfohlen.</p>
<p><img src="/post/smartgit_sshclient.png" /></p>
<p>Anschließend werden wir nach dem bevorzugten Style der Oberfläche von <code>SmartGit</code> gefragt. Hier gibt es natürlich kein richtig oder falsch und es gibt auch nicht direkt eine Empfehlung für Anfänger:innen. Die Ansicht des <strong>Working Tree</strong> wird von uns allerdings als intuitiver eingeschätzt und deshalb verwendet. Wie im Fenster beschrieben, kann diese Einstellung später auch unter Präferenz geändert werden.</p>
<p><img src="/post/smartgit_style.png" /></p>
<p>Unter <strong>Privacy</strong> kann man bestimmen, in welchen Fällen Daten an die Ersteller:innen gesendet werden, die diese zur Verbesserung des Programmes nutzen wollen. Hier möchten wir keine Empfehlung aussprechen - man kann nach persönlicher Präferenz auswählen. Außerdem sucht <code>SmartGit</code> auf dem Rechner nach initialisierten <code>repositories</code> und gibt in diesem Fenster die Anzahl an.</p>
<p><img src="/post/smartgit_privacy.png" /></p>
<p>Sobald ihr <code>SmartGit</code> installiert habt und das Programm öffnet, werdet ihr gefragt, ob ihr ein lokales <code>repository</code> öffnen oder neu erstellen wollt, oder aber ob ihr ein bereits bestehendes <code>clonen</code> möchtet. Wenn bereits <code>repositories</code> auf dem Rechner bestehen, werden diese hier unter <strong>Reopen previously used repository</strong> angezeigt. Diesen Punkt wählen wir daher auch aus. Dabei wollen wir natürlich an unserem Ordner Praktikum arbeiten.</p>
<p><img src="/post/smartgit_welcome.png" /></p>
<!-- Einen `Hosting Provider` braucht ihr nicht, diese Seite des Setups könnt ihr einfach überspringen.  -->
<!-- Nach einigen letzten Einverständniserklärungen ist das Setup von `SmartGit` abgeschlossen und ihr könnt das Programm nun mit euren `repositories` verknüpfen! -->
<p>Nun ist die Installation abgeschlossen und wir können uns die Oberfläche des Programms und die Nutzung genauer anschauen!</p>
</div>
<div id="basics" class="section level1">
<h1>Basics</h1>
<p>Jetzt wo wir <code>SmartGit</code> erfolgreich installiert und mit unserem Praktikums-Ordner verknüpft haben, stellt sich die Frage, wofür und wie wir <code>SmartGit</code> am besten verwenden. Hierzu betrachten wir zunächst, wo wir unsere bereits erlernten <code>Git</code>-Befehle umsetzen können</p>
<div id="benutzeroberfläche" class="section level3">
<h3>Benutzeroberfläche</h3>
<p>Zur Orientierung schauen wir uns jedoch zunächst die Oberfläche von <code>SmartGit</code> genauer an. Diese haben wir durch die Auswahl eines bestimmten Styles hergestellt.</p>
<p><img src="/post/smartgit_style_workingtree.png" /></p>
<p>In der oberen Zeile befinden sich zunächst Symbole mit bekannten Begriffen wie <code>Pull</code> und <code>Commit</code>. Diese Werkzeuge werden wir gleich brauchen. Auf der linken Seite sehen wir unsere <code>Repositories</code> - theoretisch können wir hier alle reinladen, an denen wir uns beteiligen. Wenn ihr dem Tutorial Stück für Stück bis hierhin gefolgt seid, sollte einmal das Dummy und das Praktikum-Repository hier erscheinen. Darunter sehen wir die verschiedenen <code>Branches</code> eines Projekts - mit diesen beschäftigen wir uns erst im nächsten Teil des Tutoriums.</p>
<p>In der Mitte des Bildschirms sehen wir die Kachel <code>Files</code>. Hierin werden alle Dateien angezeigt, die entweder noch nicht getracked werden, verändert, gelöscht oder umbenannt wurden. Für Praktikum ist hier die <code>R</code>-History zu sehen, die <code>R</code> automatisch erstellt, aber für uns keinen Wert hat. Diese ist im normalen Explorer und Terminal versteckt, wird aber hier angezeigt.</p>
<p>In der Kachel <code>Changes</code> werden die Veränderungen an einer Datei angezeigt, wenn Sie unter <code>Files</code> ausgewählt ist. Das demonstrieren wir gleich noch einmal mit einem Screenshot. In der Kachel Journal sind alle <code>Commits</code> der Historie aufgeführt.</p>
<p>Um die Arbeit mit <code>SmartGit</code> zu simulieren, müssen wir natürlich wieder Änderungen an den Dateien vornehmen. Dafür öffnen wir das Datenauswertungsskript aus unserem Ordner und ergänzen darin beispielsweise eine Häufigkeitstabelle für den Gesamtscore. Wichtig ist, dass die Änderung auch gespeichert werden muss.</p>
<p><img src="/post/Dummy_gitAuswertung_fifth.png" /></p>
<p>Durch die Änderung der Datei erscheint diese nun in <code>SmartGit</code> in der Kachel <code>Files</code>. Dabei wird sie in rot angezeigt und es steht daneben, dass sie modifiziert wurde. Wenn wir nun einmal auf sie mit Linksklick draufgehen, sehen wir auch nochmal besser, wofür die <code>Changes</code> Kachel da ist. Durch die grüne Markierung der Zeilen 19 und 20 im Code sehen wir, dass diese neu hinzugefügt wurden.</p>
<p><img src="/post/smartgit_files_changes.png" /></p>
</div>
<div id="commit" class="section level3">
<h3><code>Commit</code></h3>
<p>Nun, da wir eine Datei verändert haben, wollen wir diese Änderung natürlich auch committen. Im Terminal mussten wir dafür erst mit <code>git add</code> etwas zur <code>staging environment</code> hinzufügen. Das ist über <code>SmartGit</code> nicht mehr notwendig, bzw. wird durch Klick auf die interessierenden Dateien ersetzt. In der <code>Files</code>-Kachel wählen wir mit einem Linksklick alle Dateien aus, die im nächsten <code>Commit</code> enthalten sein sollen (bei der Auswahl mehrere Dateien wie üblich <code>strg</code> gedrückt halten). Anschließend wählen wir in der Werkzeuge-Leiste <code>Commit</code> aus. Es öffnet sich das <code>Commit</code>-Fenster, in dem nochmal angezeigt wird, welche Dateien wir ausgewählt haben. Wir möchten nur die Änderung in der Datenauswertung in unserem <code>Commit</code> haben. Weiterhin müssen wir, wie auch bei der Ausführung im Terminal, eine passende Message zu unserem <code>Commit</code> hinzufügen.</p>
<p><img src="/post/smartgit_commit.png" /></p>
<p>Wenn die Nachricht verfasst ist, reicht ein Klick auf <code>Commit</code> und die Änderungen wurden angenommen. Lokal sind sie also getracked. Alternativ könnte man hier auch auf <code>Commit &amp; Push</code> klicken, dann wird unser lokaler Ordner direkt auf <code>GitHub</code> gepusht. Dies kann man machen, wenn man sich seiner Änderungen sicher ist. Nur <code>Commit</code> ist dabei empfehlenswert, wenn man sich unsicher ist und nochmal weiter an den Änderungen arbeiten will - oder für den Fall, dass wir noch weitere Änderungen an anderen Dateien unseres Projekts vornehmen wollen. Aus Demonstrationszwecken drücken wir auf <code>Commit</code>. Wenn ihr auf <code>SmartGit</code> die Kachel <code>Journal</code> betrachtet, ist dieser <code>Commit</code> zwar im <code>master</code> enthalten, aber nicht im <code>origin</code>. Dies spricht dafür, dass die Änderung im <code>remote repository</code> noch angestoßen werden muss. Dies können wir mit einem <code>Push</code> machen.</p>
</div>
<div id="push-pull" class="section level3">
<h3><code>Push</code> &amp; <code>Pull</code></h3>
<p>Anstatt eine ganze Zeile in das Terminal eingeben zu müssen, um den Ordner auf <code>GitHub</code> auf den Stand des lokalen Ordners zu aktualisieren, reicht bei <code>SmartGit</code> ein einfacher Klick auf <code>Push</code>. Zunächst öffnet sich ein Fenster, in dem wir diese Aktion nochmals bestätigen.</p>
<p><img src="/post/smartgit_push.png" /></p>
<p>Da wir <code>SmartGit</code> nun zum ersten Mal mit einem Server interagieren lassen, werden wir nach einem <strong>Master Password</strong> gefragt. Man kann dieses zwar auch überspringen, aber es ist wichtig für den Schutz von Passwörtern in der Interaktion mit Servern, weshalb wir eine Festlegung dringend empfehlen (außerdem gibt es eine Bewegung in die Richtung, dass normale Passwort-Interaktion mit <code>GitHub</code> in Zukunft nicht mehr möglich ist). Am besten verwendet ihr hier auch nicht das gleiche Passwort, welches ihr bei <code>GitHub</code> verwendet habt.</p>
<p><img src="/post/smartgit_master_password.png" /></p>
<p>Einmal muss die Rechtmäßigkeit des Zugriffs auf den Server nun aber mit euren <code>GitHub</code>-Informationen bestätigt werden.</p>
<p><img src="/post/smartgit_github_login.png" /></p>
<p>Nun wurde der <code>Push</code> durchgeführt. Um einen optischen Indikator dafür zu haben, könnt ihr euer <code>repository</code> auf der <code>GitHub</code>-Website öffnen. Weiterhin sind man auch in der Kachel <code>Journal</code>, dass <code>origin</code> und <code>main</code> nun wieder auf derselben Höhe des neuen <code>Commits</code> sind.</p>
<p>Damit wir nicht jedes Mal die <code>GitHub</code>-Informationen eingeben müssen, aktivieren wir den Zugang über das <strong>Master Password</strong>. Dafür wählen wir in der obersten Zeile <code>Edit</code> aus und wählen darin <code>Preferences</code> aus.</p>
<p><img src="/post/smartgit_preferences.png" /></p>
<p>Hier gehen wir in der Auswahl auf <strong>Hosting Providers</strong> und drücken dann rechts auf <strong>Add</strong>.</p>
<p><img src="/post/smartgit_preferences_hosting.png" /></p>
<p><code>GitHub</code> ist hier bereits auswählt. Wir wollen nun einen <strong>Token</strong> erstellen. Dafür müssen wir den Button <strong>Generate</strong> drücken. Der Browser sollte sich automatisch öffnen und einen Login zu <code>GitHub</code> erfordern. Sobald wir diese Informationen eingegeben haben, wird ein Token generiert. Diesen kopieren wir dann in das entsprechende Fenster in <code>SmartGit</code> und klicken auf <strong>Authenticate</strong>.</p>
<p><img src="/post/smartgit_preferences_API.png" /></p>
<p>Wir gelangen zurück in das Fenster, wo wir den Token erstellt haben, und klicken auf <strong>Add</strong>. Damit erscheint nun im Fenster der Hosting Providers unser <code>GitHub</code>-Account und wir können auf <strong>OK</strong> klicken.</p>
<p><img src="/post/smartgit_preferences_hosting_two.png" /></p>
<p>Beachtet, dass der Vorgang von <code>Push</code> wirklich simpel über den Klick funktioniert hat. Die Umstellungen für das Passwort mussten wir jetzt nur einmal vornehmen. Ähnlich einfach ist der Vorgang, um unsere lokale Kopie des repositories auf die Version auf <code>GitHub</code> zu aktualisieren. Auch hier können wir den Button in der Werkzeug-Leiste nutzen. Nach dem Klick auf <code>Pull</code> geht ein Fenster auf, indem man zwischen <code>Rebase</code> und <code>Merge</code> wählen kann - diese Begriffe sind beide noch unbekannt und wir bleiben bei der Standardeinstellung. Anschließend erscheint das Fenter <code>Pull</code>. Hierin wird die URL vom <code>GitHub repository</code> angezeigt - diese müsste stimmen, könnt ihr aber gerne kontrollieren. Anschließend klicken wir auf den uns bekannten Befehl <code>Pull</code>.</p>
<p><img src="/post/smartgit_pull.png" /></p>
<p>Es erscheint für eine kurze Zeit ein grüner Kasten, in dem steht, dass der <code>Pull</code> erfolgreich war. Natürlich wurden gerade aber keine Änderungen an Dateien oder Ähnliches vorgenommen, da der Stand lokal und remote identisch war. Wir simulieren die Änderung einer anderen Person an einer Datei - wie im letzten Tutorial auch - durch eine Veränderung in der <code>GitHub</code> Version. Dafür öffnen wir das <code>repository</code> auf <code>GitHub</code> und klicken auf den Stift, der rechts in der Zeile von <strong>README.md</strong> angezeigt wird.</p>
<p>Wir wollen eine schnelle Änderung an diesem Vornehmen und fügen daher noch in der wir präzisieren, um welche Gruppe es sich bei uns imaginär handelt. In der <code>commit</code>-Nachricht beschreiben wir kurz die durchgeführte Änderung und lassen die anderen Optionen auf ihren Standardeinstellungen. Anschließend klicken wir <strong>Commit Changes</strong> und wechseln zurück auf unsere <code>SmartGit</code> Anwendung.</p>
<p><img src="/post/smartgit_github_change.png" /></p>
<p>In dieser wählen wir jetzt wieder <strong>Pull</strong> in unserem <code>repository</code> Praktikum aus. Zunächst scheint nicht viel anderes zu passieren als bei dem vorherigen <strong>Pull</strong>, wenn man allerdings genau hinschaut, sieht man, dass der letzte <code>commit</code> nun am unteren Bildschirmrand im <strong>Journal</strong> angezeigt wird. Wenn man die Datei <strong>README.md</strong> lokal auf dem eigenen Rechner anschaut, werden die neuen Inhalte nun auch angezeigt.</p>
<p><img src="/post/smartgit_pull_change.png" /></p>
<p>Bisher haben wir nur mit dem <code>repository</code> gearbeitet, das automatisch von <code>SmartGit</code> gefunden wurde. Nun wollen wir noch Fälle betrachten, in dem das <code>repository</code> nur online besteht oder in dem es noch komplett neu erstellt werden muss.</p>
<div id="bereits-bestehendes-github-repository-mit-smartgit-clonen" class="section level4">
<h4>Bereits bestehendes <code>GitHub</code>-repository mit <code>SmartGit</code> clonen</h4>
<p>Wie in den <code>git</code>-Funktionen gelernt, kann man ein <code>repository</code>, das online existiert, auch mit <code>SmartGit</code> lokal intialisieren.Um euren auf <code>GitHub</code> geladenen Praktikums-Ordner mit <code>SmartGit</code> zu verknüpfen, müsst ihr zunächst in der Menüleiste auf <code>Repository</code> klicken und dann auf <code>Clone</code>. In dem Fenster, was sich daraufhin öffnet, könnt ihr einfach die URL eures repositories (die ihr über <code>GitHub</code> anfordern könnt) in das entsprechende Feld kopieren. Die hier angegebene URL ist nur ein Platzhalter, um euch die nächste Felder zeigen zu können. Wir haben momentan kein <code>repository</code>, das nur online und nicht lokal angelegt ist. Die Eingabe muss natürlich noch bestätigt werden.</p>
<p><img src="/post/smartgit_clone_url.png" /></p>
<p>Beachtet an dieser Stelle, dass es auch möglich ist, ein lokales <code>repository</code> nochmal lokal <code>clonen</code>. Ihr hättet dieses dann zwei Mal. Hierfür müsste man <strong>local reposiotry</strong> auswählen und den Pfad dahin angeben. Dieses Vorgehen hat jedoch nicht viele Anwendungen und wird daher nicht genauer betrachtet.</p>
<p>Zurück zur Verbindung mit einem <code>repository</code> auf Github: Nach der Eingabe der URL erscheint ein Dialogfenster, in dem Details über den <code>clone</code> abgefragt werden. Diese sind vor allem interessant, wenn mehrere Branches in einem <code>repository</code> existieren, womit wir uns noch nicht beschäftigt haben. Außerdem können größere Daten ausgeschlossen werden, um Speicherplatz zu sparen. Dies trifft uns auch eher selten.</p>
<p><img src="/post/smartgit_clone_selection.png" /></p>
<p>Nach der Bestätigung der Details könnt ihr einen Ordner auswählen, in den eure Daten von <code>GitHub</code> geladen werden sollen. Ihr könnt die Standardeinstellung verwenden oder über die Ordneransicht einen Ordner auf eurem Rechner erstellen.</p>
<p><img src="/post/smartgit_clone_place.png" /></p>
<p>Nachdem das Cloning abgeschlossen ist, solltet ihr auf der linken Seite eurer <code>SmartGit</code>-Ansicht den Ordner unter <code>Repositories</code> sehen können. Jetzt könntet ihr über <code>SmartGit</code> mit <code>GitHub</code> kommunizieren und Änderungen an den Dateien tracken. Da wir diese Funktionen jetzt nur mal betrachtet und nicht ausgeführt haben, ändert sich in unserer Ansicht natürlich nichts.</p>
</div>
<div id="neues-repository-erstellen" class="section level4">
<h4>Neues <code>repository</code> erstellen</h4>
<p>Ein neues <code>repository</code> mit <code>SmartGit</code> zu erstellen, ist sehr einfach! Dazu müsst ihr in der Menüleiste zunächst auf <code>Repository</code> klicken und dann auf <strong>Add or create…</strong>. In dem Fenster, was sich jetzt öffnet, könnt ihr entweder einen Ordner auswählen, den ihr bereits erstellt habt - beispielsweise unseren bekannten Praktikums-Ordner - oder über “Neuer Ordner” einen neuen erstellen. Das Einladen eines bereits existierenden <code>repositories</code> kann nötig sein, falls die automatische Erkennung fehlgeschlagen ist oder ihr das Hinzufügen zunächst abgelehnt habt. Dafür würdet ihr einfach den Pfad des <code>repositories</code> hier einstellen, was wir jetzt aber nicht betrachten werden.</p>
<p><img src="/post/smartgit_create_rep.png" /></p>
<p>In diesem Beispiel erstellen wir in unserem Statistik-Ordner den neuen Ordner <strong>dummy2</strong> und initialisieren diesen als neues <code>repository</code>. Hierfür wird nochmal eine Bestätigung in einem seperaten Dialogfenster benötigt.</p>
<p><img src="/post/smartgit_create_init.png" /></p>
<p>Kleine Anmerkung: Diese Initialiserung würde natürlich nicht erscheinen, wenn ihr der Ordner bereits ein <code>git</code>-Ordner wäre und nur zur Anzeige in <code>SmarGit</code> eingeladen werden sollte.</p>
<p>Nach einem Klick auf <code>OK</code> ist euer <code>repository</code> erstellt und ihr könnt mit nun Dateien erstellen, hinzufügen und mit euren Veränderungen loslegen! Es wird nun auf der linken Seite in der Liste angezeigt. Das Tracking der Dateien wäre momentan natürlich nur lokal. Um eine Verbindung mit <code>GitHub</code> zu erstellen, muss zunächst äquivalent zu der Beschreibung im Tutorial zu <code>GitHub</code> ein <code>repository</code> erstellt habt. Dort wurde bereits empfohlen, dass das neu erstellte <code>repository</code> zunächst leer ist und denselben Namen wie die lokale Version trägt. Es wird dabei eine URL kreiiert, unter der das <code>repository</code> zu finden ist. In diesem Fall würde diese so aussehen:</p>
<p><img src="/post/smartgit_github_url.png" /></p>
<p>Diese solltet ihr nun kopieren und wieder zurück auf <code>SmartGit</code> wechseln. Dort wählte ihr in der Übersichtsleiste zunächst <strong>Remote</strong> und dann <strong>Add…</strong>. Es erscheint eine Eingabe für die URL, die ihr eben kopiert habt.</p>
<p><img src="/post/smartgit_add_remote.png" /></p>
<p>Um die Einrichtung abzuschließen, müsst ihr nun noch einen <code>Push</code> durchführen. Nachdem dieser abgeschlossen ist, sollte das <code>repository</code> auch auf <code>GitHub</code> den <code>initial commit</code> anzeigen. Ab diesem Moment werden alle euren lokalen Änderungen durch einen <code>Push</code> auf <code>GitHub</code> abgelegt.</p>
<p><img src="/post/smartgit_github_pushing.png" /></p>
<!-- #### Weitere Funktionen -->
<!-- Insgesamt bieten `git` und `Smartgit` natürlich noch eine Fülle an anderen Funktionen, was schon die Benutzeroberfläche sehr deutlich macht. Die Besprechung aller Optionen würde den Rahmen sprengen und einige Erklärungen folgen auch noch im Teil zu der Advanced Nutzung. Trotzdem wollen wir hier nochmal einige weitere nützliche Funktionalitäten aufführen -->
<!-- ##### `Discard` -->
<!-- Über `Discard`, können wir Änderungen, die wir an den Dateien vorgenommen haben, verwerfen und würden somit wieder zu der Version der Datei zurückkehren, die wir von `GitHub` gepullt haben. -->
<!-- *Screenshot* -->
<!-- Hier gibt es zwei Unteroptionen: -->
<!--  1. `Discard to Stash`: Hierbei wird die veränderte Datei nicht unwiderruflich gelöscht, sondern dem `Stash` - quasi einem Papierkorb - hinzugefügt. Von hier aus können die veränderten Dateien wieder abgerufen werden, falls man sie doch noch benötigt. -->
<!--  2. `Discard`: Wenn die Veränderungen nicht mehr benötigt werden, reicht diese Option aus. Somit werden sie rückgängig gemacht und die Datei bleibt weiterhin auf ihrem letzten Stand bestehen. -->
<!-- ##### `Fetch` -->
<!-- `Fetch` ist euch vielleicht schon beim Befehl `Pull` als Option aufgefallen. Dort konntet ihr euch zwischen `Pull` und `Fetch Only` entscheiden.  -->
<!-- Der Unterschied zwischen den beiden Optionen besteht darin, dass beim `Fetch` lediglich die Informationen darüber abgerufen werden, ob seit unserem letzten `Push` Veränderungen an dem Projekt vorgenommen wurden und welche genau das sind. -->
<!-- Bei `Pull` hingegen werden sowohl diese Information abgerufen als auch alle Veränderungen auf unseren lokalen Ordner übertragen. Somit arbeiten wir direkt mit den veränderten Dateien weiter, während wir bei `Fetch` noch auf unserem eigenen letzten Stand bleiben. -->
<!-- Das Praktische daran ist, dass unsere lokalen Dateien bei `Fetch` nicht verändert werden. Somit erhalten wir einen Überblick über die Veränderungen, die seit unserem letzten `Push` von den anderen Kollaborator:innen vorgenommen wurden. Dadurch, dass keine Dateien verändert oder zerstört werden können, kann man beliebig oft diesen Befehl durchführen und muss keine Sorge haben, dass etwas am Projekt "kaputt" geht. -->
<!-- ##### `gitignore` -->
<!-- Wenn ihr bereits mit `GitHub` oder `SmartGit` gearbeitet habt, ist euch vielleicht schon aufgefallen, dass bei jeder Veränderung, die ihr an euren `R`-Dateien vorgenommen habt, in eurem `Staging environment` Dateien auftauchen, die `.RHistory` oder `.RData` heißen. Diese Dateien entstehen automatisch, wenn die `R`-Datei verändert wird, da sich bei einem neuen Skript ebenfalls der Output ändert, welcher automatisch von `R` als History abgespeichert wird. Da wir diese Dateien nicht benötigen, wollen wir sie nicht bei jeder Veränderung via `SmartGit` auf `GitHub` pushen.  -->
<!-- Eine erste Möglichkeit, um diese Datein beim committen zu ignorieren, wäre es, mit einem Rechtsklick auf sie draufzugehen und sie über `Discard` zu löschen. Somit verschwinden sie aus dem `Staging environment` und werden nicht auf `GitHub` gepusht. Hierbei wählen wir die Option `Discard` und nicht `Discard to Stash`. Da diese `R`-Dateien jedoch jedes Mal entstehen und wir sie bei jedem `Push` aufs Neue manuell aus dem environment löschen müssten, ist dieser Weg etwas umständlich. -->
<!-- Einfacher geht es mit dem sogenannten `.gitignore`. Hierbei wird ein neues file - das `.gitignore`-file - erstellt, in welchem wir festlegen, welche ungetrackten Dateien wir aus unserem Projekt ignorieren wollen.  -->
<!-- Der Code dieser Datei kann kompliziert aussehen, deswegen hier ein konkretes Beispiel für unseren `Praktikums`-Ordner: -->
<!-- *Screenshot* -->
<!-- Wir legen hier fest, dass die Dateien `.RHistory` und `.RData` ignoriert werden sollen.  -->
<!-- Bei der Erstellung der `.gitignore`-Datei kann uns `SmartGit` behilflich sein: -->
<!--  1. Wir machen einen Rechtsklick auf unsere zu ignorierende Datei im `Files`-Feld auf `SmartGit`. Hier wählen wir die Option `Remove`. Im nächsten Fenster bestätigen wir nochmals mit `Remove`. -->
<!--  *Screenshot* -->
<!--  2. Wir machen einen erneuten Rechtsklick auf die Datei und wählen jetzt die Option `Ignore`. -->
<!--  3. In dem Fenster, was sich jetzt öffnet, wählen wir die erste Option -->
<!-- ``` -->
<!-- Ignore explicitly (e.g. 'Makefile') -->
<!-- ``` -->
<!--  4. Im `Files`-Feld erscheint nun eine `.gitignore`-Datei. Hier klicken wir nach dem Rechtsklick auf `Stage`. Jetzt ist die neu erstellte Datei in unserem `Staging environment`. -->
<!--  5. Im letzten Schritt müssen wir die `.gitignore`-Datei noch committen, damit es auf unsere remote-Version des Projekts hochgeladen wird. -->
<!-- Wenn jetzt nach Veränderungen an eurem Ordner die `.RHistory`- oder `.RData`-Dateien auftauchen sollten, könnt ihr in eurem `Workflow` sehen, dass diese durch die `.gitignore`-Datei ignoriert werden. -->
<!-- *Screenshot* -->
<!-- ## Anderer Style -->
<!-- Workflow also alle `commits`, die jemals an unserem Projekt durchgeführt wurden. Dabei stehen jeweils der Name der Person, die den commit durchgeführt hat sowie das Änderungsdatum. So können wir auf einen Blick nachvollziehen, wer wann was an unserem Projekt verändert hat. -->
<!-- Auf der rechten Seite des Bildschirms sehen wir unten eine Übersicht über alle unsere Dateien, die wir seit dem letzten `Pull` lokal verändert haben. Sie erscheinen hier ganz automatisch. -->
<!-- ## Befehle -->
<!-- Unterschied zwische Rebase und Revert -->
<!-- bei einem wird alles was neuer war, als der Zeitpunkt zu dem man zurück geht, gelöscht und ist nicht zugreifbar -->
<!-- bei dem anderen wird der Rückgang zu dem alten Punkt als neuer Punkt im Working Tree angelegt. -->
</div>
</div>
</div>
