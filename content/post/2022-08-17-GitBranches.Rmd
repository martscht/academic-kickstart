---
title: Branches
date: '2022-08-01'
slug: branches
categories:
  - "gitintro"
tags: []
subtitle: ''
summary: ''
authors: [schloter, nehler]
featured: no
header:
  image: "/header/Branches.jpg"
caption: "[Courtesy of jplenio](https://pixabay.com/photos/tree-nature-wood-bare-tree-tribe-3097419/)"
projects: []
publishDate: '2022-08-17' 
---


### Was sind **Branches**?

Das Konzept von **Branches** lässt sich gut durch einen Baum visualisieren. Es gibt einen Stamm, der mit der Erde verwurzelt ist und den ganzen Baum trägt. Aus diesem Stamm wachsen viele verschiedene kleinere Äste heraus, die den Baum vielfältiger machen. In diesem Szenario ist der Hauptstamm unser **main**-**branch**. Dieser trägt das Hauptprojekt und ist von Beginn an da. Die anderen kleineren Äste sind **Branches**, die wir zusätzlich erstellen können. Diese sind viele verschiedene Versionen unseres Hauptprojekts und erlauben uns kreativ zu sein. 

![](/post/branches_Concept.png)
Für Psycholog/innen kann es zum  Beispiel nützlich sein bei Datenanalysen mit Branches zu arbeiten. Sagen wir mal, ihr habt in eurem Hauptprojekt  eure Analyse schon fertig, euch fällt aber im Nachhinein auf, dass es vielleicht noch einen besseren und einfacheren Weg gibt. Dann könnt ihr einen neuen **Branch** zu eurem Hauptprojekt erstellen, an dem ihr euren neuen Weg erstmal testweise ausprobieren könnt. Falls der neue Analyseweg doch nicht so klappt, wie ihr es euch vorgestellt habt, könnt ihr ganz einfach wieder in euer Hauptprojekt wechseln mit der funktionierenden Analyse und da weiterarbeiten.  

Es können natürlich auch weitere kleine Zweige aus unseren Ästen wachsen. Das würde dann so aussehen: 

![](/post/branches_Concept2.png)
Wenn ihr jetzt aber den neuen Analyseweg besser findet als den Alten und ihn in euer Hauptprojekt übernehmen wollt, mergt ihr die beiden. Der Ast verwächst also mit dem Baumstamm. Das funktioniert natürlich auch mit mehreren "Versionen". 

![](/post/branches_MergeGraphic.png)

<!-- Ich würde evtl. die Versionen grafiken komplett raus nehmen. Der Vorteil von Git soll ja sein, von solchen Nummerierungen Abstand zu gewinnen. Auf technischer Seite sind diese Versionen ja eher fertige Pakete, die vertrieben werden und deren Stand erhalten bleiben soll. Könnte man eher sagen "Auswertung für die erste Präsentation im Kolloquium" und dafür wir ein Zwei gemacht, der ewig stehen bleibt oder sowas. Können wir gerne mal drüber sprechen -->

Nun da das grobe Konzept erklärt ist, widmen wir uns mal der etwas technischeren Erklärung von **Branches**. Wir müssen zunächst verstehen wie <span style="color: darkred;">**Git**</span> Daten speichert. Eine grobe Erklärung lest ihr im Folgenden. Wenn ihr eine genauere technische Erklärung wollt, findet ihr sie unter [Appendix A](#AppendixA).

<!-- Können wir die folgenden beiden Abschnitte an unserem existierenden Beispiel vielleicht anlehnen? Mir ist auch nicht klar, was hier mit "unser Git-Repository" gemeint ist... -->

Nehmen wir als Beispiel einen Ordner mit drei Dateien. Wenn ihr diese in das *Staging Environment* packt und einen *Commit* durchführt, wird unter anderem eine Checksum für jede einzelne Datei erstellt. Wenn man jetzt einen *Commit* durchführt, wird ein Schnappschuss genau dieser Checksums erstellt, also auch ein Schnappschuss der zu den Checksums gehörigen Dateien. 
Das passiert bei jedem *Commit* und führt dazu, dass der Computer die jeweiligen Dateien durch ihre Checksums voneinander unterscheiden kann. 

Unser <span style="color: darkred;">**Git**</span> Repository enthält jetzt 5 Objekte: drei Blobs (die die Daten unserer Dateien enthalten), diesen übergeordnet das Tree-Objekt (das die Namen der Dateien zu den jeweiligen blobs zuordnen kann) und einen *Commit* (das einen Schnappschuss dieser Dateien erstellt). Ein Blob ist ein Objekttyp, der benutzt wird, um den Kontent jeder Datei in einem Repository unterzubringen. 

### Der Master-Branch

Der *master*-Zweig ist der default-**Branch** in <span style="color: darkred;">**Git**</span>. Dieser wird mit dem Befehl *git init* automatisch erstellt und die meisten Personen ändern dies nicht. Der *master*-**Branch** ist also nicht speziell, sondern einfach nur die Voreinstellung. 

![](/post/branches_master.png)

Wenn man jetzt mehrere *Commits* macht, zeigt der *master*-**Branch** immer auf den letzten getätigten *Commit*. Der Zeiger macht das für jeden neuen *Commit* automatisch. 

<!-- Woran kann man diesen Zeiger sehen? Und was heißt das eigentlich, darauf zeigen?-->

### Einen neuen **Branch** erstellen

Wir erstellen jetzt einen neuen **Branch** in dem Ordner Test namens "New". Die erste Möglichkeit ist über das Terminal. Navigiert zu dem Ordner in dem der neue **Branch** sein soll mit cd und gebt anschließend das Command `git branch New` ein. 

<!-- Kannst du das komplette Beispiel in den Ordner "Praktikum" übertragen und dabei die Ordnerstruktur aus der ersten Session auf deinem Arbeitslaptop einfach nachabauen? dann würde es stringenter aussehen -->

![](/post/branches_New.png)
Natürlich kann auch mit <span style="color: darkred;">**SmartGit**</span> ein neuer Branch erstellt werden. Hierzu öffnet ihr <span style="color: darkred;">**SmartGit**</span>, klickt oben in der Leiste auf **Branch** und dann auf *Add Branch*. Jetzt gebt ihr einen Namen ein (z.B. "New2") und bestätigt das. 

![](/post/branches_LocalBranches.png)

Auf <span style="color: darkred;">**SmartGit**</span> müssten euch nun unter **Local Branches** drei Optionen angezeigt werden: *master*, *New* und *New2*. 

Woher wissen wir auf welchem **Branch** wir uns gerade befinden?  In <span style="color: darkred;">**SmartGit**</span> ist das wie immer ziemlich einfach. Da wird der aktuelle **Branch** einfach dick gedruckt. 

Aber auch im Terminal gibt es die Möglichkeit herauszufinden, was unser aktueller **Branch** ist.
<span style="color: darkred;">**Git**</span> hat dazu einen speziellen Zeiger namens *HEAD*. Dieser zeigt immer auf den lokalen **Branch** auf dem man sich gerade befindet.Mit dem Befehl `git log --oneline --decorate` kann man im Terminal sehen, wo der *HEAD*-Zeiger gerade hinzeigt. 

![](/post/branches_HEAD.png)
Hier immer noch auf *master*. 

Auf <span style="color: darkred;">**GitHub**</span> seht ihr direkt auf der Startseite eures Projekts auf welchem **Branch** ihr euch befindet.

![](/post/branches_GitHub.png)

<!-- Vielleicht einen etwas größeren Ausschnitt nehmen, damit man sich besser vorstellen kann, wo auf der Seite es ist -->

### **Branches** wechseln

Wir wollen jetzt zu dem **Branch** *New* wechseln. In der Sprache von Git wird diese Betrachtung eines Branches als `checkout` bezeichnet. Über das Terminal ist der Befehl daher `git checkout New`. Der *HEAD*-Zeiger bewegt sich damit zu unserem ausgewählten **Branch**. Ob es geklappt hat, können wir mit dem bereits eben verwendeten Befehl `git log --oneline --decorate` testen. 

![](/post/branches_SwitchBranch.png)
Bei <span style="color: darkred;">**SmartGit**</span> muss man einfach nur mit Doppelklick auf den **Branch** aus der links unten angezeigten Liste gehen, in den man wechseln will. Dann sollte folgendes erscheinen, dass ihr dann bestätigt.

![](/post/branches_SmartGitSwitch.png)

Wenn man jetzt einen neuen *Commit* erstellt, wird nicht mehr der *master*-**Branch** auf diesen zeigen, sondern *New*. 

<!-- Was vielleicht auch interessant ist: die Dateien, die im Explorer angezeigt werdne, ändern sich äquivalent, dies kann man hier schonmal erwähnen und später vielleicht nochmal ausprobieren -->

Machen wir uns das Ganze mal an unserer Datei "Datenauswertung" deutlich. Sagen wir mal, dass wir mit den Daten einen `t.test()` durchführen wollen, uns aber noch nicht ganz sicher sind, ob das überhaupt etwas bringt. Dazu ändern wir erstmal die Datei. 

![](/post/branches_ÄnderungDatei.png)

<!-- Sind wir nicht schon auf New? durch die zwei verschiedenen Beispiele ist das irgendwie verwirrend? -->

Jetzt öffnen wir <span style="color: darkred;">**SmartGit**</span> und wechseln zu unserem **Branch** *New*. Wir führen nun einen `Commit` auf diesem **Branch** durch, der die oben aufgeführten Änderungen enthält. Unser *HEAD*-Zeiger zeigt nun auf *New*.  Wechselt nun mal zwischen den zwei **Branches** hin und her und schaut euch den obersten `Commit` an. Hier müsstet ihr den Unterschied sehen können, ihr habt zwei verschiedene Dateiversionen auf verschiedenen **Branches**.

<!-- Hier vielleicht auch nochmal bildlich zeigen, was gesehen werden soll -->

Falls ihr jetzt also auf *master* wechselt und hier irgendwelche Veränderungen macht, tut ihr das mit euerer alten Dateiversion (ohne die Veränderungen, die auf dem *New*-**Branch** gemacht wurden). So weit wollen wir allerdings jetzt noch nicht gehen. Wie ihr aus dem Abschnitt `Conflict Solver` in <span style="color: darkred;">**SmartGit**</span> wisst, entsteht ein Konflikt immer dann, wenn in derselben Zeile unterschiedliche Dinge stehen. Aktuell stehen unsere zwei **Branches** demnach nicht in einem Konflikt, da wir hier in *New* nur eine Zeile hinzugefügt haben und in der Zeile unseres *master*-**Branches** nichts steht. Ein Merge sollte also problemlos funktionieren

Da wir zu Übungszwecken einen Merge mit Konflikt ausführen wollen, werden wir jetzt sich widersprechende **Branches** erstellen. Dafür gehen wir wieder in unsere Datei und ändern dieselbe Zeile wie vorhin. 

![](/post/branches_ÄnderungDatei2.png)

Wir stellen sicher, dass wir uns auf dem *master*-**Branch** befinden und führen einen `Commit`durch. Unser Projekt hat jetzt eine *Divergent History*, was soviel bedeutet wie auseinandergehende Geschichte. 
Die Datei auf dem einen **Branch** hat einen `t.test()`, die andere einen Vektor namens *z*.  

<!-- Vielleicht erstmal ein Beispiel ausdenken, wie sich die Branches nicht widersprechen und dann einen widersprechenden machen / dabei auch jeweils einen Merge durchführen!
!!!!!!!!!!!!!Ist eigentlich auch schon drinnen, Zeile 92 abwärts, soll das noch detaillierter werden? 
Du hast die Situation beschrieben, ja. Aber ich hätte den Merge auch durchgeführt, um das Prinzip erstmal ohne Konflikt klar zu machen-->

Das gibt uns nun die Möglichkeit zwischen den Zweigen zu wechseln und so verschiedene Versionen desselben Projekts zu erstellen. 

<!-- Hier bekommt man in Kombination mit den Bildern von oben langsam wirklich einen falschen Eindruck. Nicht zu viele verschiedene Versionen sollten entstehen, höchstens ein Original und eine Entwicklungsdatei -->

Man kann mit der Datei herumexperimentieren, ohne an dem Original etwas ändern zu müssen. 
Natürlich kann man zwei **Branches** auch wieder zu einem zusammenführen. Das Prinzip ist dasselbe wie wenn man zwei Autoren hat, die unterschiedliche Versionen einer Datei erstellt haben und dann den `Conflict Solver` benutzen müssen. Das steht im Abschnitt über <span style="color: darkred;">**SmartGit**</span>. 
 
<!-- Die vorigen Beschreibungen sind ja eher allgemeine Abschnitte, die teils in der Einleitung oder zumindest vor der ersten Erwähnung des Merges wichtig sind  -->
 
### Zwei **Branches** Mergen

Wenn ihr dem Tutorial bis hierher gefolgt seid, dann müsstet ihr zwei verschiedene Versionen eines Projekts auf verschiedenen **Branches** liegen haben. 

Wir wollen nun den **Branch** *New* und *master* zusammenfügen. Dafür gehen wir bei <span style="color: darkred;">**SmartGit**</span> auf den Button *Merge* rechts oben in der Ecke. 

Dann öffnet sich ein Fenster bei dem wir auf *Merge to Working Tree* gehen.

<span style="color: darkred;">**SmartGit**</span> sollte nun so aussehen: 

![](/post/branches_MergeState.png)

Wenn wir jetzt auf die entsprechende Datei gehen, von der es auf den zwei **Branches** unterschiedliche Versionen gibt, sollte man den *Conflict Solver* angezeigt bekommen. Wie dieser funktioniert, steht im Abschnitt über <span style="color: darkred;">**SmartGit**</span>. 

<!-- Auch wenn es da steht, vielleicht hier nochmal eine kurze Zusammenfassung -->

Jetzt habt ihr zwei **Branches** erfolgreich gemerged.

<!-- Wie wird das ersichtlich - bspw. in der Smart-Git Ansicht? -->

<!-- Ein Fazit sollte auch noch gezogen werden -->

***


## Appendix A

<details><summary> **Tieferes Verständnis von Speicherprozessen** </summary> 

Eine Checksum oder auch Prüfsumme wird jedes Mal erstellt, wenn man eine Datei in das *Staging Environment* lädt. Diese kann zum Beispiel so aussehen: "7a3k9". Mit der Checksum soll die Integrität von Daten geprüft werden. 
Das beinhaltet die Kontrolle der Korrektheit, Vollständigkeit und Konsistenz unserer Datei. 
Der Computer kann so sicherstellen, ob die Datei einen Fehler hat oder nicht. 

Nützlich ist das zum Beispiel, wenn ihr eine Datei aus dem Internet ladet und sichergehen wollt, dass kein Fehler beim Herunterladen passiert ist. Ihr müsst einfach nur die Checksum der Datei aus dem Internet und euerer Datei auf dem Computer vergleichen. Sollten die Checksums identisch sein, ist kein Fehler aufgetreten. 

Zurück zu <span style="color: darkred;">**Git**</span>. Ihr habt gerade eure Datei in das *Staging Environment* geladen und dabei für diese Datei eine Checksum erstellt. Anschließend wird diese Version der Datei in einem <span style="color: darkred;">**Git**</span>-Repository untergebracht und die Checksum zum *Staging Environment* hinzugefügt. 
Wenn ihr jetzt den `Commit` durchführt, nimmt <span style="color: darkred;">**Git**</span> die Checksum jedes Subordners und speichert diese in einem Tree-Objekt in eurem <span style="color: darkred;">**Git**</span>-Repository. Darauf folgend wird ein `Commit`-Objekt erstellt, das diese Metadaten enthält. So kann ein Schnappschuss der Daten erstellt werden, wann immer es gebraucht wird. 

Noch ein kleiner Ausflug zum Thema Metadaten. 
Wenn ihr ein Foto von etwas macht, speichert eure Kamera oder euer Smartphone nicht nur das Foto, sondern auch die zugehörigen Metadaten. 
Dazu kann gehören: 

Wann ist das Foto entstanden?
Wo ist das Foto entstanden? 
Was für eine Kamera wurde benutzt?  
...

Metadaten sind also im Prinzip Daten, die Informationen über bestimmte Merkmale anderer Daten enthalten. 

