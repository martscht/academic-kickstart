---
title: Branches
date: '2022-08-01'
slug: branches
categories:
  - "gitintro"
tags: []
subtitle: ''
summary: ''
authors: [schloter, nehler]
featured: no
header:
  image: "/header/Branches.jpg"
caption: "[Courtesy of jplenio](https://pixabay.com/photos/tree-nature-wood-bare-tree-tribe-3097419/)"
projects: []
publishDate: '2021-08-12'
---


### Was sind **Branches**?Wozu brauch ich das?

Das Konzept von **Branches** lässt sich gut durch einen Baum visualisieren. Es gibt einen Stamm, der mit der Erde verwurzelt ist und den ganzen Baum trägt. Aus diesem Stamm wachsen viele verschiedene kleinere Äste heraus, die den Baum vielfältiger machen. In diesem Szenario ist der Hauptstamm unser **main**-**branch**. Dieser trägt das Hauptprojekt und ist von Beginn an da. Die anderen kleineren Äste sind **Branches**, die wir zusätzlich erstellen können. Diese sind viele verschiedene Versionen unseres Hauptprojekts und erlauben uns kreativ zu sein. 

![](/post/branches_Concept.png)
<!-- Weiterhin wäre es noch cool, ein Anschauungsbeispiel einzuführen, bspw. Analyse soll erstmal testweise eingeführt werden und nicht gleich in der Hauptversion erscheinen. -->
Es können natürlich auch weitere kleine Zweige aus unseren Ästen wachsen. Das würde dann so aussehen: 
![](/post/branches_Concept2.png)

Nun da das grobe Konzept erklärt ist, widmen wir uns mal der etwas technischeren Erklärung von **Branches**. Wir müssen zunächst verstehen wie <span style="color: darkred;">**Git**</span> Daten speichert. Eine genaue Erklärung findet ihr unter [Appendix A](#AppendixA).

Nehmen wir als Beispiel einen Ordner mit drei Dateien. Wenn ihr diese in das *Staging Environment* packt und einen *Commit* durchführt, wird unter anderem eine Checksum für jede einzelne Datei erstellt. Wenn man jetzt einen *Commit* durchführt, wird ein Schnappschuss genau dieser Checksums erstellt, also auch ein Schnappschuss der zu den Checksums gehörigen Dateien. 
Das passiert bei jedem *Commit* und führt dazu, dass der Computer die jeweiligen Dateien durch ihre Checksums voneinander unterscheiden kann. 

Unser <span style="color: darkred;">**Git**</span> Repository enthält jetzt 5 Objekte: drei Blobs (die die Daten unserer Dateien enthalten), diesen übergeordnet das Tree-Objekt (das die Namen der Dateien zu den jeweiligen blobs zuordnen kann) und einen *Commit* (das einen Schnappschuss dieser Dateien erstellt). 

###Der Master-Branch

Der *master*-Zweig ist der default-**Branch** in <span style="color: darkred;">**Git**</span>. Dieser wird mit dem Befehl *git init* automatisch erstellt und die meisten Personen ändern dies nicht. Der *master*-**Branch** ist also nicht speziell, sondern einfach nur die Voreinstellung. 

![](/post/branches_master.png)

Wenn man jetzt mehrere *Commits* macht, zeigt der *master*-**Branch** immer auf den letzten getätigten *Commit*. Der Zeiger macht das für jeden neuen *Commit* automatisch. 

###Einen neuen **Branch** erstellen

Was passiert also, wenn man noch einen **Branch** erstellt? Man erzeugt einen neuen Zeiger, den man bewegen kann. 

Wir erstellen jetzt einen neuen **Branch** in dem Ordner Test namens "New". 
Der erste Weg ist über das Terminal. Navigiert zu dem Ordner in dem der neue **Branch** sein soll mit cd und gebt anschließend das Command *$ git branch testing* ein. 

![](/post/branches_New.png)
Natürlich kann auch mit <span style="color: darkred;">**SmartGit**</span> ein neuer Branch erstellt werden. Hierzu öffnet ihr <span style="color: darkred;">**SmartGit**</span>, klickt oben in der Leiste auf **Branch** und dann auf *Add Branch*. Jetzt gebt ihr einen Namen ein (z.B. "New2") und bestätigt das. 

![](/post/branches_LocalBranches.png)

Auf <span style="color: darkred;">**SmartGit**</span> müssten euch nun unter **Local Branches** drei Optionen angezeigt werden: *master*, *New* und *New2*. 

Woher wissen wir auf welchem **Branch** wir uns gerade befinden? 

In <span style="color: darkred;">**SmartGit**</span> ist das wie immer ziemlich einfach. Da wird der aktuelle **Branch** einfach dick gedruckt. 

Aber auch im Terminal gibt es die Möglichkeit herauszufinden, was unser aktueller **Branch** ist.
<span style="color: darkred;">**Git**</span> hat dazu einen speziellen Zeiger namens *HEAD*. Dieser zeigt immer auf den lokalen **Branch** auf dem man sich gerade befindet. 

Mit dem Befehl *git log --oneline --decorate* kann man im Terminal sehen, wo der *HEAD*-Zeiger gerade hinzeigt. 


![](/post/branches_HEAD.png)
Hier immer noch auf **master**. 

Auch  

<!-- Vielleicht noch zeigen, dass man auch auf GitHub die Branches angezeigt bekommt -->

###**Branches** wechseln

Wir wollen jetzt zu dem **Branch** *New* wechseln. Über das Terminal geschieht das mit dem Befehl *git checkout New*. Das bewegt den *HEAD*-Zeiger zu unserem ausgewählten **Branch**. Testen können wir das wieder mit *git log --oneline --decorate*. 

![](/post/branches_SwitchBranch.png)
Bei <span style="color: darkred;">**SmartGit**</span> muss man einfach nur mit Doppelklick links unten auf den **Branch** gehen in den man wechseln will.
Dann sollte folgendes erscheinen, dass ihr dann bestätigt.

![](/post/branches_SmartGitSwitch.png)
Wenn man jetzt einen neuen *Commit* erstellt, wird nicht mehr der *master*-**Branch** auf diesen zeigen, sondern *New*. 
Wechseln wir jetzt also wieder zurück auf *master* geschehen zwei Sachen. 
Erstens wechselt der *HEAD*-Zeiger wieder zu *master* und es wird der *Commit* angezeigt auf dem *master* zuletzt stehen geblieben ist. 
Da der neue *Commit* auf einem anderen **Branch** getätigt wurde.
Falls ihr jetzt also hier irgendwelche Veränderungen macht, tut ihr das mit euerer alten Dateiversion (ohne die Veränderungen, die auf dem *New*-**Branch** gemacht wurden).

<!-- Hier wird relativ deutlich, dass wir einen praktischen Ansatz brauchen - sonst ist das schwer sich vorzustellen -->

Machen wir nun genau das und erstellen wieder einen *Commit* (am besten in derselben Datei wie vorher). 

Unser Projekt hat jetzt eine *Divergent History*, was soviel bedeutet wie auseinandergehende Geschichte. 
Da die Veränderungen auf *New* und die auf *master* durch die zwei **Branches** isoliert voneinander sind. 

<!-- Vielleicht erstmal ein Beispiel ausdenken, wie sich die Branches nicht widersprechen und dann einen widersprechenden machen -->

Das gibt uns nun die Möglichkeit entweder immer zwischen den Zweigen zu wechseln und so verschiedene Versionen desselben Projekts zu erstellen. 
Oder diese wieder zu mergen. Ähnlich wie im Abschnitt über <span style="color: darkred;">**SmartGit**</span> der *Conflict Solver* es für die zwei verschiedenen Versionen von unterschiedlichen Autoren es getan hat. 

###Zwei **Branches** Mergen

Wenn ihr dem Tutorial bis hierher gefolgt seid, dann müsstet ihr zwei verschiedene Versionen eines Projekts auf verschiedenen **Branches** liegen haben. 

Wir wollen nun den **Branch** *New* und **master** zusammenfügen. Dafür gehen wir bei <span style="color: darkred;">**SmartGit**</span> auf den Button *Merge* rechts oben in der Ecke. 

Dann öffnet sich ein Fenster bei dem wir auf "Merge to Working Tree* gehen.

<span style="color: darkred;">**SmartGit**</span> sollte nun so aussehen: 

![](/post/branches_MergeState.png)

Wenn wir jetzt auf die entsprechende Datei gehen, von der es auf den zwei **Branches** unterschiedliche Versionen gibt, sollte man den *Conflict Solver* angezeigt bekommen. Wie dieser funktioniert, steht im Abschnitt über <span style="color: darkred;">**SmartGit**</span>. 

Jetzt habt ihr zwei **Branches** erfolgreich gemerged. 

###Änderungen rückgängig machen 

Situation ist Folgende: Wir haben nur einen **master**-**Branch** und einen *Commit* erstellt, den wir jetzt nicht mehr haben wollen. Wie kommen wir jetzt auf den vorherigen *Commit*? Wie machen wir den letzten *Commmit* rückgängig? 

<!-- Kommt etwas plötzlich, auch hier wäre ein Anschauungsbeispiel wertvoll (und vielleicht sollten wir das eher in ein anderes Tut einbauen) -->

Dafür gibt es verschiedene Befehle, die wir jetzt durchgehen werden. 

*git checkout* 

Mit  diesem Befehl kann man aus dem jetzigen *Commit* rausgehen und das Repository auf den vorherigen Status zurücksetzen. Wir arbeiten jetzt in keinem **Branch** mehr. Alle in diesem Status durchgeführten *Commits* werden bei der nächsten Speicherbereinigung gelöscht. 

Um das zu verhindern, kann man für diese verwaisten *Commits* einen eigenen **Branch** erstellen mit `$git checkout -b name_neuer_commit`. 
Jetzt kann man mit diesem neuen **Branch** weiterarbeiten. 

Diese Strategie ist allerdings nicht geeignet, wenn man den vorherigen **Branch** trotzdem noch benötigt, da in diesem der ungewollte *Commit* noch existiert. 

*git revert* 

Mit dem Befehl `$git revert HEAD` wird ein neuer *Commit* erstellt, der den vorherigen reverted. Wenn ihr `$git log` ausführt, werdet ihr eueren ungewollten *Commit* zwar noch sehen, aber rein technisch ist dieser rückgängig gemacht worden. 
Das ist der ideale Befehl für öffentliche Repositorys. Wenn man allerdings einen geordnetes Log haben will, sollte man etwas anderes versuchen. 

*git reset* 

Mit `$git reset --hard 76d5sj9` wird der Verlauf auf diesen ausgewählten *Commit* zurückgesetzt. Die ungewollten *Commits* kann man im Log nicht mehr sehen. 

Dieses Zurücksetzen eignet sich gut für lokale Repositorys, nicht so gut für remote Repositorys. 

Je nach Befehl passiert etwas anderes, ihr müsst euch den Befehl raussuchen, der am besten zu euerer Situation passt. Aber trotzdem sollte man mit dem endgültigen Löschen von *Commits* natürlich immmer vorsichtig sein. 

Das Alles waren nun Befehle für die Konsole oder das Terminal. Wie kann man den letzten *Commit* auf <span style="color: darkred;">**SmartGit**</span> rückgängig machen?

Indem ihr in <span style="color: darkred;">**SmartGit**</span> auf *Local*, oben in der Leiste geht und dann nur noch auf `Undo last Commit` klickt. Damit kehrt ihr wieder auf den Stand vor diesem *Commit* zurück. 

***

## Appendix A

<details><summary> **Checksum** </summary>

Eine Checksum oder auch Prüfsumme wird jedes Mal erstellt, wenn man eine Datei in das *Staging Environment* lädt. Diese kann zum Beispiel so aussehen: "7a3k9". Mit der Checksum soll die Integrität von Daten geprüft werden. 
Das beinhaltet die Kontrolle der Korrektheit, Vollständigkeit und Konsistenz unserer Datei. 
Der Computer kann so sicherstellen, ob die Datei einen Fehler hat oder nicht. 

Nützlich ist das zum Beispiel, wenn ihr eine Datei aus dem Internet ladet und sichergehen wollt, dass kein Fehler beim Herunterladen passiert ist. Ihr müsst einfach nur die Checksum der Datei aus dem Internet und euerer Datei auf dem Computer vergleichen. Sollten die Checksums identisch sein, ist kein Fehler aufgetreten. 

Zurück zu <span style="color: darkred;">**Git**</span>. Ihr habt gerade eure Datei in das *Staging Environment* geladen und dabei für diese Datei eine Checksum erstellt. Anschließend wird diese Version der Datei in einem <span style="color: darkred;">**Git**</span>-Repository untergebracht und die Checksum zum *Staging Environment* hinzugefügt. Diese <span style="color: darkred;">**Git**</span>-Repositorys werden auch "blobs" genannt. 

Wenn ihr jetzt den `Commit` durchführt, nimmt <span style="color: darkred;">**Git**</span> die Checksum jedes Subordners und speichert diese in einem Tree-Objekt in eurem <span style="color: darkred;">**Git**</span>-Repository. Darauf folgend wird ein `Commit`-Objekt erstellt, das diese Metadaten enthält. So kann ein Schnappschuss der Daten erstellt werden, wann immer es gebraucht wird. 
Noch ein kleiner Ausflug zum Thema Metadaten. 
Wenn ihr ein Foto von etwas macht, speichert eure Kamera oder euer Smartphone nicht nur das Foto, sondern auch die zugehörigen Metadaten. 
Dazu kann gehören: 

Wann ist das Foto entstanden?
Wo ist das Foto entstanden? 
Was für eine Kamera wurde benutzt? 
...

Metadaten sind also im Prinzip Daten, die Informationen über bestimmte Merkmale anderer Daten enthalten. 



