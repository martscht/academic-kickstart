---
title: Branches
date: '2022-08-01'
slug: branches
categories:
  - "gitintro"
tags: []
subtitle: ''
summary: ''
authors: [schloter, nehler]
featured: no
header:
  image: "/header/Branches.jpg"
caption: "[Courtesy of jplenio](https://pixabay.com/photos/tree-nature-wood-bare-tree-tribe-3097419/)"
projects: []
publishDate: '2022-08-17'
---


### Was sind **Branches**?

Das Konzept von **Branches** lässt sich gut durch einen Baum visualisieren. Es gibt einen Stamm, der mit der Erde verwurzelt ist und den ganzen Baum trägt. Aus diesem Stamm wachsen viele verschiedene kleinere Äste heraus, die den Baum vielfältiger machen. In diesem Szenario ist der Hauptstamm unser **main**-**branch**. Dieser trägt das Hauptprojekt und ist von Beginn an da. Die anderen kleineren Äste sind **Branches**, die wir zusätzlich erstellen können. Diese sind viele verschiedene Versionen unseres Hauptprojekts und erlauben uns kreativ zu sein. 

![](/post/branches_Concept.png)
<!-- Weiterhin wäre es noch cool, ein Anschauungsbeispiel einzuführen, bspw. Analyse soll erstmal testweise eingeführt werden und nicht gleich in der Hauptversion erscheinen. -->
Es können natürlich auch weitere kleine Zweige aus unseren Ästen wachsen. Das würde dann so aussehen: 
![](/post/branches_Concept2.png)

Nun da das grobe Konzept erklärt ist, widmen wir uns mal der etwas technischeren Erklärung von **Branches**. Wir müssen zunächst verstehen wie <span style="color: darkred;">**Git**</span> Daten speichert. Eine genaue Erklärung findet ihr unter [Appendix A](#AppendixA).

Nehmen wir als Beispiel einen Ordner mit drei Dateien. Wenn ihr diese in das *Staging Environment* packt und einen *Commit* durchführt, wird unter anderem eine Checksum für jede einzelne Datei erstellt. Wenn man jetzt einen *Commit* durchführt, wird ein Schnappschuss genau dieser Checksums erstellt, also auch ein Schnappschuss der zu den Checksums gehörigen Dateien. 
Das passiert bei jedem *Commit* und führt dazu, dass der Computer die jeweiligen Dateien durch ihre Checksums voneinander unterscheiden kann. 

Unser <span style="color: darkred;">**Git**</span> Repository enthält jetzt 5 Objekte: drei Blobs (die die Daten unserer Dateien enthalten), diesen übergeordnet das Tree-Objekt (das die Namen der Dateien zu den jeweiligen blobs zuordnen kann) und einen *Commit* (das einen Schnappschuss dieser Dateien erstellt). 

<!-- Ich würde die Branches vielleicht nicht so mit den Versionsnummern halten - außerdem ist ja ein Teilzweck acuh, dass sie zurück in den Main Branch kommen. Das sollte vielleicht auf den Schaubildern noch auftauchen-->
<!-- Blobs wird hier nicht mehr erklärt -->

### Der Master-Branch

Der *master*-Zweig ist der default-**Branch** in <span style="color: darkred;">**Git**</span>. Dieser wird mit dem Befehl *git init* automatisch erstellt und die meisten Personen ändern dies nicht. Der *master*-**Branch** ist also nicht speziell, sondern einfach nur die Voreinstellung. 

![](/post/branches_master.png)

Wenn man jetzt mehrere *Commits* macht, zeigt der *master*-**Branch** immer auf den letzten getätigten *Commit*. Der Zeiger macht das für jeden neuen *Commit* automatisch. 

### Einen neuen **Branch** erstellen

Wir erstellen jetzt einen neuen **Branch** in dem Ordner Test namens "New". 
Die erste Möglichkeit ist über das Terminal. Navigiert zu dem Ordner in dem der neue **Branch** sein soll mit cd und gebt anschließend das Command `git branch New` ein. 

![](/post/branches_New.png)
Natürlich kann auch mit <span style="color: darkred;">**SmartGit**</span> ein neuer Branch erstellt werden. Hierzu öffnet ihr <span style="color: darkred;">**SmartGit**</span>, klickt oben in der Leiste auf **Branch** und dann auf *Add Branch*. Jetzt gebt ihr einen Namen ein (z.B. "New2") und bestätigt das. 

![](/post/branches_LocalBranches.png)

Auf <span style="color: darkred;">**SmartGit**</span> müssten euch nun unter **Local Branches** drei Optionen angezeigt werden: *master*, *New* und *New2*. 

Woher wissen wir auf welchem **Branch** wir uns gerade befinden?  In <span style="color: darkred;">**SmartGit**</span> ist das wie immer ziemlich einfach. Da wird der aktuelle **Branch** einfach dick gedruckt. 

Aber auch im Terminal gibt es die Möglichkeit herauszufinden, was unser aktueller **Branch** ist.
<span style="color: darkred;">**Git**</span> hat dazu einen speziellen Zeiger namens *HEAD*. Dieser zeigt immer auf den lokalen **Branch** auf dem man sich gerade befindet.Mit dem Befehl `git log --oneline --decorate` kann man im Terminal sehen, wo der *HEAD*-Zeiger gerade hinzeigt. 

![](/post/branches_HEAD.png)
Hier immer noch auf *master*. 
<!-- Vielleicht noch zeigen, dass man auch auf GitHub die Branches angezeigt bekommt -->

### **Branches** wechseln

Wir wollen jetzt zu dem **Branch** *New* wechseln. In der Sprache von Git wird diese Betrachtung eines Branches als `checkout` bezeichnet. Über das Terminal ist der Befehl daher `git checkout New`. Der *HEAD*-Zeiger bewegt sich damit zu unserem ausgewählten **Branch**. Ob es geklappt hat, können wir mit dem bereits eben verwendeten Befehl `git log --oneline --decorate` testen. 

![](/post/branches_SwitchBranch.png)
Bei <span style="color: darkred;">**SmartGit**</span> muss man einfach nur mit Doppelklick auf den **Branch** aus der links unten angezeigten Liste gehen, in den man wechseln will. Dann sollte folgendes erscheinen, dass ihr dann bestätigt.

![](/post/branches_SmartGitSwitch.png)

Wenn man jetzt einen neuen *Commit* erstellt, wird nicht mehr der *master*-**Branch** auf diesen zeigen, sondern *New*.  Wechseln wir jetzt also wieder zurück auf *master* geschehen zwei Sachen. 

<!-- Was vielleicht auch interessant ist: die Dateien, die im Explorer angezeigt werdne, ändern sich äquivalent -->

Erstens wechselt der *HEAD*-Zeiger wieder zu *master* und es wird der *Commit* angezeigt auf dem *master* zuletzt stehen geblieben ist. Da der neue *Commit* auf einem anderen **Branch** getätigt wurde.

Falls ihr jetzt also hier irgendwelche Veränderungen macht, tut ihr das mit euerer alten Dateiversion (ohne die Veränderungen, die auf dem *New*-**Branch** gemacht wurden).

Probieren wir das Ganze mal an der Datei Datenauswertung aus. Sagen wir mal, dass wir mit den Daten einen `t.test()` durchführen wollen, uns aber noch nicht ganz sicher sind, ob das überhaupt etwas bringt. Dazu ändern wir erstmal die Datei. 

<!-- Eher nach oben schieben / vor dem Hin und her wechseln machen -->

![](/post/branches_ÄnderungDatei.png)
Jetzt öffnen wir <span style="color: darkred;">**SmartGit**</span> und wechseln zu unserem **Branch** *New*. Wir führen nun einen `Commit` auf diesem **Branch** durch, der die oben aufgeführten Änderungen enthält. Wechselt nun mal zwischen den zwei **Branches** hin und her und schaut euch den obersten `Commit` an. Hier müsstet ihr den Unterschied sehen können.

Diese zwei **Branches** widersprechen sich nun nicht. Wie ihr aus dem Abschnitt `Conflict Solver` in <span style="color: darkred;">**SmartGit**</span> wisst, entsteht ein Konflikt dann, wenn in derselben Zeile unterschiedliche Dinge stehen. 

Da wir hier nur eine Zeile hinzugefügt haben und in der Zeile unseres *master*-**Branches** nichts steht, wird hier kein Konflikt beim mergen der Zweige entstehen. 

Da wir zu Übungszwecken einen Merge mit Konflikt ausführen wollen, werden wir jetzt sich widersprechende **Branches** erstellen. Dafür gehen wir wieder in unsere Datei und ändern dieselbe Zeile wie vorhin. 

![](/post/branches_ÄnderungDatei2.png)

<!-- Sind wir hier nicht noch im Master Branch? -->
Dann wechseln wir zum *master*-**Branch** und führen einen `Commit`durch. Unser Projekt hat jetzt eine *Divergent History*, was soviel bedeutet wie auseinandergehende Geschichte. 
Die Datei auf dem einen **Branch** hat einen `t.test()`, die andere einen Vektor namens *z*.  

<!-- Vielleicht erstmal ein Beispiel ausdenken, wie sich die Branches nicht widersprechen und dann einen widersprechenden machen / dabei auch jeweils einen Merge durchführen!-->

Das gibt uns nun die Möglichkeit zwischen den Zweigen zu wechseln und so verschiedene Versionen desselben Projekts zu erstellen. 
Man kann mit der Datei herumexperimentieren, ohne an dem Original etwas ändern zu müssen. 
Natürlich kann man zwei **Branches** auch wieder zu einem zusammenführen. Das Prinzip ist dasselbe wie wenn man zwei Autoren hat, die unterschiedliche Versionen einer Datei erstellt haben und dann den `Conflict Solver` benutzen müssen. Das steht im Abschnitt über <span style="color: darkred;">**SmartGit**</span>. 
 
<!-- Die vorigen Beschreibungen sind ja eher allgemeine Abschnitte, die teils in der Einleitung oder zumindest vor der ersten Erwähnung des Merges wichtig sind  -->
 
### Zwei **Branches** Mergen

Wenn ihr dem Tutorial bis hierher gefolgt seid, dann müsstet ihr zwei verschiedene Versionen eines Projekts auf verschiedenen **Branches** liegen haben. 

Wir wollen nun den **Branch** *New* und *master* zusammenfügen. Dafür gehen wir bei <span style="color: darkred;">**SmartGit**</span> auf den Button *Merge* rechts oben in der Ecke. 

Dann öffnet sich ein Fenster bei dem wir auf *Merge to Working Tree* gehen.

<span style="color: darkred;">**SmartGit**</span> sollte nun so aussehen: 

![](/post/branches_MergeState.png)

Wenn wir jetzt auf die entsprechende Datei gehen, von der es auf den zwei **Branches** unterschiedliche Versionen gibt, sollte man den *Conflict Solver* angezeigt bekommen. Wie dieser funktioniert, steht im Abschnitt über <span style="color: darkred;">**SmartGit**</span>. 

Jetzt habt ihr zwei **Branches** erfolgreich gemerged.

***

<!-- Hinweis auf den Appendix sollte irgendwo im Text sichtbar sein -->

## Appendix A

<details><summary> **Tieferes Verständnis von Speicherprozessen** </summary>

Eine Checksum oder auch Prüfsumme wird jedes Mal erstellt, wenn man eine Datei in das *Staging Environment* lädt. Diese kann zum Beispiel so aussehen: "7a3k9". Mit der Checksum soll die Integrität von Daten geprüft werden. 
Das beinhaltet die Kontrolle der Korrektheit, Vollständigkeit und Konsistenz unserer Datei. 
Der Computer kann so sicherstellen, ob die Datei einen Fehler hat oder nicht. 

Nützlich ist das zum Beispiel, wenn ihr eine Datei aus dem Internet ladet und sichergehen wollt, dass kein Fehler beim Herunterladen passiert ist. Ihr müsst einfach nur die Checksum der Datei aus dem Internet und euerer Datei auf dem Computer vergleichen. Sollten die Checksums identisch sein, ist kein Fehler aufgetreten. 

Zurück zu <span style="color: darkred;">**Git**</span>. Ihr habt gerade eure Datei in das *Staging Environment* geladen und dabei für diese Datei eine Checksum erstellt. Anschließend wird diese Version der Datei in einem <span style="color: darkred;">**Git**</span>-Repository untergebracht und die Checksum zum *Staging Environment* hinzugefügt. Diese <span style="color: darkred;">**Git**</span>-Repositorys werden auch "blobs" genannt. 

Wenn ihr jetzt den `Commit` durchführt, nimmt <span style="color: darkred;">**Git**</span> die Checksum jedes Subordners und speichert diese in einem Tree-Objekt in eurem <span style="color: darkred;">**Git**</span>-Repository. Darauf folgend wird ein `Commit`-Objekt erstellt, das diese Metadaten enthält. So kann ein Schnappschuss der Daten erstellt werden, wann immer es gebraucht wird. 

Noch ein kleiner Ausflug zum Thema Metadaten. 
Wenn ihr ein Foto von etwas macht, speichert eure Kamera oder euer Smartphone nicht nur das Foto, sondern auch die zugehörigen Metadaten. 
Dazu kann gehören: 

Wann ist das Foto entstanden?
Wo ist das Foto entstanden? 
Was für eine Kamera wurde benutzt?  
...

Metadaten sind also im Prinzip Daten, die Informationen über bestimmte Merkmale anderer Daten enthalten. 

