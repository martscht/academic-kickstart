---
title: Branches
date: '2022-08-01'
slug: branches
categories:
  - "gitintro"
tags: []
subtitle: ''
summary: ''
authors: [schloter, nehler]
featured: no
header:
  image: "/header/Branches.jpg"
caption: "[Courtesy of Pixabay](https://pixabay.com/photos/tree-nature-wood-bare-tree-tribe-3097419/)"
projects: []
publishDate: '2022-08-17' 
---


### Was sind **Branches**?

Das Konzept von **Branches** lässt sich gut durch einen Baum visualisieren. Es gibt einen Stamm, der mit der Erde verwurzelt ist und den ganzen Baum trägt. Aus diesem Stamm wachsen viele verschiedene kleinere Äste heraus, die den Baum vielfältiger machen. In diesem Szenario ist der Hauptstamm unser **main**-**branch**. Dieser trägt das Hauptprojekt und ist von Beginn an da. Die anderen kleineren Äste sind **Branches**, die wir zusätzlich erstellen können. Diese sind viele verschiedene Versionen unseres Hauptprojekts und erlauben uns kreativ zu sein. 


Für Psycholog/innen kann es zum  Beispiel nützlich sein bei Datenanalysen mit Branches zu arbeiten. Sagen wir mal, ihr habt in eurem Hauptprojekt  eure Analyse schon fertig, euch fällt aber im Nachhinein auf, dass es vielleicht noch einen besseren und einfacheren Weg gibt. Dann könnt ihr einen neuen **Branch** zu eurem Hauptprojekt erstellen, an dem ihr euren neuen Weg erstmal testweise ausprobieren könnt. Falls der neue Analyseweg doch nicht so klappt, wie ihr es euch vorgestellt habt, könnt ihr ganz einfach wieder in euer Hauptprojekt wechseln mit der funktionierenden Analyse und da weiterarbeiten.  

Wenn ihr jetzt aber den neuen Analyseweg besser findet als den Alten und ihn in euer Hauptprojekt übernehmen wollt, mergt ihr die beiden. Der Ast verwächst also mit dem Baumstamm.  

![](/post/branches_MergeGraphic.png)

Nun da das grobe Konzept erklärt ist, widmen wir uns mal der etwas technischeren Erklärung von **Branches**. Wir müssen zunächst verstehen wie <span style="color: darkred;">**Git**</span> Daten speichert. Eine grobe Erklärung lest ihr im Folgenden. Wenn ihr eine genauere technische Erklärung wollt, findet ihr sie unter [Appendix A](#AppendixA).

Nehmen wir hier zur Verdeutlichung unser schon existierendes <span style="color: darkred;">**Git**</span>-Repository Praktikum. In diesem liegt die Datei *Datenauswertung.R*. 

![](/post/branches_OrdnerPraktikum.png)

Verändern wir jetzt etwas kleines an der Datei. Fügt in einer Zeile ein Ausrufezeichen hinzu oder einen Punkt. Wichtig ist, dass die Datei in einen neuen *Commit* gepackt werden muss. 
Öffnen wir nun das Terminal und mit *cd* unser <span style="color: darkred;">**Git**</span>-Repository. 

![](/post/branches_OpenTerminal.png)
Jetzt wollen wir die Datei für einen `Commit` vorbereiten. Dafür muss man sie, wie ihr wisst, erstmal ins *Staging Environment* laden. 

![](/post/branches_Stage.png)
Anschließend führen wir einen `Commit`durch. 

![](/post/branches_Commit.png)
Wie unterscheidet <span style="color: darkred;">**Git**</span> jetzt aber den neuen `Commit`vom Alten? 

Dafür erstellt <span style="color: darkred;">**Git**</span> bei jedem `Commit`, den ihr durchführt, sogenannte Checksums. Zu jeder Checksum gehört dann logischerweise auch eine andere Version der Datei. <span style="color: darkred;">**Git**</span> erstellt somit quasi einen Schnappschuss eurer Datei, dessen Name die jeweilige Checksum ist. 
Schauen wir uns mal an, wie so eine Checksum aussieht. 
Dafür gebt ihr im Terminal den Befehl `git log` ein. Dieser Befehl zeigt euch eure `Commit`-Historie an und auch die jeweiligen Checksums, die <span style="color: darkred;">**Git**</span> erstellt hat. Diese sehen folgendermaßen aus: 

![](/post/branches_CheckusmTerminal.png)
Vergleicht mal verschiedene Checksums unterschiedlicher `Commits`. Ihr werdet nie zwei identische finden. 

Auf <span style="color: darkred;">**SmartGit**</span> sind die Checksums etwas schwerer zu finden und sehen auch ein bisschen anders aus. Geht dafür auf den *Log*-Button oben in der Leiste.  

![](/post/branches_SmartGitLog.png)
Es öffnet sich noch ein Fenster, dass jeden eurer `Commits` in diesem Repository anzeigt. 
Die Checksum zu unserem neuen `Commit` finden wir rechts in dem `Commit` Fenster. 

![](/post/branches_SmartGitCommit.png)
Wie ihr hier sehen könnt, benutzt <span style="color: darkred;">**SmartGit**</span> eine andere "Sprache" für Checksums. Trotzdem sind der `Commit` "00c0a4d9" und der `Commit` "00c0a4d9cbee2c8578b1d00adcb810c21b0ae151" dergleiche. Auch interessant ist, dass <span style="color: darkred;">**SmartGit**</span> euch auch anzeigt von welchem `Commit` der neue abstammt. Welcher `Commit` also das "Elternteil" des Neuen ist. So könnt ihr, vor allem in der Hinsicht auf verschiedene *Branches*, sehr gut den Überblick über eure `Commit`-Historie behalten. 
Zurück zu unserem Ordner "Praktikum". Dieser enthält unser Objekt *Datenauswertung.R*. Dazu zugehörig wird ein sogenannter "Blob" erstellt. Ein "Blob" ist ein Objekttyp, der benutzt wird, um den Dateininhalt in einem Repository unterzubringen. Jetzt brauchen wir allerdings noch ein Objekt, das diesen Dateiinhalten auch Namen wie hier *Datenauswertung.R* zuordnen kann. Dafür ist das "Tree-Objekt" zuständig. Zu guter Letzt befindet sich in diesem Ordner auch noch ein neues `Commit`-Objekt, das wir durch die Durchführung des `Commits` von *Datenauswertung.R* erstellt haben. In diesem befindet sich ein Schnappschuss der Datei zu dem Zeitpunkt an dem der `Commit` erstellt wurde. 

Hier könnt ihr euch diese grobe Erklärung der Datenstruktur von <span style="color: darkred;">**Git**</span> nochmal verbildichen: 

![](/post/branches_GitDatenStruktur.png)

### Der Master-Branch

Der *master*-Zweig ist der default-**Branch** in <span style="color: darkred;">**Git**</span>. Dieser wird mit dem Befehl *git init* automatisch erstellt und die meisten Personen ändern dies nicht. Der *master*-**Branch** ist also nicht speziell, sondern einfach nur die Voreinstellung. 

![](/post/branches_master.png)
Der *master*-**Branch** verfolgt unsere `Commits` und befindet sich automatisch immer auf unserem aktuellen `Commit`. Damit wir wissen, wo sich der **Branch** gerade befindet, hat <span style="color: darkred;">**Git**</span> einen Zeiger oder Pfeil eingebaut.  

![](/post/branches_masterPfeil.png)
Unser aktueller `Commit` ist der mit dem Namen "Neuer Commit". Der grüne Zeiger des *master*-**Branches** zeigt darauf. 

<!-- Woran kann man diesen Zeiger sehen? Und was heißt das eigentlich, darauf zeigen? Bin hier noch nicht so super zufrieden mit der Erklärung.-->

### Einen neuen **Branch** erstellen

Wir wollen jetzt einen neuen **Branch** in unserem Ordner "Praktikum" erstellen, um zu testen, ob ein neuer Analyseweg besser ist als der Alte. Die erste Möglichkeit ist über das Terminal. Navigiert zu dem Ordner in dem der neue **Branch** sein soll mit cd und gebt anschließend das Command `git branch Analyse1` ein. 

<!-- Kannst du das komplette Beispiel in den Ordner "Praktikum" übertragen und dabei die Ordnerstruktur aus der ersten Session auf deinem Arbeitslaptop einfach nachabauen? dann würde es stringenter aussehen -- Bei neuer Branch erstellen schon geschehen, bei Branch wechseln muss es ncoh gemacht werden-->

![](/post/branches_New2.png)
Natürlich kann auch mit <span style="color: darkred;">**SmartGit**</span> ein neuer Branch erstellt werden. Hierzu öffnet ihr <span style="color: darkred;">**SmartGit**</span>, klickt oben in der Leiste auf **Branch** und dann auf *Add Branch*. Jetzt gebt ihr einen Namen ein (z.B. "Analyse2") und bestätigt das. 

![](/post/branches_LocalBranches2.png)

Auf <span style="color: darkred;">**SmartGit**</span> müssten euch nun unter **Local Branches** drei Optionen angezeigt werden: *master*, *Analyse1* und *Analyse2*. 

Woher wissen wir auf welchem **Branch** wir uns gerade befinden?  In <span style="color: darkred;">**SmartGit**</span> ist das wie immer ziemlich einfach. Da wird der aktuelle **Branch** einfach dick gedruckt. 

Aber auch im Terminal gibt es die Möglichkeit herauszufinden, was unser aktueller **Branch** ist.
<span style="color: darkred;">**Git**</span> hat dazu einen speziellen Zeiger namens *HEAD*. Dieser zeigt immer auf den lokalen **Branch** auf dem man sich gerade befindet.Mit dem Befehl `git log --oneline --decorate` kann man im Terminal sehen, wo der *HEAD*-Zeiger gerade hinzeigt. 

![](/post/branches_HEAD2.png)
Hier immer noch auf *master*. 

Auf <span style="color: darkred;">**GitHub**</span> seht ihr direkt auf der Startseite eures Projekts auf welchem **Branch** ihr euch befindet. b

![](/post/branches_GitHub2.png)

### **Branches** wechseln

Wir wollen jetzt zu dem **Branch** *Analyse1* wechseln. In der Sprache von Git wird diese Betrachtung eines Branches als `checkout` bezeichnet. Über das Terminal ist der Befehl daher `git checkout Analyse1`. Der *HEAD*-Zeiger bewegt sich damit zu unserem ausgewählten **Branch**. Ob es geklappt hat, können wir mit dem bereits eben verwendeten Befehl `git log --oneline --decorate` testen. 

![](/post/branches_SwitchBranch2.png)
Bei <span style="color: darkred;">**SmartGit**</span> muss man einfach nur mit Doppelklick auf den **Branch** aus der links unten angezeigten Liste gehen, in den man wechseln will. Dann sollte folgendes erscheinen, dass ihr dann bestätigt.

![](/post/branches_SmartGitSwitch2.png)

<!-- Was vielleicht auch interessant ist: die Dateien, die im Explorer angezeigt werdne, ändern sich äquivalent, dies kann man hier schonmal erwähnen und später vielleicht nochmal ausprobieren ? Welcher Explorer? -->

Machen wir uns das Ganze mal an unserer Datei "Datenauswertung" deutlich. Sagen wir mal, dass wir mit den Daten einen `t.test()` durchführen wollen, uns aber noch nicht ganz sicher sind, ob das überhaupt etwas bringt. Dazu ändern wir erstmal die Datei. 

![](/post/branches_ÄnderungDatei.png)

Jetzt öffnen wir <span style="color: darkred;">**SmartGit**</span> und stellen sicher, dass wir immer noch auf unserem **Branch** *Analyse1*. Wir führen nun einen `Commit` auf diesem **Branch** durch, der die oben aufgeführten Änderungen enthält. Unser *HEAD*-Zeiger zeigt nun auf *Analyse1*. Wechselt nun mal zwischen den zwei **Branches** hin und her und schaut euch den obersten `Commit` an. Hier sehen wir den Unterschied. Der `t.test()`-`Commit` ist nur auf dem **Branch** *Analyse1* vorhanden (Bild 1). Auf dem **Branch** *master* ist nur unser inzwischen alter "Neuer Commit" (Bild 2). 

Bild 1: 
![](/post/branches_UnterschiedBranches.png)
Bild 2: 
![](/post/branches_UnterschiedBranches2.png)

Falls ihr jetzt also auf *master* wechselt und hier irgendwelche Veränderungen macht, tut ihr das mit euerer alten Dateiversion (ohne die Veränderungen, die auf dem *New*-**Branch** gemacht wurden). So weit wollen wir allerdings jetzt noch nicht gehen. Wie ihr aus dem Abschnitt `Conflict Solver` in <span style="color: darkred;">**SmartGit**</span> wisst, entsteht ein Konflikt immer dann, wenn in derselben Zeile unterschiedliche Dinge stehen. Aktuell stehen unsere zwei **Branches** demnach nicht in einem Konflikt, da wir hier in *New* nur eine Zeile hinzugefügt haben und in der Zeile unseres *master*-**Branches** nichts steht. 

Da wir zu Übungszwecken einen Merge mit Konflikt ausführen wollen, werden wir jetzt sich widersprechende **Branches** erstellen. Dafür gehen wir wieder in unsere Datei und ändern dieselbe Zeile wie vorhin. 

![](/post/branches_ÄnderungDatei2.png)

Wir stellen sicher, dass wir uns auf dem *master*-**Branch** befinden und führen einen `Commit`durch. Unser Projekt hat jetzt eine *Divergent History*, was soviel bedeutet wie auseinandergehende Geschichte. 
Die Datei auf dem einen **Branch** hat einen `t.test()`, die andere einen Vektor namens *z*.  

<!-- Vielleicht erstmal ein Beispiel ausdenken, wie sich die Branches nicht widersprechen und dann einen widersprechenden machen / dabei auch jeweils einen Merge durchführen!
!!!!!!!!!!!!!Ist eigentlich auch schon drinnen, Zeile 92 abwärts, soll das noch detaillierter werden? 
Du hast die Situation beschrieben, ja. Aber ich hätte den Merge auch durchgeführt, um das Prinzip erstmal ohne Konflikt klar zu machen. Habe grade bei dem Merge gesehen, dass Git das auch als Konflikt sieht, wenn in der einen Zeile was steht und in der anderen nichts-->

Jetzt haben wir ein Original auf dem *master* und eine Entwicklungsdatei auf dem *Analyse1*-**Branch**. 
Man kann mit der Entwicklungsdatei herumexperimentieren, ohne an dem Original etwas ändern zu müssen. 
 
### Zwei **Branches** Mergen

Natürlich kann man zwei **Branches** auch wieder zu einem zusammenführen. Das Prinzip ist dasselbe wie wenn man zwei Autoren hat, die unterschiedliche Versionen einer Datei erstellt haben und dann den `Conflict Solver` benutzen müssen. Das steht im Abschnitt über <span style="color: darkred;">**SmartGit**</span>. 

Wenn ihr dem Tutorial bis hierher gefolgt seid, dann müsstet ihr zwei verschiedene Versionen eines Projekts auf verschiedenen **Branches** liegen haben. 

Wir wollen nun den **Branch** *New* und *master* zusammenfügen. Dafür gehen wir bei <span style="color: darkred;">**SmartGit**</span> auf den Button *Merge* rechts oben in der Ecke. 

Dann öffnet sich ein Fenster bei dem wir auf *Merge to Working Tree* gehen.

<span style="color: darkred;">**SmartGit**</span> sollte nun so aussehen: 

![](/post/branches_MergeState.png)

Wenn wir jetzt auf die entsprechende Datei gehen, von der es auf den zwei **Branches** unterschiedliche Versionen gibt, sollte man den *Conflict Solver* angezeigt bekommen. Wie dieser funktioniert, steht im Abschnitt über <span style="color: darkred;">**SmartGit**</span> genauer. Trotzdem kommt hier nochmal eine kurze Zusammenfassung. 

Die Datei, die im Konflikt ist, sieht so aus: 

![](/post/branches_conflictedData.png)
Wenn ihr auf diese Datei klickt, erscheint automatisch ein Button für den `Conflict Solver`. 

![](/post/branches_ConflictSolver.png)

Auf diesen klicken wir und es geht ein neues Fenster mit dem `Conflict Solver` auf. 
Jetzt müssen wir entscheiden, welche Version wir nehmen. Hier ist das noch sehr simpel, da wir nur eine Zeile haben, die sich unterscheidet. 
Wir haben entschieden, dass wir die Analyse unserer Entwicklungsdatei in unser Original einbauen wollen. 

![](/post/branches_ConflictTakettest.png)
Sobald wir den `t.test()` in die Mitte "gezogen" haben, speichern wir das und schließen den `Conflict Solver`. Es öffnet sich erneut ein Fenster. 

![](/post/branches_StageforCommit.png)
Hier klicken wir auf *Stage*, da die Datei somit direkt ins *Staging Environment* geladen wird und wir im Anschluss darauf einen `Commit` durchführen können. 

Es öffnet sich dieses Fenster durch das wir unseren `Commit` finalisieren können und eine *Commit-Message* hinzufügen können. 

Jetzt habt ihr zwei **Branches** erfolgreich gemerged.

Auf <span style="color: darkred;">**SmartGit**</span> seht ihr den erfolgreichen Merge im *Log*. 

![](/post/branches_Log.png)

# Fazit und Ausblick

Wie ihr seht, sind **Branches** in <span style="color: darkred;">**Git**</span> ein sehr nützliches Tool. Das es euch ermöglicht ein bisschen herumzuexperimentieren, indem ihr wie im Beispiel oben ein Original und eine Entwicklungsdatei habt. Natürlich ist das **Branches**-Tool noch viel umfangreicher als hier beschrieben. Ihr könnt auch die Entwicklungsdatei nochmal spalten und dann entscheiden, welche ihr mergen wollt. Hier aber aufpassen, dass ihr den Überblick behaltet. 

***


## Appendix A

<details><summary> **Tieferes Verständnis von Speicherprozessen** </summary> 

Eine Checksum oder auch Prüfsumme wird jedes Mal erstellt, wenn man eine Datei in das *Staging Environment* lädt. Diese kann zum Beispiel so aussehen: "7a3k9". Mit der Checksum soll die Integrität von Daten geprüft werden. 
Das beinhaltet die Kontrolle der Korrektheit, Vollständigkeit und Konsistenz unserer Datei. 
Der Computer kann so sicherstellen, ob die Datei einen Fehler hat oder nicht. 

Nützlich ist das zum Beispiel, wenn ihr eine Datei aus dem Internet ladet und sichergehen wollt, dass kein Fehler beim Herunterladen passiert ist. Ihr müsst einfach nur die Checksum der Datei aus dem Internet und euerer Datei auf dem Computer vergleichen. Sollten die Checksums identisch sein, ist kein Fehler aufgetreten. 

Zurück zu <span style="color: darkred;">**Git**</span>. Ihr habt gerade eure Datei in das *Staging Environment* geladen und dabei für diese Datei eine Checksum erstellt. Anschließend wird diese Version der Datei in einem <span style="color: darkred;">**Git**</span>-Repository untergebracht und die Checksum zum *Staging Environment* hinzugefügt. 
Wenn ihr jetzt den `Commit` durchführt, nimmt <span style="color: darkred;">**Git**</span> die Checksum jedes Subordners und speichert diese in einem Tree-Objekt in eurem <span style="color: darkred;">**Git**</span>-Repository. Darauf folgend wird ein `Commit`-Objekt erstellt, das diese Metadaten enthält. So kann ein Schnappschuss der Daten erstellt werden, wann immer es gebraucht wird. 

Noch ein kleiner Ausflug zum Thema Metadaten. 
Wenn ihr ein Foto von etwas macht, speichert eure Kamera oder euer Smartphone nicht nur das Foto, sondern auch die zugehörigen Metadaten. 
Dazu kann gehören: 

Wann ist das Foto entstanden?
Wo ist das Foto entstanden? 
Was für eine Kamera wurde benutzt?  
...

Metadaten sind also im Prinzip Daten, die Informationen über bestimmte Merkmale anderer Daten enthalten. 

