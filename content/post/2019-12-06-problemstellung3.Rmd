---
title: Problemstellung
author: Christina Berger
date: '2019-12-06'
slug: problemstellung3
categories:
  - Projekt 3
tags: []
subtitle: ''
summary: ''
authors: [berger]
lastmod: '2019-12-06T19:13:23+01:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

## Datensammlung

Als Datengrundlage musst du dir, wie in der [Vorbereitung](/post/uebersicht3/) gezeigt, einen deiner WhatsApp Chats exportieren und in R einlesen.

## Datenaufbereitung

Schau dir die Datei am besten zunächst einmal an, und überlege was du nun alles verändern musst, um damit arbeiten zu können.

Das erste was dir vielleicht auffällt, ist dass sowohl Uhrzeit, als auch Name und Nachricht zusammen in einer Spalte stehen und nicht von einander getrennt sind. Daher wollen wir als erstes den Datensatz in drei Spalten zerlegen (Zeit, Absender der Nachricht & Inhalt der Nachricht).
Für die Uhrzeit funktioniert dies ziemlich einfach, weil sie in jeder Zeile gleich lang ist. Daher können wir mit dem Befehl `substr` arbeiten. Für die Umwandlung in eine Datumsvariable haben wir dir in [Aufagbe 1](/post/uebersicht1) schon eine Möglichkeit gezeigt.

Als nächstes kommt der Absender. Diesen zu extrahieren ist etwas schwieriger, weil alle Namen unterschiedlich lang sind. Deshalb haben wir eine Datei erstellt, in der alle Absender stehen [(Vorbereitung)](/post/uebersicht3).
Mit einer `for`-Schleife, wie wir sie in [Aufgabe 2](/post/uebersicht2) benutzt haben, kannst du nun jede Nachricht durchgehen und den Empfänger herausfiltern. Es gibt verschiede Möglichkeiten nach einem bestimmten Muster einen Datensatz zu duchsuchen. 
In den [R-Wikibooks](https://de.wikibooks.org/wiki/GNU_R:_Umgang_mit_Datens%C3%A4tzen_(Erstellen,_Ausw%C3%A4hlen_und_Filtern))  findest du ein paar davon (unter 'Auswahl von Fällen mittels "Wildcard"').

So können wir nun eine zusätzliche Variable erstellen, die alle Informationen zu den Nachrichten enthält, in dem wir sowohl die Person, als auch die Zeit ihr zuweisen.

Als letztes brauchst du noch den Text. Diesen extrahieren wir, wie den Absender mit einer `for`-Schleife. Mit dem Befehl `gsub` durchsuchst du die ganze Datei nach den Nachrichten, um diese in einer anderen Variable abzuspeichern. 

Aus den drei Variablen (Wann, Wer und Was) kannst du einen Dataframe erstellen, den du wie gewohnt anschauen kannst. Dabei wirst du sehen, dass es in manchen Zeilen keinen Absender und keine Zeitangabe gibt. Das passiert, wenn jemand einen Absatz in seiner Nachricht gemacht hat. 
Um dies zu beheben müssen wir erst alle Zeilen identifizieren, die dieses Problem aufweisen.Nun musst du die Uhrzeit und den Absender aus der vorherigen Nachricht kopieren und in den ersten beiden Spalten der folgenden Nachricht einfügen.

Es gibt noch zwei weitere Sonderfälle in unserem Datensatz. Das sind die ausgeschlossenen Medien, oder wenn jemand dem Chat beigetreten bzw. ihn verlassen hat. Für Zweiteres kannst du `na.omit` nutzen. Schau dir den Befehl am besten in der Hilfefunktion an.
Die ausgeschlossenen Medien entsprechen immer der gleichen Benachrichtigung, daher kannst du alle diese Zeilen auswählen und löschen.
Wenn du dir nun deinen Datensatz anschaust, sollte er keine leeren Zeilen oder Spalten mehr aufweisen. Damit hast du den größten Schritt schon geschafft und wir können anfangen. 
 
## Darstellung 



## Zeitanalyse

Im ersten Schritt unsere Analyse schauen wir, wer am schnellsten antwortet. Dafür vergleichen wir den Durchschnitt der Antwortzeiten aller Personen.
Für die Antwortzeiten wird von jeder Uhrzeit, die Uhrzeit der darauffolgenden Nachricht abgezogen. 
Wenn du dir die Antwortzeiten anguckst, fällt dir etwas auf? 

Wie du vielleicht von der Datenaufbereitung noch im Hinterkopf hast, werden aus Nachrichten mit einem Zeilenumbruch zwei Nachrichten in unserem Datensatz. Daher müssen wir alle Nachrichten ausschließen, bei denen Sender und Antworter gleich sind.
Wenn du den Durchschnitt ausrechnest, überlege zunächst welches Maß das sinnvollste ist.

Für unsere Freundetest erstellen wir nun eine neue Tabelle, in der wir Punkte vergeben. In dieser Tabelle müssen die Namen aller Teilnehmer und das Ergebnis der Zeitanalyse stehen. Für die Punktevergaben gibt es einen einfachen Befehl. Versuche ihn über die Hilfefunktion zu finden oder schaue sonst unter [Tipps](/post/tipps3)

## Stimmungsanalyse


Für die Stimmungsanalyse benötigen wir zwei Pakete: `Udpipe` und `ggplot2`, wie in der [Vorbereitung](/post/uebersicht3) schon beschrieben. 
Im Anschluss musst du die passenden Tabellen für unsere Analyse in R einlesen („EmotionLookupTable“, „BoosterWordList“ und „NegatingWordList“). 
Tipp: schau dir vorher die Datei an, welche Trennzeichen vorhanden sind und ob es eine Überschrift der Spalten gibt.


Bei der ersten Datei („EmotionLookupTable“) handelt es sich um eine Liste von Wörtern, welche einen Score haben der aussagt, wie stark positiv oder negativ die Bedeutung des Wortes ist. Zum Beispiel hat das Wort „grausam“ einen Score von -4, weil es sehr stark negativ geprägt ist. Im Gegensatz dazu hat das Wort „Niederlage“ einen Score von -1, weil es zwar negativ geprägt ist, aber nicht in dem gleichen Ausmaß wie „grausam“. 

In der zweiten Liste („BoosterWordList“) befinden sich sogenannte Verstärker. Auch hier wird jedem Wort ein Score zugewiesen zwischen -1 und 2. Dabei bedeutet -1, dass es sich um einen Abschwächer handelt und bei 1, um einen Verstärker. Es gibt auch Worte mit 0, die als neutral gelten.

Die dritte Datei („NegatingWordList“) ist eine Liste mit Wörtern, die die Bedeutung umkehren können. Wenn zum Beispiel später in der Chatanalyse der Satz „ich habe heute gar keine Lust!“ vorkommt, erkennt der Computer das Wort „Lust“ als ein sehr positiv geprägtes Wort. Daher benötigen wir diese Liste, um Verneinungen zu erkennen.


Um diese Dateien zu benutzten, müssen wir zunächst die "EmotionLookupTable" in einen Dataframe bringen. Die "BoosterWordList" müssen wir aufteilen in Verstärker und Abschwächer.
Die Analyse können wir sowohl nur für eine bestimmte Person machen, als auch für alle gleichzeitig. Wir werden es erst mit einer Person versuchen, um es im Anschluss auf alle zu erweitern.
Such dir einfach eine Person aus deinem Chat aus und speiche alle Nachrichten von ihr als `Character` in einer neuen Variable.

Nun kommt unser `Udpipe` Paket in Einsatz. Schau dir den Befehl `udpipe()` an. Er zerlegt den Quellcode in sogenannte Tokens. Tokens sind logische Einheiten an Wörtern. So bleiben manche Wörter in einer Einheit, wenn sie zusammengehören. Bezogen auf unser Beispiel von eben würde der Satz „ Ich habe heute gar keine Lust!“ in: 

Ich    |	Habe  	    |	Heute 	    |	Gar keine     |	Lust

zerlegt werden.
Diese Tokens können nun analysiert werden mit dem Befehl `txt_sentiment`. Schau dir den Befehl am besten als erstes einmal an. Du hast alles eingelesen, was du für den Befehl brauchst.
Um dir das Ergebnis anzuschauen muss du es einer neuen Variable zuweisen und kannst wenn du die Spalte `overall` aufrufst dein Ergebnis in der Console sehen.

Um diese Analyse mit dem ganzen Chat zu machen benötigt du erst einen Dataframe, in dem der Chat als `Charakter` gespeichert ist. Im Anschluss musst du die Nachrichten wieder verketten. Dies ist mit allen Mitgliedern ein bisschen komplizierter, aber im Grundsatz das Gleiche, wie bei der einzelnen Person.

Danach kannst du wie eben vorgehen. Wenn du dir am Ende dein Ergebnis anschaust, stehen dort keine Namen mehr. Du kannst der neuen Tabelle aber einfach die gleichen Namen wie in der Chatdatei zuweisen.

Für unseren Test ist  wichtig, dass jede Person einen Wert bekommen hat. Je höher dieser Wert, desto mehr positive Stimmungen wurden von ihr verbreitet. Wenn du diesen Wert in unser Punktetabelle speicherst, kannst du wie bei der Zeitanalyse Rangpunkte vergeben. 

Zum Schluss solltest du einen Endscore errechenen und so ein Ergebnis haben, wer deine beste Freundin ist. Und überrascht?

