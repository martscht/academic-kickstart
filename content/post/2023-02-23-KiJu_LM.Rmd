---
title: Einführung in lineare Modelle in R
date: '2023-02-23'
slug: kiju-lm
categories: ["KiJu"]
tags: ["Regression"]
subtitle: ''
summary: ''
authors: [nehler]
lastmod: '2023-02-28T16:20:00+01:00'
featured: no
header:
  image: "/header/KiJu_LMMsQuer.jpg"
  caption: "[Courtesy of pexels](https://www.pexels.com/photo/bunches-of-grapes-hanging-from-vines-3840335/)"
projects: []
---

```{r, echo=FALSE}
library(knitr)
```


## Vorbereitung

- Pakete aktivieren und Code durchführen, die im letzten Tutorials schon da waren

```{r, eval = FALSE}
library(haven)
setwd("~/Pfad/zu/Ordner")
data <- read_sav(file = "fb22_mod.sav")
data$geschl_faktor <- factor(data$geschl,                                   # Ausgangsvariable
                             levels = c(1, 2, 3),                           # Faktorstufen
                             labels = c("weiblich", "männlich", "anderes")) # Label für Faktorstufen
data$nr_ges <- rowMeans(data[,c("nr1", "nr2", "nr3", "nr4", "nr5", "nr6")])
data$prok <- rowMeans(data[,c("prok1", "prok4", "prok6", "prok9", "prok10")])

data$wohnen_faktor <- factor(data$wohnen,                                   
                             levels = c(1, 2, 3, 4),                                
                             labels = c("WG", "bei Eltern", "alleine", "sonstiges")) 
```

```{r, echo = FALSE}
library(haven)
data <- read_sav(file = url("https://pandar.netlify.app/post/fb22_mod.sav"))
data$geschl_faktor <- factor(data$geschl,                                   # Ausgangsvariable
                             levels = c(1, 2, 3),                           # Faktorstufen
                             labels = c("weiblich", "männlich", "anderes")) # Label für Faktorstufen
data$nr_ges <- rowMeans(data[,c("nr1", "nr2", "nr3", "nr4", "nr5", "nr6")])
data$prok <- rowMeans(data[,c("prok1", "prok4", "prok6", "prok9", "prok10")])

data$wohnen_faktor <- factor(data$wohnen,                                   
                             levels = c(1, 2, 3, 4),                                
                             labels = c("WG", "bei Eltern", "alleine", "sonstiges")) 
```

## lineare Modellierung

- Grundlage für spätere hierarchische Ansetzung ist lineares Modell ohne Hierarchie

### Syntax

- spezielle Syntax für die Darstellungen von Abhängigkeiten
- Demonstration an der aggregate Funktion
- Operation wird an einer Variable in Abhängigkeit einer anderen durchgeführt

```{r}
aggregate(extra ~ geschl_faktor, data = data, FUN = mean)
```

### Einfaches lineares Modell

- eben gelernte Syntaxlogik übertragen

```{r}
lm(extra ~ lz, data = data)
```

- hat erstmal nur sehr beschränkte Ausgabe
- man kann meist mehr aus Funktionen herausholen, indem man ihren Output in ein Objekt ablegt

```{r}
mod <- lm(extra ~ lz, data = data)
```

- erscheint oben im Environment
- was für ein Typ Objekt ist das nun?
- steht da, dass es eine List ist; etwas anderes als ein Datensatz; hier gibt es feste Anzahl an Spalten pro Reihe und umgekehrt
- bei Listen können in verschiedenen Bestandteilen der Liste ganz unterschiedliche Sachen liegen
- bspw. auch Datensätze; häufig ist die Auswahl von Listenbestandteilen aber auch durch das `$`

```{r}
mod$coefficients
mod$call
```

- wie Variablen auch (`numeric` etc.), können Listen verschiedene Klassen haben
- bspw. haben wir hier die class lm, erstellt aus der Funktion
- Datensätze hingegen haben meist die class data.frame

```{r}
class(data)
class(mod)
```

- neben der händischen Exploration können wir auch automatische Funktionen nutzen
- bspw. die summary Funktion; wird am häufigsten genutzt

```{r}
summary(mod)
```

- zeigt uns wichtigste Parameter an
- Funktion ist auch auf Objetkte anderer Klassen anwendbar; hier auf Datensatz; zeigt Zusammenfassungen der Variablen
- werden sie auch in den nächsten Blöcken weiter verwenden

```{r}
summary(data)
```
- weiteres Beispiel für eine solche Funktion ist `plot()`
- einfache lineare Modellierung kann [hier](https://pandar.netlify.app/post/regression/) vertieft werden

## Multiple Regression

- Erweiterung des Modells mit Aufnahme von Effekten
- zur multiplen Regression gibt es viele Themen in der [Übersicht von PsyBSc7](https://pandar.netlify.app/lehre/#bsc7)

### Kontinuierliche Prädiktoren

- einfache Erweiterung der Syntax um eine Addition

```{r}
mod_kont <- lm(lz ~ neuro + intel, data = data)
```

- class bleibt gleich und auch summary daher gleich aufgebaut
- coefficient erweitert sich logischerweise um einen Eintrag

```{r}
class(mod_kont)
summary(mod_kont)
```


### Aufnahme kategorialer Prädiktor

- nehmen wir zunächst mal geschl auf, wie es ursprünglich vorlag
- Syntax bleibt genau gleich

```{r}
mod_kat <- lm(lz ~ intel + geschl, data = data)
summary(mod_kat)
```

- geschl bekommt eigenes Steigungsgewicht; aber nur eins, was überraschend ist, da es drei Ausprägungen gibt
- daher ist Verwandlung in einen Faktor essentiell
  
```{r}
mod_kat <- lm(lz ~ intel + geschl_faktor, data = data)
summary(mod_kat)
```

- Summary zeigt direkt an, in welche Kategorie der Unterschied besteht
- fehlende Kategorie wird als Referenz genutzt
- Standardmäßig also eine dummykodierung

### Moderierte Regression

- Interaktionseffekt zwischen zwei Variablen soll aufgenommen werden
- vorher zentrieren, damit Multikollinearität vorgebeugt wird

```{r}
data$neuro_center <- scale(data$neuro, scale = F, center = T)
data$intel_center <- scale(data$intel, scale = F, center = T)
```

- Funktionalität überprüfen; nicht immer genau null, aber maschinell gesehen schon

```{r}
mean(data$neuro_center)
mean(data$intel_center)
```

- lineare Modellierung mit Moderationseffekt
- da Moderation eine Multiplikation der Effekte ist, würde man intuitiv den Code folgendermaßen schreiben

```{r}
mod_inter_nocenter <- lm(lz ~ neuro + intel + neuro * intel, data = data)
mod_inter_center <- lm(lz ~ neuro_center + intel_center + neuro_center * intel_center, data = data)
summary(mod_inter_nocenter)
summary(mod_inter_center)
```
- sehen, dass die Zentralisierung wie erwartet die Standardfehler reduziert
- nochmal zurück zu dem Code: die intuitive Lösung mit der Multiplikation benötigt theoretisch nicht mal die einzelne Aufführung der Variablen, die Teil der Interaktion sind:

```{r}
mod_inter_center <- lm(lz ~ neuro_center * intel_center, data = data)
summary(mod_inter_center)
```
- allerdings hat das natürlich den Nachteil, wenn man bei manchen Variablen Interaktion haben will und bei anderen nicht (besonders dann bei mehr als zwei Prädiktoren)
- daher besteht die Möglichkeit, Interaktionen sehr präzise auszuwählen mit dem `:`

```{r}
mod_inter_center <- lm(lz ~ neuro_center + intel_center + neuro_center:intel_center, data = data)
summary(mod_inter_center)
```

- grafische Darstellung: Paket unterstützt diese sehr gut

```{r, eval = FALSE}
install.packages("interactions")
library(interactions)
```

```{r}
library(interactions)
```

- Festlegung des Moderators kann `R` natürlich nicht für uns übernehmen

```{r}
interact_plot(model = mod_inter_center, pred = intel_center, modx = neuro_center)
```

Weitere Infos zur Moderation, besonders Zusammenspiel mit quadratischen Effekten, finden sich [hier](https://pandar.netlify.app/post/ancova-und-moderierte-regression/)

## Anwendungen

1. Erstelle eine multiple Regression mit Extraversion als abhängiger Variable und Art des Wohnens sowie Verträglichkeit als unabhängigen Variablen.

<details><summary>Lösung</summary>

```{r}
mod_extra <- lm(extra ~ wohnen_faktor + vertr, data = data)
summary(mod_extra)
```

</details>

2. Finde mit Hilfe des Internets heraus, wie standardisierte Regressionsparameter mit Hilfe einer Funktion ausgegeben werden können.

<details><summary>Lösung</summary>

```{r}
library(lm.beta)
lm.beta(mod_extra)
```

</details>

3. Nun sollen statt Art des Wohnens die Skalenscores für Prokrastination und Naturverbundenheit genutzt werden. Außerdem soll die Dreifachinteraktion der Prädiktoren aufgenommen werden, aber keine Interaktionen zwischen zwei Prädiktoren.

<details><summary>Lösung</summary>

```{r}
data$nr_ges_center <- scale(data$nr_ges, scale = F, center = T) 
data$prok_center <- scale(data$prok, scale = F, center = T)
data$vertr_center <- scale(data$vertr, scale = F, center = T)
```


```{r}
mod_falsch <- lm(extra ~ nr_ges_center * prok_center * vertr_center, data = data)
summary(mod_falsch)
```

```{r}
mod_korrekt <- lm(extra ~ nr_ges_center + prok_center + vertr_center + nr_ges_center:prok_center:vertr_center, data = data)
summary(mod_korrekt)
```
</details>

