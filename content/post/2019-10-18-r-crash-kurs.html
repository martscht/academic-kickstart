---
title: R Crash-Kurs
date: '2019-10-18'
slug: r-crash-kurs
categories: ["Zusatz", "BSc2"]
tags: ["R Intro"]
subtitle: ''
summary: ''
authors: [schultze]
lastmod: '2020-10-01T11:35:06+02:00'
featured: no
header:
  image: "/header/crash_post.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/1217289)"
projects: []
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<details>
<summary>
Kernfragen dieses Beitrags
</summary>
<ul>
<li>Was ist <strong>R</strong> und was ist <strong>RStudio</strong>?</li>
<li>Was ist die <strong>Konsole</strong> und was ist die <strong>Syntax</strong>?</li>
<li>Wie kann ich <strong>Syntax ausführen</strong>?</li>
<li>Wie sehen <strong>Ergebnisse</strong> von Befehlen in R aus?</li>
<li>Wie kann ich R als <strong>Taschenrechner</strong> und für <strong>logische Vergleiche</strong> benutzen?</li>
<li>Was sind <strong>Funktionen</strong> und wie sind sie aufgebaut?</li>
<li>Wie bekomme ich in R <strong>Hilfe</strong>?</li>
<li>Was sind <strong>Objekte</strong>?</li>
<li>Was ist das <strong>Environment</strong>?</li>
<li>Was sind <strong>Vektoren</strong> und welche unterschiedlichen Arten gibt es?</li>
<li>Welche <strong>mehrdimensionalen Datenstrukturen</strong> gibt es und worin unterscheiden sie sich?</li>
<li>Wie kann ich aus Datensätze einzelne Variablen oder Beobachtungen <strong>extrahieren</strong> und sie <strong>hinzufügen</strong>?</li>
<li>Wie <strong>importiere</strong> und <strong>exportiere</strong> ich Daten?</li>
</ul>
</details>
<hr />
<div id="warum-r-nutzen" class="section level2">
<h2>Warum R nutzen?</h2>
<p>Ziel dieses gesamten R-Praktikums ist es, dass Sie am Ende des Semester geübt im Umgang mit R sind, die Grundfunktionalität beherrschen und die Analyseverfahren durchführen können, die in der Vorlesung behandelt werden. Damit wir - oder genauer genommen, eigentlich Sie - dieses Ziel erreichen, legen wir hier mit einer “kurzen” Einführung in die Grundprinzipien von und den Umgang mit R los. Viele Dinge, die hier besprochen werden, sind auch in den <a href="categories/bsc2">anderen Sitzungen zu dieser Veranstaltung</a> relevant und werden dort immer wieder vor kommen. Deswegen ist es das Beste, einfach nebenbei RStudio auf zu haben und die hier beschriebenen Schritte auch direkt selbst mit zu machen.</p>
<p>Zuerst aber ein bisschen ausholen: R haben wir für die Lehre aus einer Reihe von Programmen ausgewählt, weil es ein paar hervorragende Eigenschaften hat:</p>
<ul>
<li>R ist “free &amp; free”
<ul>
<li>“Free (as in beer)”: gratis verfügbar, für jeden zugänglich</li>
<li>“Free (as in speech)”: durch die Öffentlichkeit, nicht durch einzelne Instanz reguliert</li>
</ul></li>
<li>Extrem weit verbreitet</li>
<li>Laut Google Scholar knapp 250 000 mal zitiert</li>
<li>Allein in den letzten 30 Tagen 444364 mal heruntergeladen</li>
<li>Für Hausarbeiten, Projekte, Abschlussarbeiten gut geeignet</li>
<li>Auswertung und Fließtext in einer Datei (wie dieser) vereinbar</li>
<li>Wiederherstellbarer Arbeitsablauf</li>
<li>Mit jedem teilbar</li>
<li>Auch außerhalb der Universität und Forschung eine gefragte Fähigkeit</li>
</ul>
<p>Ein paar nützliche Links für R sind die <a href="https://www.r-project.org/">R Main Page</a>, wo R runtergeladen werden kann und diverse technische Details zu finden sind. Für eine kurze, schnelle Einführung in verschiede R-relevante Themen bietet sich <a href="https://www.statmethods.net/">Quick R</a> und, spezifisch für die Psychologie, das <a href="http://www.personality-project.org/r/">Personality Project</a> an. Eine Einführung in die R-Nutzung, an die auch dieses Skript angelehnt ist, findet sich im repository <a href="https://smobsc.readthedocs.io/en/latest/chapter_ana/Introduction%20to%20Programming%20with%20R.html">Scientific Methods for Open Behavioral, Social and Cognitive Sciences</a>.</p>
<hr />
</div>
<div id="rstudio" class="section level2">
<h2>RStudio</h2>
<p>Weil die traditionelle R Nutzeroberfläche extrem spartanisch ist, werden wir auf dieser Seite mit RStudio arbeiten. RStudio ist eine zusätzliche Nutzeroberfläche, die den Umgang durch diverse convenience features mit R ein wenig erleichtert. Es muss separat installiert werden, ist aber, genau wie R selbst, gratis erhältlich. Um RStudio herunterzuladen besuchen Sie am einfachsten <a href="https://www.rstudio.com/">https://www.rstudio.com/</a>.</p>
<p><img src="/post/2019-10-18-r-crash-kurs_files/rstudio.png" /></p>
<p>RStudio besteht aus vier Panels. Zunächst sind nur drei sichtbar - durch <strong>Strg+Shift+n</strong> (OS X: <strong>Cmd+Shift+n</strong>) oder über den <img src="/post/2019-10-18-r-crash-kurs_files/new_script.png" /> Button öffnen Sie eine neue Skriptdatei und das vierte Panel erscheint. R ist syntaxbasiert - genau genommen ist R eigentlich eine Programmiersprache und kein Auswertungsprogramm - und im neu erschienenen Fenster können Sie diese Syntax schreiben. Das pure schreiben bewirkt zunächst nichts. Damit etwas passiert, muss die Syntax mit <strong>Strg+Return</strong> (OS X: <strong>cmd+Return</strong>) oder mit dem <img src="/post/2019-10-18-r-crash-kurs_files/run.png" /> Button ausgeführt werden. Wenn Sie z.B. <code>3 + 4</code> in die Syntax schreiben und so ausführen, erscheint in der Konsole:</p>
<pre class="r"><code>3 + 4</code></pre>
<pre><code>## [1] 7</code></pre>
<p>Die beiden verbleibenden Panels stellen jeweils als Tabs verschiedene Dinge dar. Oben rechts wird per Voreinstellung das <em>Environment</em> angezeigt. Was genau das bedeutet sehen wir in Kürze. Unten rechts werden fünf Tabs dargestellt, die allesamt im Verlauf des Semesters von Relevanz sein werden:</p>
<ol style="list-style-type: decimal">
<li><em>Files</em>: erlaubt die Navigation in Ordnern um Dateien ausfindig zu machen.</li>
<li><em>Plots</em>: hier werden grafische Abbildungen dargestellt.</li>
<li><em>Packages</em>: gibt eine Übersicht über die installierten Erweiterungen für R.</li>
<li><em>Help</em>: das wahrscheinlich wichtigste Tab - hier wird die Hilfe zu R-Funktionen angezeigt.</li>
</ol>
<hr />
</div>
<div id="erste-schritte" class="section level2">
<h2>Erste Schritte</h2>
<p>Eine wichtige Funktionalität jeder Programmiersprache sind <em>Kommentare</em>, die dazu dienen sollen das Vorgehen in Syntax zu gliedern und leichter verständlich zu machen. In R werden sie durch (beliebig viele) <code>#</code> begonnen und enden bei einem Zeilenumbruch. Mit Kommentaren kann Syntax auch in verschiedene Abschnitte gegliedert werden. Empfehlenswert ist es, solche Abschnittüberschriften mit <code>####</code> zu beginnen und mit <code>----</code> zu beenden. RStudio erkennt solche Kommentare automatisch als Überschriften und stellt über den <img src="/post/2019-10-18-r-crash-kurs_files/outline.png" /> Button eine darauf basierende Gliederung zur Verfügung.</p>
<p>Wir können diese Funktionalität der Kommentare am Beispiel der Nutzung von R als Taschenrechner ausprobieren:</p>
<pre class="r"><code>#### R als Taschenrechner ----

3 + 4   # Addition</code></pre>
<pre><code>## [1] 7</code></pre>
<pre class="r"><code>3 - 4   # Subtraktion</code></pre>
<pre><code>## [1] -1</code></pre>
<pre class="r"><code>3 * 4   # Multiplikation</code></pre>
<pre><code>## [1] 12</code></pre>
<pre class="r"><code>3 / 4   # Division</code></pre>
<pre><code>## [1] 0.75</code></pre>
<pre class="r"><code>3 ^ 4   # Potenz</code></pre>
<pre><code>## [1] 81</code></pre>
<p>In der Gliederung sollte in RStudio jetzt die Überschrift “R als Taschenrechner” auftauchen.</p>
<p>In diesem Beispiel sind zwischen den Zahlen und Operatoren immer Leerzeichen. Leerzeichen spielen für R keine Rolle - sie werden bei der Ausführung ignoriert. Daher können Leerzeichen und Einschübe zu Beginn von Zeilen genutzt werden um der Syntax noch mehr Struktur zu geben. Generell wird empfohlen, R Syntax wie normale Sätze zu schreiben und Leerzeichen zu nutzen um die Lesbarkeit der Syntax zu gewährleisten. Einige weitere Empfehlungen zur Gestaltung von R Syntax finden Sie im <a href="http://adv-r.had.co.nz/Style.html">Online Buch von Hadley Wichkam</a> und im <a href="https://google.github.io/styleguide/Rguide.html">Styleguide, der von Google Programmier*innen genutzt wird</a>.</p>
<p>Neben einfachen Taschenrechner-Funktionen mit <em>numerischen Ergebnissen</em> kann R auch logische Abfragen und Vergleiche durchführen:</p>
<pre class="r"><code>#### Logische Abfragen ----

3 == 4   # Ist gleich?</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>3 != 4   # Ist ungleich?</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>3 &gt; 4    # Ist größer?</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>3 &lt; 4    # Ist kleiner?</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>3 &gt;= 4   # Ist größer/gleich?</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>3 &lt;= 4   # Ist kleiner/gleich?</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Die Ergebnisse dieser Abfragen sind <em>boolesch</em> - also immer entweder wahr (<code>TRUE</code>) oder falsch (<code>FALSE</code>). Wie in vielen anderen Programmiersprachen wird in R das <code>!</code> genutzt um eine Aussage zu negieren. Wir könnten also die “ist ungleich” Relation <code>!=</code> auch als “nicht (ist gleich)” umformulieren:</p>
<pre class="r"><code>!(3 == 4)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Wie in der Mathematik üblich, wird der Inhalt von Klammern als erstes evaluiert und ergibt hier <code>FALSE</code>. Dieses Ergebnis wird dann durch <code>!</code> negiert, sodass das finale Ergebnis <code>TRUE</code> ist.</p>
<hr />
</div>
<div id="funktionen-und-argumente" class="section level2">
<h2>Funktionen und Argumente</h2>
<p>Das Nutzen von R als Taschenrechner ist - streng genommen - ein Sonderfall, der vom “üblichen Weg” abweicht, mit dem Dinge in R umgesetzt werden. Mithilfe der einfachen Addition können wir eine Summe bilden:</p>
<pre class="r"><code>3 + 4 + 1 + 2</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Für R typischer wäre aber die Umsetzung mit</p>
<pre class="r"><code>sum(3, 4, 1, 2)</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Hier wird die Funktion <code>sum</code> genutzt um eine Summe der Argumente (<code>3</code>, <code>4</code>, <code>1</code> und <code>2</code>) zu bilden. An diesem Beispiel lässt sich bereits die generelle Struktur von Funktionen in R erkennen:</p>
<pre><code>funktion(argument1, argument2, argument3, ...)</code></pre>
<p>In R werden Funktionen namentlich aufgerufen und alle Argumente, die diese Funktion entgegennehmen kann, folgen in Klammern. Die <code>sum</code>-Funktion ist dabei sogar ein Sonderfall, weil sie unendlich viele Argumente entgegennehmen kann. Eine eher typische Funktion ist z.B. der Logarithmus:</p>
<pre class="r"><code>log(100)</code></pre>
<pre><code>## [1] 4.60517</code></pre>
<p>Wie zu erkennen ist, wird mit <code>log</code> der natürliche Logarithmus einer Zahl bestimmt. Es ist aber mit der gleichen Funktion auch möglich Logarithmen mit jeder anderen Basis zu bilden:</p>
<pre class="r"><code>log(100, 10)</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Um zu verstehen, wie das in R funktioniert, können wir die grundlegende Struktur von Logarithmen betrachten. Diese bestehen aus drei Komponenten: <span class="math inline">\(\log_{b}(x) = y\)</span>. Dabei bezeichnet <span class="math inline">\(b\)</span> die Basis (Englisch: <em>base</em>) des Logarithmus, <span class="math inline">\(x\)</span> das Argument und <span class="math inline">\(y\)</span> das Ergebnis. Die oben dargestellte Funktion <code>log</code> nimmt also als Erstes <span class="math inline">\(x\)</span> und als Zweites <span class="math inline">\(b\)</span> entgegen.</p>
<p>Weil es bei der beinahe unendliche Mengen von Funktionen in R unmöglich ist, sich die korrekte Reihenfolge aller Argumente zu merken, können Argumente auch direkt benannt werden:</p>
<pre class="r"><code>log(x = 100, base = 10)</code></pre>
<pre><code>## [1] 2</code></pre>
<p>In diesem Fall muss man nicht mehr die Reihenfolge der Argumente, sondern lediglich deren Namen kennen. Wenn Argumente so benannt werden, können sie in einer beliebigen Reihenfolge in der Funktion genutzt werden:</p>
<pre class="r"><code>log(base = 10, x = 100)</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Weil es nur geringfügig einfacher ist, sich alle Namen von Argumente statt deren Reihenfolge zu merken, bietet R diverse Möglichkeiten sich diesbezüglich helfen zu lassen. Um z.B. die Namen und Reihenfolge von Argumenten einer Funktion in Erfahrung zu bringen kann die Funktion <code>args</code> auf jede R-Funktion angewendet werden:</p>
<pre class="r"><code>args(log)</code></pre>
<pre><code>## function (x, base = exp(1)) 
## NULL</code></pre>
<p>Dieses Ergebnis bedeutet, dass <code>log</code> zwei mögliche Argumente hat: <code>x</code> und <code>base</code>. Darüber hinaus besagt <code>base = exp(1)</code>, dass es für das zweite Argument eine Voreinstellung gibt, nämlich die Zahl <code>exp(1)</code>, also die Euler’sche Zahl <span class="math inline">\(e\)</span>. Diese Zahl wird dabei als Ergebnis der Funktion <code>exp</code> gewonnen:</p>
<pre class="r"><code>exp(1)</code></pre>
<pre><code>## [1] 2.718282</code></pre>
<p>Das Ergebnis dieser Funktion wird bestimmt und als Argument an die Funktion <code>log</code> weitergegeben. Das zeigt bereits eine zentrale Eigenschaft von R: Funktionen können ineinander geschachtelt werden. Dabei werden Klammern wie in der Mathematik gehandhabt und von innen nach außen evaluiert.</p>
<hr />
</div>
<div id="hilfe" class="section level2">
<h2>Hilfe</h2>
<p>R bietet ein sehr detailliertes und gutes integriertes Hilfesystem. Mit <code>args</code> kann man sich zwar die Argumente einer Funktion ausgeben lassen, erhält aber keinerlei Zusatzinformationen. Wenn man mehr Informationen bezüglich einer spezifischen Funktion benötigt, kann man <code>help</code> auf jede beliebige Funktion anwenden (bzw. <code>?</code> vor den Namen einer Funktion schreiben). Sie sollten - besonders zum Einstieg in R - häufig und gezielt diese Hilfe in Anspruch nehmen.</p>
<pre class="r"><code>help(log)</code></pre>
<p>Die Hilfe zur Funktion wird im Panel unten rechts geöffnet und ist ein Dokument, das üblicherweise aus den folgenden Abschnitten besteht:</p>
<ul>
<li><em>Description</em>: eine kurze Beschreibung der Funktion.</li>
<li><em>Usage</em>: die grundlegende Struktur der Funktion. Dieser Abschnitt enthält alle Argumente, die diese Funktion entgegennimmt. In manchen Fällen kann dieser Abschnitt auch mehrere Funktionen enthalten, die gemeinsam dokumentiert sind. Argumente, denen ein <code>= etwas</code> folgt, haben eine Voreinstellung und müssen nicht bei jedem Aufruf der Funktion angesprochen werden (sondern nur, wenn man eine andere Einstellung als die Voreinstellung nutzen will). Argumente, denen kein <code>=</code> folgt, müssen hingegen bei jeder Anwendung definiert werden.</li>
<li><em>Arguments</em>: Eine Liste der Argumente mit einer kurzen Beschreibung.</li>
<li><em>Details</em>: Zusatzinformationen zur Funktion.</li>
<li><em>Values</em>: Eine Liste der Ergebniselemente, die diese Funktion erzeugt. In R sind Ergebnisse häufig größer als das was in der Konsole gedruckt wird und dieser Abschnitt liefert eine Übersicht über diese Inhalte.</li>
<li><em>See also</em>: Ähnliche Funktionen, die vielleicht eher dem entsprechen, was man sucht.</li>
<li><em>Examples</em>: Der vielleicht wichtigste Abschnitt - hier wird die Funktion beispielhaft angewendet.</li>
</ul>
<p>Wenn man den genauen Namen einer Funktion nicht kennt, ist <code>help</code> meistens nur wenig hilfreich. Für diesen Fall gibt es die Funktion <code>apropos</code> mit der man die Hilfe-Dateien auf ein Schlagwort durchsuchen kann:</p>
<pre class="r"><code>apropos(&quot;logarithm&quot;)</code></pre>
<p>Dies sollte im Help-Tab eine Liste aller Funktionen öffnen, die mit dem Schlagwort “logarithm” versehen sind. Falls dem nicht so sein sollte, kann hier - wie bei der direkten Hilfe - auch mit einer Abkürzung gearbeitet werden. In diesem Fall ist es das doppelte Fragezeichen, also für den Logarithmus: <code>??logarithm</code></p>
<hr />
</div>
<div id="nachrichten-warnungen-und-fehler" class="section level2">
<h2>Nachrichten, Warnungen und Fehler</h2>
<p>Im Umgang mit R ist es unvermeidlich: es werden Fehler passieren. Wichtig ist nur, dass man weiß, was die Rückmeldung bedeutet, die R produziert und wie man darauf reagieren sollte. Zusätzlich zu dem Fall, in dem das korrekte Ergebnis produziert wird, kann man in R drei Formen von Rückmeldungen unterscheiden: messages, warnings und errors.</p>
<p>Eine <code>Message</code> liefert Informationen und dient ausschließlich der Kommunikation. Hier werden z.B. Hinweise bezüglich des Zustands einer Funktion gegeben (etwa, wenn sie sich noch in der Beta-Phase befindet) oder Zusatzinformationen geliefert, die die Interpretation eines Ergebnisse vereinfachen sollen. Der Text, den R bei jedem Start produziert, ist ein Beispiel für eine <code>Message</code>.</p>
<p>Eine <code>Warning</code> deutet darauf hin, dass höchstwahrscheinlich etwas nicht so gelaufen ist, wie geplant, aber dennoch ein Ergebnis produziert wurde. Für den Logarithmus erscheint beispielsweise eine Warnung:</p>
<pre class="r"><code>log(-1)</code></pre>
<pre><code>## Warning in log(-1): NaNs wurden erzeugt</code></pre>
<pre><code>## [1] NaN</code></pre>
<p>Warnung beginnen in R mit dem Wort <code>Warning</code>. In diesem Fall werden wir darauf hingewiesen, dass als Ergebnis der Funktion <code>NaNs</code> (Not a Number) erzeugt werden - also wahrscheinlich ein Ergebnis, das wir nicht haben wollten, als wir den Logarithmus aufgerufen haben.</p>
<p>Die letzte Art sind <code>Error</code>, die immer damit einhergehen, dass kein Ergebnis produziert wird. Für den Logarithmus erhalten wir einen Fehler wenn</p>
<pre class="r"><code>log(argument = 10)</code></pre>
<pre><code>## Error in eval(expr, envir, enclos): Argument &quot;x&quot; fehlt (ohne Standardwert)</code></pre>
<p>In diesem Fall werden wir darauf hingewiesen, dass wir keine Einstellung für das Argument <code>x</code> vorgenommen haben, obwohl dieses keine Voreinstellung hat. Daher ist die Funktion unfähig ein Ergebnis zu produzieren. Bei Fehlern sollten Sie bedenken, dass diese das Ausführen mehrerer Zeilen nicht unterbrechen. Wenn Sie also eine komplette Syntax auf einmal ausführen, können aus Fehlern Folgefehler entstehen, weil ein Ergebnis nicht entstanden ist, mit dem Sie anschließend weiter rechnen wollten.</p>
<hr />
</div>
<div id="objekte-und-das-environment" class="section level2">
<h2>Objekte und das Environment</h2>
<p>Einer der großen Vorteile von R gegenüber anderen Ansätzen zur statistischen Datenanalyse ist die Möglichkeit Ergebnisse in Objekten abzulegen und diese als Argumente in anderen Funktionen weiter zu verwenden. Dadurch ergibt sich in R die Möglichkeit sehr große Teile von Auswertungen und Ergebnisdarstellung mit generell gehaltenen Skripten zu automatisieren. Die Zuweisung eines Ergebnisses zu einem Objekt erfolgt über den sog. Zuweisungspfeil <code>&lt;-</code>.</p>
<pre class="r"><code>my_num &lt;- sum(3, 4, 1, 2)</code></pre>
<p>Anders als zuvor wird in diesem Fall in der Konsole kein Ergebnis ausgedruckt, sondern lediglich der Befehl gespiegelt. Das Ergebnis der Summen-Funktion ist im Objekt <code>my_num</code> abgelegt. Dieses Objekt sollte nun auch im Panel oben rechts - spezifischer im Tab <em>Environment</em> - aufgetaucht sein.</p>
<p>Objekte können beliebige Namen tragen - ausgeschlossen ist lediglich, dass die Namen mit einer Zahl beginnen. Generell wird empfohlen, Objekte im sog. <em>snake case</em> zu bezeichnen - also in der Form: <code>name_des_objekts</code>. Die Benennung sollte dabei so kurz und prägnant wie möglich sein. Zwei Objekte können aber niemals den gleichen Namen tragen. Wenn Sie ein zweites Objekt erstellen, dass den gleichen Namen trägt, wird das erste Objekt - ohne Warnung - überschrieben. Um den Inhalt eines Objektes abzurufen, müssen Sie lediglich den Namen des Objektes ausführen:</p>
<pre class="r"><code>my_num</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Das ist die Kurzfassung von <code>print(my_num)</code>. Das eigentliche Ziel von Objektzuweisungen ist aber, den Inhalt von Objekten an weitere Funktionen weiterreichen zu können.</p>
<pre class="r"><code>sqrt(my_num)</code></pre>
<pre><code>## [1] 3.162278</code></pre>
<p>Der Inhalt des Objektes wird so als Argument in die Funktion <code>sqrt</code> übergeben. Das ist letztlich das Gleiche wie</p>
<pre class="r"><code>sqrt(sum(3, 4, 1, 2))</code></pre>
<pre><code>## [1] 3.162278</code></pre>
<p>wo das Ergebnis nicht explizit in einem Objekt gespeichert wird, sondern direkt als Argument an eine Funktion weitergegeben wird. Dabei werden geschachtelte Funktionen - wie schon besprochen - von innen nach außen evaluiert. Die Aneinanderkettung von Objektzuweisungen und Schachtelungen ist unbegrenzt, sodass sehr komplexe Systeme entstehen können. Weil das aber sehr schnell anstrengend werden kann - und man dabei leicht den Überblick verliert, was eigentlich wann ausgeführt wird - gibt es noch eine weitere Variante, Funktionen aneinander zu reihen: die <em>Pipe</em>.</p>
<p>Bei der Pipe <code>|&gt;</code> wird ein links stehendes Objekt oder Ergebnis genommen und als <em>erstes Argument</em> der rechts stehenden Funktion eingesetzt. Für unser Wurzelbeispiel also:</p>
<pre class="r"><code>sum(3, 4, 1, 2) |&gt; sqrt()</code></pre>
<pre><code>## [1] 3.162278</code></pre>
<p>Das hat den immensen Vorteil, dass wir dadurch unseren Code wieder in der, im wesentlichen Kulturkreis üblichen Variante wie Text von links nach rechts lesen können. Dabei ist das was als erstes passiert links, das Ergebnis wird nach rechts weitergereicht und irgendetwas passiert damit. Auch dieses System ist theoretisch unendlich fortsetzbar:</p>
<pre class="r"><code>sum(3, 4, 1, 2) |&gt; sqrt() |&gt; log()</code></pre>
<pre><code>## [1] 1.151293</code></pre>
<p>Zusammengefasst gibt es also drei Möglichkeiten, um Ergebnisse von Berechnungen in weiteren Schritten weiter zu nutzen:</p>
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Beschreibung</th>
<th>Code-Stil</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Funktionen schachteln</td>
<td><code>funktion1(funktion2(argument))</code></td>
</tr>
<tr class="even">
<td>Objekt im Environment anlegen</td>
<td><code>objekt &lt;- funktion1(argument)</code> <br> <code>funktion2(objekt)</code></td>
</tr>
<tr class="odd">
<td>Ergebnis-Pipe</td>
<td><code>funktion1(argument) |&gt; funktion2()</code></td>
</tr>
</tbody>
</table>
<p>Wann benutzt man am besten welches dieser drei Systeme? Wie so häufig in R ist das eine Sache des persönlichen Schreibstils und dessen, womit man selbst gut zurecht kommt. Meine persönliche Empfehlung ist für dieses Dreiergespann:</p>
<ul>
<li>Ergebnisse sollte man als Objekte ablegen, wenn man das Ergebnis im Verlauf des Skripts noch an mehreren Stellen brauchen wird.</li>
<li>Funktionen kann man dann schachteln, wenn mehrere verschiedene Argumente erst aus anderen Funktionen erzeugt werden müssen.</li>
<li>Die Pipe bietet sich wegen der Leserlichkeit in allen anderen Fällen an.</li>
</ul>
<p>Wenn wir das Ergebnis unseres zweiten Schritts (also wenn wir die Wurzel ziehen), direkt wieder einem Objekt zuzuweisen, passiert Folgendes:</p>
<pre class="r"><code>my_root &lt;- sqrt(my_num)</code></pre>
<p>Im Environment (oben rechts) sollten jetzt zwei Objekte zu erkennen sein. R-intern kann das Environment über den <code>ls</code>-Befehl betrachtet werden:</p>
<pre class="r"><code>ls()</code></pre>
<pre><code>## [1] &quot;my_num&quot;  &quot;my_root&quot;</code></pre>
<p>Wenn das Environment sehr voll ist, kann die Ausgabe mit dem Argument <code>pattern =</code> auf spezifische Objekte eingeschränkt werden:</p>
<pre class="r"><code>ls(pattern = &#39;num&#39;)</code></pre>
<pre><code>## [1] &quot;my_num&quot;</code></pre>
<p>Objekte können auch einfach aus dem Environment entfernt werden:</p>
<pre class="r"><code>rm(my_num)
ls()</code></pre>
<pre><code>## [1] &quot;my_root&quot;</code></pre>
<p>Beachten Sie wieder, dass R ihnen keinerlei Warnung oder Nachfrage gibt, wenn Sie Objekte entfernen. Sollten Sie also Objekte haben, deren Erstellung lange dauert, gehen Sie vorsichtig mit <code>rm</code> um. Um das Environment gänzlich zu leeren können Sie entweder in RStudio den <img src="/post/2019-10-18-r-crash-kurs_files/clear_environment.png" /> Button (im Tab <em>Environment</em>) nutzen oder direkt über die Syntax arbeiten:</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<p>Es empfiehlt sich auch hier idealerweise alle Arbeitsschritte mittels Syntax durchzuführen, damit sie dokumentiert und nachvollziehbar sind.</p>
<p>Natürlich können wir die Objekterstellung auch mit der Schachtelung von Befehlen und der Pipe nach Belieben kombinieren. Wenn wir z.B. in drei Schritten ein Ergebnis erzeugen wollen, was wir später noch brauchen könnten, können wir das Ergebnis durch eine Pipe erstellen und dann als Objekt ablegen:</p>
<pre class="r"><code>my_num &lt;- sum(3, 4, 1, 2) |&gt; sqrt() |&gt; log()
my_num</code></pre>
<pre><code>## [1] 1.151293</code></pre>
<hr />
</div>
<div id="daten" class="section level2">
<h2>Daten</h2>
<p>Um zu verstehen, wie Daten in R funktionieren, nutzen wir als Beispiel ein klassisches Experiment aus der Psychologie: den Stroop Test. Die Grundidee lässt sich am leichtesten in einem Bild darstellen:</p>
<p><img src="/post/2019-10-18-r-crash-kurs_files/stroop.png" /></p>
<p>Der Stroop-Effekt ist der Unterschied zwischen der durchschnittlichen Zeit, die man benötigt um die Farbe zu nennen, in der ein Wort abgebildet ist - je nachdem ob die Farbe und das Wort gleich sind oder nicht. Wenn Sie über den Stroop Test mehr erfahren möchten, oder ihn selbst mal ausprobieren wollen, finden Sie bei <a href="https://www.psytoolkit.org/lessons/stroop.html">Psytoolkit</a> Informationen und eine Online-Variante des Tests.</p>
<p>Nehmen wir an, Sie hätten für dieses einfache Beispiel die acht Reaktionszeiten gemessen und diese wären (in Millisekunden): 510, 897, 647, 891, 925, 805, 443 und 778. Um diese Daten in R aufzunehmen können Sie folgendes machen:</p>
<pre class="r"><code>react &lt;- c(510, 897, 647, 891, 925, 805, 443, 778)</code></pre>
<p><code>c</code> ist eine Funktion mit der alle Argumente (in diesem Fall acht Reaktionszeiten) in ein gemeinsames Objekt zusammengeführt werden. Dieses Objekt ist ein Vektor - eine eindimensionale Datenreihe. Daten können unterschiedliche Formate haben - welches Format vorliegt erfahren wir mit</p>
<pre class="r"><code>class(react)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>Wir erfahren also, dass es sich um ein numerisches Objekt handelt. Um ein wenig detailliertere Information zu erhalten können wir <code>str</code> nutzen:</p>
<pre class="r"><code>str(react)</code></pre>
<pre><code>##  num [1:8] 510 897 647 891 925 805 443 778</code></pre>
<p>Wir erhalten als Ergebnis die <em>Struktur</em> des Objektes. In diesem Fall handelt es sich um ein numerisches (<code>num</code>) Objekt mit Elementen 1 bis 8 (<code>[1:8]</code>) und dem angezeigten Inhalt. Bei großen Objekten werden nicht alle, sondern nur die ersten paar Elemente hier angezeigt.</p>
<p>Im Kern werden in R drei Typen von Vektoren unterschieden:</p>
<table>
<thead>
<tr class="header">
<th>Typ</th>
<th>Kurzform</th>
<th>Inhalt</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>logical</code></td>
<td><code>logi</code></td>
<td>wahr (<code>TRUE</code>) oder falsch (<code>FALSE</code>)</td>
</tr>
<tr class="even">
<td><code>numeric</code></td>
<td><code>num</code></td>
<td>Beliebige Zahlen</td>
</tr>
<tr class="odd">
<td><code>character</code></td>
<td><code>char</code></td>
<td>Kombinationen aus Zahlen und Buchstaben</td>
</tr>
</tbody>
</table>
<p>Um die Reaktionszeiten in <code>react</code> interpretieren zu können, müssen sie mit der jeweiligen Farbe, in der Wort abgebildet ist, in Verbindung gebracht werden. Dafür bietet sich ein <code>character</code> Vektor an:</p>
<pre class="r"><code>color &lt;- c(&#39;gruen&#39;, &#39;gelb&#39;, &#39;blau&#39;, &#39;gruen&#39;, &#39;gelb&#39;, &#39;blau&#39;, &#39;rot&#39;, &#39;rot&#39;)</code></pre>
<p>Um zu prüfen, ob ein Objekt einen erwarteten Typ hat, können wir mit Funktionen vor den Typ-Namen <code>is.</code> schreiben und das als Funktion anwenden:</p>
<pre class="r"><code>is.character(color)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Das Präfix <code>as.</code> wandelt dann Vektoren von einem Typ in einen um:</p>
<pre class="r"><code>as.character(react)</code></pre>
<pre><code>## [1] &quot;510&quot; &quot;897&quot; &quot;647&quot; &quot;891&quot; &quot;925&quot; &quot;805&quot; &quot;443&quot; &quot;778&quot;</code></pre>
<pre class="r"><code>as.numeric(color)</code></pre>
<pre><code>## Warning: NAs durch Umwandlung erzeugt</code></pre>
<pre><code>## [1] NA NA NA NA NA NA NA NA</code></pre>
<p>Wie man sieht funktionieren Umwandlungen aber nicht beliebig - in diesem Fall gibt es keine sinnvolle, numerische Repräsentation der Farben (mehr dazu erfahren Sie in der ersten Sitzung der Vorlesung).</p>
<p>Als dritte Information benötigen wir in unserem Experiment den Text des Wortes:</p>
<pre class="r"><code>text &lt;- c(&#39;gruen&#39;, &#39;blau&#39;, &#39;blau&#39;, &#39;rot&#39;, &#39;gelb&#39;, &#39;gruen&#39;, &#39;rot&#39;, &#39;gelb&#39;)</code></pre>
<p>Die Kernaussage des Stroop-Effekts ist, dass Reaktionszeiten langsamer sind, wenn Farbe und Wort inkongruent sind (also wenn <code>color</code> und <code>text</code> ungleich sind) als wenn sie kongruent sind (wenn <code>color</code> und <code>text</code> gleich sind). Wie zuvor gesehen, können wir logische Operatoren nutzen um diesen Abgleich durchzuführen. Eine der großen Stärken von R ist, dass diese Abgleiche nicht nur funktionieren, wenn wir einzelne Elemente vergleichen, sondern auch, wenn wir ganze Vektoren vergleichen:</p>
<pre class="r"><code>cong &lt;- color == text
cong</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE</code></pre>
<p>In <code>cong</code> ist das Ergebnis des elementenweisen Vergleichs von <code>color</code> und <code>text</code> enthalten. Wir sehen also, dass das erste Wort kongruent war (<code>gruen == gruen</code>), das zweite Wort inkongruent (<code>gelb != blau</code>) usw. Wir können einfach zeigen, dass es sich hier um einen logischen Vektor handelt:</p>
<pre class="r"><code>is.logical(cong)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Eine Sonderform eines Vektors in R ist der <code>factor</code>. Diese Form wird genutzt um nominal- und ordinalskalierte Variablen (mehr dazu in der Vorlesung!) sinnvoll zu speichern. Das wird dadurch erreicht, dass ein <code>factor</code> eigentlich numerisch ist, aber gleichzeitig für jede Zahl ein sog. “Label” vergibt. Den <code>color</code> Vektor, beispielsweise, können wir mit <code>as.factor</code> von einem <code>character</code> in einen <code>factor</code> umwandeln:</p>
<pre class="r"><code>color_fac &lt;- as.factor(color)
str(color_fac)</code></pre>
<pre><code>##  Factor w/ 4 levels &quot;blau&quot;,&quot;gelb&quot;,..: 3 2 1 3 2 1 4 4</code></pre>
<p>In diesem Fall werden die ursprünglichen Farben in Zahlenwerte übertragen und es wird anhand des Labels (<code>"blau", "gelb", ...</code>) verdeutlicht welche Zahl welche Farbe repräsentiert. Um alle möglichen Ausprägungen (Engl. levels) der Variable zu sehen:</p>
<pre class="r"><code>levels(color_fac)</code></pre>
<pre><code>## [1] &quot;blau&quot;  &quot;gelb&quot;  &quot;gruen&quot; &quot;rot&quot;</code></pre>
<p>Wir sehen also, dass die Variable vier mögliche Ausprägungen hat. Die Zahlen werden entsprechend der Reihenfolge dieser <code>levels</code> vergeben. Bei der Umwandlung eines <code>character</code> Vektors in einen <code>factor</code> werden die <code>levels</code> dabei einfach alphabetisch sortiert. Um diese Abfolge zu ändern, können wir mit <code>relevel</code> bestimmen, welche Ausprägung den Wert <code>1</code> erhalten soll:</p>
<pre class="r"><code>relevel(color_fac, &#39;gruen&#39;)</code></pre>
<pre><code>## [1] gruen gelb  blau  gruen gelb  blau  rot   rot  
## Levels: gruen blau gelb rot</code></pre>
<p>Beachten Sie, dass hier - wie immer in R - durch das ausführen der Funktion keine Veränderung am Objekt vorgenommen wird! Wenn wir diese veränderte Variante speichern wollen, müssen wir dafür ein Objekt anlegen (entweder ein Neues oder das Alte überschreiben).</p>
<p>Durch die duale Zuordnung von Zahlen und Labels zum Vektor können <code>factor</code> sehr einfach sowohl in numerische Vektoren, als auch <code>character</code> Vektoren umgewandelt werden:</p>
<pre class="r"><code>as.numeric(color_fac)</code></pre>
<pre><code>## [1] 3 2 1 3 2 1 4 4</code></pre>
<pre class="r"><code>as.character(color_fac)</code></pre>
<pre><code>## [1] &quot;gruen&quot; &quot;gelb&quot;  &quot;blau&quot;  &quot;gruen&quot; &quot;gelb&quot;  &quot;blau&quot;  &quot;rot&quot;   &quot;rot&quot;</code></pre>
<p>Wie wir im Verlauf des Semesters sehen werden, haben beide Umwandlungen Konsequenzen für die Berechnungen, die wir durchführen können.</p>
<hr />
</div>
<div id="daten-zusammenführen" class="section level2">
<h2>Daten zusammenführen</h2>
<p>Im Environment liegen jetzt fünf Vektoren:</p>
<pre class="r"><code>ls()</code></pre>
<pre><code>## [1] &quot;color&quot;     &quot;color_fac&quot; &quot;cong&quot;      &quot;my_num&quot;    &quot;react&quot;     &quot;text&quot;</code></pre>
<p>Weil diese Vektoren zusammengehören, wäre es sinnvoll, sie zu einem Objekt zu kombinieren. Wie auch bei Vektoren, gibt es unterschiedliche Typen Daten zu kombinieren, allerdings sind ihre Relationen zueinander ein wenig komplizierter:</p>
<table>
<thead>
<tr class="header">
<th>Typ</th>
<th>Dimensionen</th>
<th>Inhalt</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>matrix</code></td>
<td>2</td>
<td>Vektoren des gleichen Typs</td>
</tr>
<tr class="even">
<td><code>array</code></td>
<td><span class="math inline">\(n\)</span></td>
<td>Vektoren des gleichen Typs</td>
</tr>
<tr class="odd">
<td><code>data.frame</code></td>
<td>2</td>
<td>Vektoren der gleichen Länge</td>
</tr>
<tr class="even">
<td><code>list</code></td>
<td>1</td>
<td>Beliebige Objekte</td>
</tr>
</tbody>
</table>
<p>Die Datentypen werden nach oben restriktiver - sie schränken die Kombinationsmöglichkeiten von Daten ein, werden dabei aber effizienter in der Datenverarbeiten (bezogen auf Rechenkapazitäten). In der Psychologie ist der <code>data.frame</code> die häufigste Variante Daten zu speichern. Besonders bei sehr großen Datensätzen (wie sie z.B. in der modernen neurokognitiven Psychologie entstehen) bietet es sich allerdings an mit <code>matrix</code> zu arbeiten.</p>
<p>Aus der Tabelle lässt sich leicht schließen, dass eine <code>matrix</code> ein Sonderfall eines <code>array</code> ist - Daten werden auf zwei Dimensionen restringiert. Vielleicht weniger eindeutig ist die Beziehung zwischen <code>data.frame</code> und <code>list</code>. Ein <code>data.frame</code> ist der Sonderfall einer <code>list</code> in dem alle Elemente die gleiche Länge haben.</p>
<p>Wir können damit beginnen, eine <code>matrix</code> zu erstellen. Dafür können wir zwei Vektoren des gleichen Typs kombinieren. Im Stroop Beispiel sind <code>color</code> und <code>text</code> beide vom Typ <code>character</code>:</p>
<pre class="r"><code>class(color)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>class(text)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>class(color) == class(text)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Um die Matrix zu erstellen, können wir entweder direkt den <code>matrix</code>-Befehl nutzen oder eine der beiden <code>bind</code>-Funktionen benutzen. Um Vektoren als Spalten (Engl. <em>columns</em>) zusammenzuführen, steht <code>cbind</code> zur Verfügung. Um Vektoren hingegen als Zeilen (Engl. <em>rows</em>) zusammenzuführen, können wir <code>rbind</code> nutzen. Typischerweise werden psychologische Daten so gehandhabt, dass verschiedene Beobachtungen (z.B. unterschiedliche Personen) in Zeilen und verschiedene Variablen in Spalten abgetragen werden. In unserem Fall haben wir acht Beobachtungen (jeder Vektor ist acht Einträge lang) und zwei Variablen (<code>color</code> und <code>text</code>). Daher sollten wir in diesem Fall mit <code>cbind</code> arbeiten:</p>
<pre class="r"><code>mat &lt;- cbind(color, text)
mat</code></pre>
<pre><code>##      color   text   
## [1,] &quot;gruen&quot; &quot;gruen&quot;
## [2,] &quot;gelb&quot;  &quot;blau&quot; 
## [3,] &quot;blau&quot;  &quot;blau&quot; 
## [4,] &quot;gruen&quot; &quot;rot&quot;  
## [5,] &quot;gelb&quot;  &quot;gelb&quot; 
## [6,] &quot;blau&quot;  &quot;gruen&quot;
## [7,] &quot;rot&quot;   &quot;rot&quot;  
## [8,] &quot;rot&quot;   &quot;gelb&quot;</code></pre>
<p>Das resultierende Objekt ist eine Matrix:</p>
<pre class="r"><code>class(mat)</code></pre>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<p>Weil Matrizen aber Sonderfälle von Arrays sind, ist dieses Objekt auch ein Array! Was es hingegen nicht ist, ist ein <code>data.frame</code> oder eine <code>list</code>.</p>
<pre class="r"><code>is.array(mat)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.data.frame(mat)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>is.list(mat)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Weil in einer <code>matrix</code> nur Vektoren des gleichen Typs kombiniert werden können, führt <code>cbind</code> dazu, dass Vektoren in den allgemeinsten, gemeinsamen Fall umgewandelt werden, bevor sie als Matrix zusammengeführt werden. Wie wir bereits gesehen haben, sind die “klassischen” Typen von Vektoren in R von spezifisch zu allgemein <code>logical</code> -&gt; <code>numeric</code> -&gt; <code>character</code>. In diesem Fall ist werden also alle Vektoren in <code>character</code> umgewandelt:</p>
<pre class="r"><code>mat &lt;- cbind(color, text, cong, react)
mat</code></pre>
<pre><code>##      color   text    cong    react
## [1,] &quot;gruen&quot; &quot;gruen&quot; &quot;TRUE&quot;  &quot;510&quot;
## [2,] &quot;gelb&quot;  &quot;blau&quot;  &quot;FALSE&quot; &quot;897&quot;
## [3,] &quot;blau&quot;  &quot;blau&quot;  &quot;TRUE&quot;  &quot;647&quot;
## [4,] &quot;gruen&quot; &quot;rot&quot;   &quot;FALSE&quot; &quot;891&quot;
## [5,] &quot;gelb&quot;  &quot;gelb&quot;  &quot;TRUE&quot;  &quot;925&quot;
## [6,] &quot;blau&quot;  &quot;gruen&quot; &quot;FALSE&quot; &quot;805&quot;
## [7,] &quot;rot&quot;   &quot;rot&quot;   &quot;TRUE&quot;  &quot;443&quot;
## [8,] &quot;rot&quot;   &quot;gelb&quot;  &quot;FALSE&quot; &quot;778&quot;</code></pre>
<p>Dadurch verlieren wir aber die Möglichkeit, <code>react</code> als numerische Variable zu nutzen. Das bedeutet, dass wir nach der Umwandlung keine mathematischen Berechnungen (und demzufolge auch nur noch limitierte statistische Analysen) mit der neuen Variable durchführen können. Um die Typen von Vektoren zu erhalten und so Unterschiede im Messniveau zwischen Variablen in den gespeicherten Daten zu berücksichtigen, wird meistens <code>data.frame</code> genutzt:</p>
<pre class="r"><code>dat &lt;- data.frame(color, text, cong, react)
dat</code></pre>
<pre><code>##   color  text  cong react
## 1 gruen gruen  TRUE   510
## 2  gelb  blau FALSE   897
## 3  blau  blau  TRUE   647
## 4 gruen   rot FALSE   891
## 5  gelb  gelb  TRUE   925
## 6  blau gruen FALSE   805
## 7   rot   rot  TRUE   443
## 8   rot  gelb FALSE   778</code></pre>
<pre class="r"><code>str(dat)</code></pre>
<pre><code>## &#39;data.frame&#39;:    8 obs. of  4 variables:
##  $ color: chr  &quot;gruen&quot; &quot;gelb&quot; &quot;blau&quot; &quot;gruen&quot; ...
##  $ text : chr  &quot;gruen&quot; &quot;blau&quot; &quot;blau&quot; &quot;rot&quot; ...
##  $ cong : logi  TRUE FALSE TRUE FALSE TRUE FALSE ...
##  $ react: num  510 897 647 891 925 805 443 778</code></pre>
<p>Beim Erstellen eines <code>data.frame</code> werden Vektoren per Voreinstellung in <code>factor</code> umgewandelt. Wie bereits geschildert, müssen alle Vektoren, die zu einem <code>data.frame</code> zusammengeführt werden die gleiche Länge haben. Wenn wir also einen Vektor erstellen, der nur 3 Einträge hat, können wir keinen gemeinsamen Datensatz erzeugen:</p>
<pre class="r"><code>three &lt;- c(1, 2, 3)
data.frame(color, text, cong, react, three)</code></pre>
<pre><code>## Error in data.frame(color, text, cong, react, three): Argumente implizieren unterschiedliche Anzahl Zeilen: 8, 3</code></pre>
<p>Dazu gibt es jedoch eine, sehr spezifische, Ausnahme. Es ist möglich, dass Vektoren unterschiedliche Längen haben, wenn die längere Länge ein Vielfaches der kürzeren Länge ist. Wenn wir also einen Vektor mit 4 Elementen erstellen:</p>
<pre class="r"><code>four &lt;- c(three, 4)
data.frame(color, text, cong, react, four)</code></pre>
<pre><code>##   color  text  cong react four
## 1 gruen gruen  TRUE   510    1
## 2  gelb  blau FALSE   897    2
## 3  blau  blau  TRUE   647    3
## 4 gruen   rot FALSE   891    4
## 5  gelb  gelb  TRUE   925    1
## 6  blau gruen FALSE   805    2
## 7   rot   rot  TRUE   443    3
## 8   rot  gelb FALSE   778    4</code></pre>
<p>In diesen Fällen wird der kurze Vektor solange wiederholt, bis er genauso lang ist, wie der lange Vektor.</p>
<hr />
</div>
<div id="datenextraktion" class="section level2">
<h2>Datenextraktion</h2>
<p>Bisher haben wir uns mit dem Zusammenführen von Daten befasst, wie es bei der Datensammlung üblich ist. Bei der Datenauswertung und -inspektion kann es aber genauso wichtig sein, Einzelteile von Datensätzen zu extrahieren.</p>
<p>Der einfachste Fall in R ist die Extraktion eines Elements aus einem Vektor. Dazu können wir noch einmal die Struktur eines Vektors inspizieren:</p>
<pre class="r"><code>str(react)</code></pre>
<pre><code>##  num [1:8] 510 897 647 891 925 805 443 778</code></pre>
<p>Die <code>[1:8]</code> zeigt uns, wie viele Elemente im Vektor enthalten sind und die Klammern zeigen uns, wie diese Elemente angesprochen werden können:</p>
<pre class="r"><code>react[5]</code></pre>
<pre><code>## [1] 925</code></pre>
<p>So erhalten wir das fünfte Element aus dem Vektor. Mit einzelnen Zahlen in den eckigen Klammern können also direkt einzelne Elemente ausgewählt werden. Umgekehrt können auch einzelne Elemente ausgeschlossen werden:</p>
<pre class="r"><code>react[-5]</code></pre>
<pre><code>## [1] 510 897 647 891 805 443 778</code></pre>
<p>In den Klammern müssen aber nicht nur einzelne Elemente stehen. Wie beinahe Alles in R, lässt sich eine Funktionsweise einzelner Elemente auch auf ganze Vektoren übertragen. Wir können also einen Selektionsvektor nutzen, um mehrere Elemente auszuwählen:</p>
<pre class="r"><code>sel &lt;- c(1, 3, 5)
react[sel]</code></pre>
<pre><code>## [1] 510 647 925</code></pre>
<p>Wie bei allen Dingen, brauchen wir nicht zwingend das Objekt <code>sel</code> anlegen, sondern können Funktionen schachteln:</p>
<pre class="r"><code>react[c(1, 3, 5)]</code></pre>
<pre><code>## [1] 510 647 925</code></pre>
<p>Weil es bei großen Datensätzen oder über unterschiedliche Datensätze hinweg selten vorkommt, dass wir spezifische Positionen von relevanten Elementen kennen, können Vektoren auch logisch gefiltert werden. Das bedeutet, dass wir anhand eines logischen Vektors mit der gleichen Länge wie unser Zielvektor über <code>TRUE</code> und <code>FALSE</code> Elemente auswählen können. Einen solchen Vektor haben wir bereits erstellt, nämlich <code>cong</code> der kongruente Farbe-Wort Paare kennzeichnet. Um also alle kongruenten Reaktionszeiten auszuwählen:</p>
<pre class="r"><code>react[cong]</code></pre>
<pre><code>## [1] 510 647 925 443</code></pre>
<p>Oder auch das Gegenteil:</p>
<pre class="r"><code>react[!cong]</code></pre>
<pre><code>## [1] 897 891 805 778</code></pre>
<p>Weil Vektoren eindimensional sind, benötigen wir zur Auswahl von Elementen nur eine Information. Bei <code>matrix</code> und <code>data.frame</code> sieht das natürlich anders aus. Der zuvor erstelle <code>data.frame</code> sieht so aus:</p>
<pre class="r"><code>dat</code></pre>
<pre><code>##   color  text  cong react
## 1 gruen gruen  TRUE   510
## 2  gelb  blau FALSE   897
## 3  blau  blau  TRUE   647
## 4 gruen   rot FALSE   891
## 5  gelb  gelb  TRUE   925
## 6  blau gruen FALSE   805
## 7   rot   rot  TRUE   443
## 8   rot  gelb FALSE   778</code></pre>
<p>Er hat also 8 Zeilen und 4 Spalten. Um z.B. die 5. Reaktionszeit auszuwählen, müssen wir das Element in der 5. Zeile und 4. Spalte ansprechen. Bei mehrdimensionalen Objekten werden in R die Dimensionen in eckigen Klammern einfach durch Kommata getrennt:</p>
<pre class="r"><code>dat[5, 4]</code></pre>
<pre><code>## [1] 925</code></pre>
<p>In R-Termini nimmt die Auswahlfunktion (die eckigen Klammern) in diesem Fall zwei Argumente entgegen: Zeile und Spalte. Wenn ein Argument ausgelassen wird, ist die Voreinstellung, dass alle Elemente dieser Dimension ausgegeben werden:</p>
<pre class="r"><code>dat[1, ]   # 1. Zeile, alle Spalten</code></pre>
<pre><code>##   color  text cong react
## 1 gruen gruen TRUE   510</code></pre>
<pre class="r"><code>dat[, 1]   # Alle Zeilen, 1. Spalte</code></pre>
<pre><code>## [1] &quot;gruen&quot; &quot;gelb&quot;  &quot;blau&quot;  &quot;gruen&quot; &quot;gelb&quot;  &quot;blau&quot;  &quot;rot&quot;   &quot;rot&quot;</code></pre>
<p>Wie bei Vektoren, kann die Auswahl wieder über verschiedene Kombinationen aus Auswahlvektoren und einzelnen Elementen erfolgen:</p>
<pre class="r"><code>dat[c(2, 3), 3]   # 2. und 3. Zeile, 3. Spalte</code></pre>
<pre><code>## [1] FALSE  TRUE</code></pre>
<pre class="r"><code>dat[cong, ]       # Alle kongruenten Zeilen, alle Spalten</code></pre>
<pre><code>##   color  text cong react
## 1 gruen gruen TRUE   510
## 3  blau  blau TRUE   647
## 5  gelb  gelb TRUE   925
## 7   rot   rot TRUE   443</code></pre>
<p>Um herauszufinden, wieivel Zeilen und Spalten ein Datensatz hat, gibt es die beiden Funktionen:</p>
<pre class="r"><code>nrow(dat)    # Anzahl der Zeilen</code></pre>
<pre><code>## [1] 8</code></pre>
<pre class="r"><code>ncol(dat)    # Anzahl der Spalten</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code>dim(dat)     # Alle Dimensionen</code></pre>
<pre><code>## [1] 8 4</code></pre>
<p>In <code>data.frame</code> sind die einzelnen Spalten üblicherweise benannt, weil es sinnvoll ist Variablen spezifische Namen zu geben. Um diese Namen abfragen zu können, gibt es die <code>names</code> Funktion:</p>
<pre class="r"><code>names(dat)</code></pre>
<pre><code>## [1] &quot;color&quot; &quot;text&quot;  &quot;cong&quot;  &quot;react&quot;</code></pre>
<p>Wenn wir also spezifische Variablen aus einem Datensatz auswählen möchten, können wir diese auch über ihren Namen ansprechen:</p>
<pre class="r"><code>dat[, &#39;react&#39;]                # Einzelne Variable auswählen</code></pre>
<pre><code>## [1] 510 897 647 891 925 805 443 778</code></pre>
<pre class="r"><code>dat[, c(&#39;react&#39;, &#39;cong&#39;)]     # Mehrere Variable auswählen</code></pre>
<pre><code>##   react  cong
## 1   510  TRUE
## 2   897 FALSE
## 3   647  TRUE
## 4   891 FALSE
## 5   925  TRUE
## 6   805 FALSE
## 7   443  TRUE
## 8   778 FALSE</code></pre>
<p>Beachten Sie hierbei, dass die Variablennamen in Anführungszeichen stehen müssen, da die Variable sonst als Filtervektor genutzt wird! Als Kurzform für die Auswahl einzelner Variable wird in R häufig das <code>$</code> genutzt:</p>
<pre class="r"><code>dat$react</code></pre>
<pre><code>## [1] 510 897 647 891 925 805 443 778</code></pre>
<hr />
</div>
<div id="daten-verändern-und-hinzufügen" class="section level2">
<h2>Daten verändern und hinzufügen</h2>
<p>Der Zuweisungspfeil funktioniert auch für Elemente größerer Objekte. Nehmen wir an, wir hätten uns bei der Eingabe der 5. Reaktionszeit vertippt und diese sei eigentlich 725 ms gewesen. Um die vorhandenen Daten zu überschreiben, können wir neue Werte direkt zuweisen. Auch hier sollte beachtet werden, dass es dabei keinerlei Warnung und Absicherung gibt. Sobald die Zuweisung ausgeführt ist, sind die Daten überschrieben und die vorherigen Daten verloren.</p>
<pre class="r"><code>dat[5, &#39;react&#39;]           # Aktuellen Inhalt abfragen</code></pre>
<pre><code>## [1] 925</code></pre>
<pre class="r"><code>dat[5, &#39;react&#39;] &lt;- 725    # Aktuellen Inhalt überschreiben
dat[, &#39;react&#39;]            # Alle Reaktionszeiten abfragen</code></pre>
<pre><code>## [1] 510 897 647 891 725 805 443 778</code></pre>
<p>Mit eckigen Klammern und <code>$</code> können auch Zeilen und Spalten angesprochen werden, die noch nicht existieren. Dieser Ansatz kann z.B. genutzt werden um eine neue Variable zu erstellen. Wenn wir, beispielsweise auch Inkongruenz explizit als Variable im Datensatz aufnehmen wollen, können wir diese Variable direkt erzeugen.</p>
<pre class="r"><code>dat$incong &lt;- !dat$cong
dat</code></pre>
<pre><code>##   color  text  cong react incong
## 1 gruen gruen  TRUE   510  FALSE
## 2  gelb  blau FALSE   897   TRUE
## 3  blau  blau  TRUE   647  FALSE
## 4 gruen   rot FALSE   891   TRUE
## 5  gelb  gelb  TRUE   725  FALSE
## 6  blau gruen FALSE   805   TRUE
## 7   rot   rot  TRUE   443  FALSE
## 8   rot  gelb FALSE   778   TRUE</code></pre>
<p>Per Voreinstellung werden neue Variablen an die letzte Stelle des Datensatzes aufgenommen. Das Gleiche können wir auch mit neuen Zeilen machen. Hierfür müssen wir eine komplette Zeile mit den korrekten Variablen eingeben.</p>
<pre class="r"><code>dat[9, ] &lt;- c(&#39;gelb&#39;, &#39;gruen&#39;, FALSE, 824, TRUE)
dat</code></pre>
<pre><code>##   color  text  cong react incong
## 1 gruen gruen  TRUE   510  FALSE
## 2  gelb  blau FALSE   897   TRUE
## 3  blau  blau  TRUE   647  FALSE
## 4 gruen   rot FALSE   891   TRUE
## 5  gelb  gelb  TRUE   725  FALSE
## 6  blau gruen FALSE   805   TRUE
## 7   rot   rot  TRUE   443  FALSE
## 8   rot  gelb FALSE   778   TRUE
## 9  gelb gruen FALSE   824   TRUE</code></pre>
<p>Um Zeilen oder Spalten aus einem <code>data.frame</code> zu “entfernen” muss eine Kopie des <code>data.frame</code> angelegt werden, in dem dieser Inhalt nicht vorhanden ist. Diese Kopie kann auch genutzt werden um den ursprünglichen <code>data.frame</code> zu überschreiben und so Dinge zu entfernen:</p>
<pre class="r"><code>dat &lt;- dat[-9, ]    # Datensatz ohne die 9. Zeile
dat</code></pre>
<pre><code>##   color  text  cong react incong
## 1 gruen gruen  TRUE   510  FALSE
## 2  gelb  blau FALSE   897   TRUE
## 3  blau  blau  TRUE   647  FALSE
## 4 gruen   rot FALSE   891   TRUE
## 5  gelb  gelb  TRUE   725  FALSE
## 6  blau gruen FALSE   805   TRUE
## 7   rot   rot  TRUE   443  FALSE
## 8   rot  gelb FALSE   778   TRUE</code></pre>
<hr />
</div>
<div id="daten-importexport" class="section level2">
<h2>Daten Import/Export</h2>
<p>Alles Objekte, die bisher erstellt wurden liegen im Workspace - sobald wir R schließen wird dieser Workspace geleert und die Objekte gehen verloren. In den meisten Fällen ist das explizit gewünschtes Verhalten - durch die Syntax können wir die Objekte ja wiederherstellen - aber in manchen Fällen ist es Sinnvoll Objekte wie Datensätze abzuspeichern und in späteren Schritten die bereits bearbeiteten Daten zu laden.</p>
<p>Um Daten zu laden und zu speichern muss R wissen an welchem Ort nach diesen Daten zu suchen ist. In den meisten Fällen macht es Sinn, für Projekte einen Ordner anzulegen in dem alle relevanten Dateien (z.B. Daten und Syntax) enthalten sind. Dieser Ordner kann R als <em>Working Directory</em> mitgeteilt werden. Das aktuelle Working Directory kann man einfach abrufen:</p>
<pre class="r"><code>getwd()</code></pre>
<p>Als Ergebnis sollte ein Ordnerpfad ausgeben werden. Unter Windows hat dieser wahrscheinlich das Format <code>C:/Users/Name/Documents</code>. Um manuell einen anderen Ordner zu nutzen, kann dieser mit <code>setwd</code> festgelegt werden:</p>
<pre class="r"><code>setwd(&#39;Pfad/Zum/Ordner&#39;)</code></pre>
<p>Windows nutzt <code>\</code> statt <code>/</code> um Ordner zu strukturieren. Wenn Sie also ihren Zielordner direkt aus der Adresszeile des Ordners kopieren müssen Sie diese Slashes austauschen. Unter OS X oder Linux besteht dieses Problem nicht.</p>
<p>Um sich den Inhalt eines Ordners anzeigen zu lassen (z.B. um zu prüfen, welche Dateien bereits in dem Ordner vorhanden sind):</p>
<pre class="r"><code>dir()</code></pre>
<p>R hat zwei eigene Datenformate mit denen Dateien abgespeichert werden können: RDA und RDS.</p>
<table>
<colgroup>
<col width="64%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead>
<tr class="header">
<th>Dateiformat</th>
<th>RDA</th>
<th>RDS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dateiendung</td>
<td>.rda, .RData</td>
<td>.rds</td>
</tr>
<tr class="even">
<td>Speichern</td>
<td><code>save</code></td>
<td><code>saveRDS</code></td>
</tr>
<tr class="odd">
<td>Laden</td>
<td><code>load</code></td>
<td><code>readRDS</code></td>
</tr>
<tr class="even">
<td>Gespeicherte Objekte</td>
<td>Mehrere</td>
<td>Einzeln</td>
</tr>
<tr class="odd">
<td>Ladeverhalten</td>
<td>Objekte werden im Environment wiederhergestellt</td>
<td>Geladene Daten einem neuen Objekt zuweisen</td>
</tr>
</tbody>
</table>
<p>Generell ist RDS dann zu präferieren, wenn einzelne Objekte (z.B. Datensätze) gespeichert werden und RDA dann, wenn man mehrere Objekte gemeinsam abspeichern möchte. Der Vorteil von RDS ist, dass geladenen Dateien beim Laden ein neuer, in dieser Sitzung nützlicher Name gegeben werden kann. Beim Laden eines RDA werden die Objekte mit den Namen geladen, die sie bei ihrer Erstellung hatten, was zu Konflikten mit bereits im Environment vorhandenen Objekten führen kann (diese werden ohne Vorwarnung überschrieben).</p>
<p>Dieses Verhalten können wir uns im Folgenden anschauen. Zunächst speichern wir den Stroop Datensatz:</p>
<pre class="r"><code>save(dat, file = &#39;dat.rda&#39;)</code></pre>
<p>Dann leeren wir das gesamte Environment:</p>
<pre class="r"><code>rm(list = ls())
ls()</code></pre>
<pre><code>## character(0)</code></pre>
<p>Wenn wir jetzt den Datensatz laden, wird er mit seiner Originalbenennung (<code>dat</code>) wiederhergestellt:</p>
<pre class="r"><code>load(&#39;dat.rda&#39;)
ls()</code></pre>
<pre><code>## [1] &quot;dat&quot;</code></pre>
<p>Jetzt durchlaufen wir die gleichen Schritte mit dem RDS Format:</p>
<pre class="r"><code>saveRDS(dat, &#39;dat.rds&#39;)
rm(list = ls())
ls()</code></pre>
<pre><code>## character(0)</code></pre>
<p>Beim Laden des Datensatzes können wir diesen jetzt einem beliebigen Objekt zuweisen:</p>
<pre class="r"><code>stroop &lt;- readRDS(&#39;dat.rds&#39;)
stroop</code></pre>
<pre><code>##   color  text  cong react incong
## 1 gruen gruen  TRUE   510  FALSE
## 2  gelb  blau FALSE   897   TRUE
## 3  blau  blau  TRUE   647  FALSE
## 4 gruen   rot FALSE   891   TRUE
## 5  gelb  gelb  TRUE   725  FALSE
## 6  blau gruen FALSE   805   TRUE
## 7   rot   rot  TRUE   443  FALSE
## 8   rot  gelb FALSE   778   TRUE</code></pre>
<p>Dieses Verhalten ist konsistent mit dem Verhalten von anderen Funktionen zum Datenimport. R kann mithilfe verschiedener Funktionen eine Vielzahl unterschiedlicher Datenformate einlesen. Zwei sehr typische - Klartextformate (.txt oder .dat) und CSV (.csv) - können über die Funktionen <code>read.table</code> und <code>read.csv</code> eingelesen werden. Genaugenommen ist dabei <code>read.csv</code> nur eine Abwandlung von <code>read.table</code> mit anderen Voreinstellungen für die gleichen Argumente, sodass wir hier nur die <code>read.table</code> Funktion betrachten werden.</p>
<hr />
</div>
<div id="daten-aus-dem-fragebogen" class="section level2">
<h2>Daten aus dem Fragebogen</h2>
<p>Die Daten aus der Befragung, die Sie letzte Woche ausgefüllt haben finden Sie <a href="/post/fb20.csv"><i class="fas fa-download"></i> hier</a>. Diese liegen im CSV Format vor und die Datei heißt <strong>fb20.csv</strong>. Mit <code>read.table</code> können wir diesen Datensatz laden, müssen aber bestimmte Eigenheiten des Datensatzes bedenken. Wenn Sie den Datensatz mit einem Text-Editor öffnen sehen die ersten 5 Zeilen folgendermaßen aus:</p>
<pre><code>## &quot;mdbf1&quot;,&quot;mdbf2&quot;,&quot;mdbf3&quot;,&quot;mdbf4&quot;,&quot;mdbf5&quot;,&quot;mdbf6&quot;,&quot;mdbf7&quot;,&quot;mdbf8&quot;,&quot;mdbf9&quot;,&quot;mdbf10&quot;,&quot;mdbf11&quot;,&quot;mdbf12&quot;,&quot;lz&quot;,&quot;extra&quot;,&quot;vertr&quot;,&quot;gewis&quot;,&quot;neuro&quot;,&quot;intel&quot;,&quot;pro&quot;,&quot;grund&quot;,&quot;fach&quot;,&quot;ziel&quot;,&quot;lerntyp&quot;,&quot;geschl&quot;,&quot;job&quot;,&quot;ort&quot;,&quot;ort12&quot;,&quot;wohnen&quot;,&quot;uni1&quot;,&quot;uni2&quot;,&quot;uni3&quot;,&quot;uni4&quot;
## 3,2,4,3,2,1,2,3,4,3,2,2,5.4,3.5,3.5,4,4.25,3.25,1.9,&quot;weil mich die menschliche Psyche sehr interessiert, vor allem die Ursachen fÃ¼r negative Verhaltenweisen, Charaktereigenschaften, Entwicklung&quot;,3,2,1,1,2,1,2,1,1,1,0,0
## 5,3,2,1,3,4,3,5,1,3,1,5,6.8,4,5,3.5,3,3.75,2.1,&quot;Tiefes Interesse&quot;,3,2,3,1,1,2,2,4,1,0,0,0
## 4,4,2,1,1,4,1,4,2,4,1,4,5,3.5,5,3.75,4.5,4.5,2.5,&quot;Interessante Themen&quot;,4,2,1,2,1,1,1,2,1,1,0,0
## 4,2,3,-99,4,2,5,3,4,1,3,2,3.6,2.75,3.75,4.25,4.75,2.25,2.7,&quot;Interesse auf Menschen&quot;,3,3,1,2,2,2,2,1,0,1,0,0</code></pre>
<p>Die Art in der dieser Datensatz aufbereitet ist, muss R mitgeteilt werden, damit wir ihn ordentlich einlesen können. Es empfiehlt sich dafür mit <code>help(read.table)</code> die Hilfe zu öffnen. Was diese Hilfe verrät sind unter Anderem die Argumente, die die Funktion entgegennimmt:</p>
<pre class="r"><code>args(read.table)</code></pre>
<pre><code>## function (file, header = FALSE, sep = &quot;&quot;, quote = &quot;\&quot;&#39;&quot;, dec = &quot;.&quot;, 
##     numerals = c(&quot;allow.loss&quot;, &quot;warn.loss&quot;, &quot;no.loss&quot;), row.names, 
##     col.names, as.is = !stringsAsFactors, na.strings = &quot;NA&quot;, 
##     colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, 
##     fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, 
##     comment.char = &quot;#&quot;, allowEscapes = FALSE, flush = FALSE, 
##     stringsAsFactors = FALSE, fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, 
##     text, skipNul = FALSE) 
## NULL</code></pre>
<p>Das einzige Argument ohne Voreinstellung ist <code>file</code>, also der Dateiname. Wenn wir den Datensatz mit Voreinstellungen laden, erhalten wir folgenden Fehler:</p>
<pre class="r"><code>fb20 &lt;- read.table(&#39;fb20.csv&#39;)</code></pre>
<pre><code>## Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : line 1 did not have 16 elements</code></pre>
<p>Das liegt in diesem Fall daran, dass <code>read.table</code> als Voreinstellung annimmt, dass die erste Zeile der Datei nicht besonders ist (<code>header = FALSE</code>). In unserem Fall enthält diese Zeile aber die Namen der Variablen, sodass wir diese Einstellung ändern müssen:</p>
<pre class="r"><code>fb20 &lt;- read.table(&#39;fb20.csv&#39;, header = TRUE)</code></pre>
<pre><code>## Error in read.table(&quot;fb20.csv&quot;, header = TRUE): more columns than column names</code></pre>
<p>Wieder ergibt sich ein Fehler, der lamentiert, dass es mehr Spalten als Variablennamen gibt. Das liegt daran, dass <code>read.table</code> per Voreinstellung davon ausgeht, dass Variablen (bzw. Spalten des Datensatzes) durch Leerzeichen getrennt sind (<code>sep = ""</code>). In unserer Datei erfolgt das aber durch Kommata.</p>
<pre class="r"><code>fb20 &lt;- read.table(&#39;fb20.csv&#39;, header = TRUE, sep = &quot;,&quot;)</code></pre>
<p>Im Environment erscheint jetzt das Objekt <code>fb20</code>. Mit <code>head</code> können wir uns den Kopf des Datensatzes (die ersten 6 Zeilen) anzeigen lassen:</p>
<pre class="r"><code>head(fb20)    # Kopfzeilen</code></pre>
<pre><code>##   mdbf1 mdbf2 mdbf3 mdbf4 mdbf5 mdbf6 mdbf7 mdbf8 mdbf9 mdbf10 mdbf11 mdbf12
## 1     3     2     4     3     2     1     2     3     4      3      2      2
## 2     5     3     2     1     3     4     3     5     1      3      1      5
## 3     4     4     2     1     1     4     1     4     2      4      1      4
## 4     4     2     3   -99     4     2     5     3     4      1      3      2
## 5     5     4     2     1     1     4     2     5     2      3      2      4
## 6     4     4     1     1     1     3     3     4     1      4      1      4
##    lz extra vertr gewis neuro intel pro
## 1 5.4  3.50  3.50  4.00  4.25  3.25 1.9
## 2 6.8  4.00  5.00  3.50  3.00  3.75 2.1
## 3 5.0  3.50  5.00  3.75  4.50  4.50 2.5
## 4 3.6  2.75  3.75  4.25  4.75  2.25 2.7
## 5 5.6  4.25  3.50  4.25  4.25  4.50 2.9
## 6 5.4  3.00  4.50  4.75  2.00  4.00 2.1
##                                                                                                                                           grund
## 1 weil mich die menschliche Psyche sehr interessiert, vor allem die Ursachen fÃ¼r negative Verhaltenweisen, Charaktereigenschaften, Entwicklung
## 2                                                                                                                              Tiefes Interesse
## 3                                                                                                                           Interessante Themen
## 4                                                                                                                        Interesse auf Menschen
## 5                                                                                                                            GroÃŸes Interesse 
## 6                                                                           Menschen zuhÃ¶ren, helfen, andere Vorstellungen &amp; Erleben verstehen
##   fach ziel lerntyp geschl job ort ort12 wohnen uni1 uni2 uni3 uni4
## 1    3    2       1      1   2   1     2      1    1    1    0    0
## 2    3    2       3      1   1   2     2      4    1    0    0    0
## 3    4    2       1      2   1   1     1      2    1    1    0    0
## 4    3    3       1      2   2   2     2      1    0    1    0    0
## 5    2    3       3      1   1   1     1      1    1    1    0    0
## 6    1    1       1      2   1   1     1      2    0    1    1    0</code></pre>
<pre class="r"><code>str(fb20)     # Struktur des Datensatzes</code></pre>
<pre><code>## &#39;data.frame&#39;:    98 obs. of  32 variables:
##  $ mdbf1  : int  3 5 4 4 5 4 3 4 2 4 ...
##  $ mdbf2  : int  2 3 4 2 4 4 4 2 2 2 ...
##  $ mdbf3  : int  4 2 2 3 2 1 1 4 4 2 ...
##  $ mdbf4  : int  3 1 1 -99 1 1 2 3 4 2 ...
##  $ mdbf5  : int  2 3 1 4 1 1 1 3 4 4 ...
##  $ mdbf6  : int  1 4 4 2 4 3 4 3 2 4 ...
##  $ mdbf7  : int  2 3 1 5 2 3 1 4 4 4 ...
##  $ mdbf8  : int  3 5 4 3 5 4 4 4 2 4 ...
##  $ mdbf9  : int  4 1 2 4 2 1 1 4 4 2 ...
##  $ mdbf10 : int  3 3 4 1 3 4 3 3 2 4 ...
##  $ mdbf11 : int  2 1 1 3 2 1 1 3 5 2 ...
##  $ mdbf12 : int  2 5 4 2 4 4 4 2 2 4 ...
##  $ lz     : num  5.4 6.8 5 3.6 5.6 5.4 4.8 3.6 5 5.4 ...
##  $ extra  : num  3.5 4 3.5 2.75 4.25 3 3.5 4 3.25 3.5 ...
##  $ vertr  : num  3.5 5 5 3.75 3.5 4.5 4.5 4 4.5 5 ...
##  $ gewis  : num  4 3.5 3.75 4.25 4.25 4.75 4.5 4.25 3 4.75 ...
##  $ neuro  : num  4.25 3 4.5 4.75 4.25 2 4 3.5 3.25 4.25 ...
##  $ intel  : num  3.25 3.75 4.5 2.25 4.5 4 3.25 3.5 2.75 3.5 ...
##  $ pro    : num  1.9 2.1 2.5 2.7 2.9 2.1 2.4 2 2.5 2.2 ...
##  $ grund  : chr  &quot;weil mich die menschliche Psyche sehr interessiert, vor allem die Ursachen fÃ¼r negative Verhaltenweisen, Chara&quot;| __truncated__ &quot;Tiefes Interesse&quot; &quot;Interessante Themen&quot; &quot;Interesse auf Menschen&quot; ...
##  $ fach   : int  3 3 4 3 2 1 4 1 4 -99 ...
##  $ ziel   : int  2 2 2 3 3 1 2 1 2 -99 ...
##  $ lerntyp: int  1 3 1 1 3 1 1 3 3 -99 ...
##  $ geschl : int  1 1 2 2 1 2 1 1 -99 -99 ...
##  $ job    : int  2 1 1 2 1 1 1 1 1 -99 ...
##  $ ort    : int  1 2 1 2 1 1 1 2 -99 -99 ...
##  $ ort12  : int  2 2 1 2 1 1 1 3 1 -99 ...
##  $ wohnen : int  1 4 2 1 1 2 3 2 1 -99 ...
##  $ uni1   : int  1 1 1 0 1 0 0 0 0 0 ...
##  $ uni2   : int  1 0 1 1 1 1 1 1 0 0 ...
##  $ uni3   : int  0 0 0 0 0 1 0 0 0 0 ...
##  $ uni4   : int  0 0 0 0 0 0 0 1 0 0 ...</code></pre>
<p>Wir können den Datensatz übrigens auch direkt von der Website in R laden. Der Dateiname nimmt auch direkt URLs entegegen:</p>
<pre class="r"><code>fb20 &lt;- read.table(&#39;https://pandar.netlify.app/post/fb20.csv&#39;, header = TRUE, sep = &quot;,&quot;)</code></pre>
<p>so kann umgangen werden, dass wir die gleiche Datei immer und überall lokal speichern müssen, obwohl wir eine zentrale, online verfügbare Datei nutzen.</p>
<p>Gegenspieler von <code>read.table</code> ist <code>write.table</code> mit dem Daten im Klartextformat gespeichert werden können. Um den Datensatz als .txt-Datei abzuspeichern können wir Folgendes nutzen:</p>
<pre class="r"><code>write.table(fb20,     # zu speichernder Datensatz
  &#39;fb20.txt&#39;          # Dateiname
  )</code></pre>
<p>Diese Datei entspricht den Voreinstellungen von <code>write.table</code>. Daher sehen die ersten 5 Zeilen in einem Text-Editor jetzt so aus:</p>
<pre><code>## &quot;mdbf1&quot; &quot;mdbf2&quot; &quot;mdbf3&quot; &quot;mdbf4&quot; &quot;mdbf5&quot; &quot;mdbf6&quot; &quot;mdbf7&quot; &quot;mdbf8&quot; &quot;mdbf9&quot; &quot;mdbf10&quot; &quot;mdbf11&quot; &quot;mdbf12&quot; &quot;lz&quot; &quot;extra&quot; &quot;vertr&quot; &quot;gewis&quot; &quot;neuro&quot; &quot;intel&quot; &quot;pro&quot; &quot;grund&quot; &quot;fach&quot; &quot;ziel&quot; &quot;lerntyp&quot; &quot;geschl&quot; &quot;job&quot; &quot;ort&quot; &quot;ort12&quot; &quot;wohnen&quot; &quot;uni1&quot; &quot;uni2&quot; &quot;uni3&quot; &quot;uni4&quot;
## &quot;1&quot; 3 2 4 3 2 1 2 3 4 3 2 2 5.4 3.5 3.5 4 4.25 3.25 1.9 &quot;weil mich die menschliche Psyche sehr interessiert, vor allem die Ursachen fÃ¼r negative Verhaltenweisen, Charaktereigenschaften, Entwicklung&quot; 3 2 1 1 2 1 2 1 1 1 0 0
## &quot;2&quot; 5 3 2 1 3 4 3 5 1 3 1 5 6.8 4 5 3.5 3 3.75 2.1 &quot;Tiefes Interesse&quot; 3 2 3 1 1 2 2 4 1 0 0 0
## &quot;3&quot; 4 4 2 1 1 4 1 4 2 4 1 4 5 3.5 5 3.75 4.5 4.5 2.5 &quot;Interessante Themen&quot; 4 2 1 2 1 1 1 2 1 1 0 0
## &quot;4&quot; 4 2 3 -99 4 2 5 3 4 1 3 2 3.6 2.75 3.75 4.25 4.75 2.25 2.7 &quot;Interesse auf Menschen&quot; 3 3 1 2 2 2 2 1 0 1 0 0</code></pre>
<hr />
<p><em>Bei dieser Seite handelt es sich um eine - mehr oder weniger direkte - Übersetzung eines Kapitels aus dem Online-Buch <a href="https://smobsc.readthedocs.io/en/latest/">Scientific Methods for Open Behavioral, Social and Cognitive Sciences</a>. <a href="https://smobsc.readthedocs.io/en/latest/chapter_ana/Introduction%20to%20Programming%20with%20R.html">Das englischsprachige Original gibt es hier</a>.</em></p>
</div>
