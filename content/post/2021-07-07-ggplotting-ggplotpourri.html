---
title: ggplotpourri
date: '2020-10-17'
slug: ggplotting-ggplotpourri
categories: [""]
tags: ["ggplotting"]
subtitle: ''
summary: ''
authors: [schultze, buchholz]
lastmod: '2021-07-07T18:00:00+01:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
header:
  image: "/header/ggplotting_ggplotpourri.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/34132)"
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>In diesem Beitrag geben wir eine kurze Übersicht über einige gägngie Plotarten mit den Beispielen, die wir schon behandelt haben oder noch behandeln werden. Um die Navigation ein wenig zu vereinfachen, hier eine Tabelle:</p>
<table>
<thead>
<tr class="header">
<th><!-- --></th>
<th><!-- --></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><a href="#balken1">Balkendiagramm I</a></td>
</tr>
<tr class="even">
<td>2</td>
<td><a href="#balken2">Balkendiagramm II</a></td>
</tr>
<tr class="odd">
<td>3</td>
<td><a href="#histogramm">Histogramm</a></td>
</tr>
<tr class="even">
<td>4</td>
<td><a href="#boxplot">Boxplot</a></td>
</tr>
<tr class="odd">
<td>5</td>
<td><a href="#violin">Violin Plot</a></td>
</tr>
<tr class="even">
<td>6</td>
<td><a href="#ridgeline">Ridgelines</a></td>
</tr>
<tr class="odd">
<td>7</td>
<td><a href="#torten">Torten und Donuts</a></td>
</tr>
<tr class="even">
<td>8</td>
<td><a href="#bubble">Bubble Chart</a></td>
</tr>
<tr class="odd">
<td>9</td>
<td><a href="#karten">Karten</a></td>
</tr>
<tr class="even">
<td>10</td>
<td><a href="#wordcloud">Wordcloud</a></td>
</tr>
</tbody>
</table>
<div id="balken1" class="section level2">
<h2>Balkendiagramm</h2>
<p>Die digiGEBF hatte zur Teilnahme an einer Data Challenge aufgerufen. Die Ergebnisse sind <a href="https://www.digigebf21.de/frontend/index.php?page_id=17723">hier einsehbar</a>.</p>
<p>Jeder Beitrag wurde durch die einreichende Person kommentiert und dokumentiert. So lässt sich nachvollziehen, mit welcher Software die Grafiken erzeugt wurden. Dabei zeigt sich folgendes Bild:</p>
<table>
<thead>
<tr class="header">
<th>Software</th>
<th align="center">Anzahl</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R</td>
<td align="center">5</td>
</tr>
<tr class="even">
<td>MS Excel</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td>Python</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td>STATA</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<p>Diese Ergebnisse lassen sich mit einem Balkendiagramm visualiseren.</p>
<p>Da uns hier bereits die Ergebnisse so vorliegen, wie sie abgebildet werden sollen (als Höhe der Balken), verwenden wir die Funktion <code>geom_col()</code>. (Lägen uns Rohdaten vor, deren Häufigkeit zunächst ausgezählt werden muss, um sie als Höhe der Balken darzustellen, würde man <code>geom_bar()</code> verwenden.)</p>
<pre class="r"><code># Pakete laden
library(ggplot2)
library(magick)
library(cowplot)

# Datensatz erstellen
df &lt;- data.frame(software = factor(x = c(&quot;R&quot;, &quot;MS Excel&quot;, &quot;Python&quot;, &quot;Stata&quot;),
                                   levels = c(&quot;R&quot;, &quot;MS Excel&quot;, &quot;Python&quot;, &quot;Stata&quot;)),
                 count = c(5,1,1,1))

# Einfaches Balkendiagramm
ggplot(df, aes(x=software, y=count)) +
  geom_col() </code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Diese Darstellung lässt sich noch optimieren. Statt der Achsenbeschriftung beschriften wir die Balken selbst mit dem Logo der Software!</p>
<pre class="r"><code># Software-Logos herunterladen und einlesen (Funktion aus dem Paket magick)
r &lt;- image_read(&quot;https://www.r-project.org/logo/Rlogo.svg&quot;)
excel &lt;- image_read(&quot;https://upload.wikimedia.org/wikipedia/commons/8/8d/Microsoft_Excel_Logo_%282013-2019%29.svg&quot;)
python &lt;- image_read(&quot;https://upload.wikimedia.org/wikipedia/commons/f/f8/Python_logo_and_wordmark.svg&quot;)
stata &lt;- image_read(&quot;https://upload.wikimedia.org/wikipedia/commons/5/5c/Stata_Logo.svg&quot;)

# ggplot-Befehl zur Erstellung der &quot;nackten&quot; Grafik 
ggplot(df, aes(x=software, y=count)) +
  geom_col() +
  theme_void() +
  labs(x=&quot;&quot;, y=&quot;&quot;) +
  theme(plot.margin = unit(c(3,0,0,0), &quot;cm&quot;),
        axis.text.y = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank()) -&gt; plot

# Positionieren der Bilddateien auf den Balken (Paket cowplot)
ggdraw(plot) +
  draw_image(r, x = .13, y = .86, scale = .2, hjust = .5, vjust = .5) +
  draw_image(excel, x = .38, y = .26, scale = .14, hjust = .5, vjust = .5) +
  draw_image(python, x = .62, y = .26, scale = .2, hjust = .5, vjust = .5) +
  draw_image(stata, x = .86, y = .26, scale = .1, hjust = .5, vjust = .5) +
  scale_fill_manual(values = c(rgb(102,153,204, max=255), &quot;grey&quot;, &quot;grey&quot;, &quot;grey&quot;)) +
  draw_plot(plot)</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="balken2" class="section level2">
<h2>Noch ein Balkendiagramm</h2>
<p>Es soll ein Vergleich angestellt werden, wie hoch die Ausgaben in Deutschland im Jahr 2016 für die unterschiedlichen Bildungsbereiche (Primar, Sekundar, Tertiär) waren. Dafür eignet sich ein Balkendiagramm.</p>
<p>Auch hier liegen uns die Daten so vor, wie sie dargestellt werden sollen (als Höhe der Balken). In diesem Fall kann <code>geom_col()</code> verwendet werden (siehe Beispiel oben). Es kann aber auch <code>geom_bar()</code> in Kombination mit dem Argument <code>stat="idendity"</code> verwendet werden - so weiß ggplot, dass die Daten nicht (wie per Default in <code>geom_bar()</code>) ausgezählt, sondern direkt übernommen werden können.</p>
<pre class="r"><code>edu_exp |&gt;
  subset(edu_exp$Country == &quot;Germany&quot; &amp; edu_exp$Year == 2016) |&gt;
  reshape(direction = &quot;long&quot;,
          varying = c(&quot;Primary&quot;, &quot;Secondary&quot;, &quot;Tertiary&quot;),
          times  = c(&quot;Primary&quot;, &quot;Secondary&quot;, &quot;Tertiary&quot;),
          v.name = &quot;value&quot;,
          timevar = &quot;exp&quot;) |&gt;
  ggplot(aes(x=exp, y=value)) +
  geom_bar(stat = &quot;identity&quot;, fill = rgb(102, 153, 204, max=255)) +
  labs(x = &quot;Educational level&quot;,
       y = &quot;Expenditure&quot;, 
       title =&quot;Expenditures in Education in Germany (2016)&quot;,
       subtitle = &quot;Expenditure per student (% of GDP/Population)&quot;) +
  theme_classic()</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
</div>
<div id="histogramm" class="section level2">
<h2>Histogramm</h2>
<p>Die Verteilung des Einkommens (GDP/Person) soll für das Jahr 2016 dargestellt werden. Es handelt sich um eine kontinuierliche Variable, so bietet sich ein Histogramm an. Für Histogramme kann die Funktion <code>geom_histogram()</code> verwendet werden. Wir kombinieren sie mit dem Theme <code>theme_economist</code> aus dem Paket <code>ggthemes</code>.</p>
<pre class="r"><code>library(ggthemes)</code></pre>
<pre><code>## 
## Attaching package: &#39;ggthemes&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:cowplot&#39;:
## 
##     theme_map</code></pre>
<pre class="r"><code>edu_exp |&gt;
  subset(edu_exp$Year == 2016) |&gt;
  ggplot(aes(x = Income)) +
  geom_histogram() +
  labs(x = &quot;GPD per Person&quot;,
       y = &quot;&quot;, 
       title =&quot;Distribution of income across countries&quot;,
       caption = &quot;Source: gapminder&quot;) +
  theme_economist() +
  theme(plot.margin = unit(c(0.5,1,0.5,0.5), &quot;cm&quot;))</code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
</div>
<div id="boxplot" class="section level2">
<h2>Boxplot</h2>
<p>Erneut soll die Verteilung des Einkommens (GDP/Person) für das Jahr 2016 dargestellt werden - diesmal jedoch separat nach Weltregion. Eine alternative Darstellung für Verteilungen ist das Boxplot. Es lässt sich per <code>geom_boxplot()</code> anfordern. Wir hinterlegen über <code>aes(x=Region)</code>, dass eine Box pro Weltregion erzeugt wird. Sie werden dann nebeneinander dargestellt und ein Vergleich ist leicht möglich.
Die Grafik wird mit dem Theme <code>theme_fivethirtyeight</code> aus dem Paket <code>ggthemes</code> angepasst.</p>
<pre class="r"><code>library(ggthemes)

edu_exp |&gt;
  subset(edu_exp$Year == 2016) |&gt;
  ggplot(aes(x = Region, y = Income)) +
  geom_boxplot() +
  labs(x = &quot;GPD per Person&quot;,
       y = &quot;&quot;, 
       title =&quot;Distribution of income across countries in 2016&quot;,
       caption = &quot;Source: gapminder&quot;) +
  scale_x_discrete(labels = c(&quot;Africa&quot;, &quot;Americas&quot;, &quot;Asia&quot;, &quot;Europe&quot;)) + 
  theme_fivethirtyeight()</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
</div>
<div id="violin" class="section level2">
<h2>Violin Plot</h2>
<p>Für das gleiche Datenbeispiel wie im Boxplot oben (Verteilung des Einkommens (GDP/Person) für das Jahr 2016 separat nach Weltregion)
fordern wir nun ein sog. violin Plot an. Anstelle der Quartile wird die Dichte der Verteilung direkt dargestellt. Auch hier sind die Weltregionen nebeneinander dargestellt (<code>aes(x=Region)</code>), sodass ein Vergleich sehr leicht möglich ist. Das entsprechende Layer wird mit <code>geom_violin</code> angefordert. Zusätzlich werden schmale Boxplots eingezeichnet.</p>
<p>Die Grafik wird ebenfalls mit dem Theme <code>theme_fivethirtyeight</code> aus dem Paket <code>ggthemes</code> angepasst.</p>
<pre class="r"><code>library(ggthemes)

edu_exp |&gt;
  subset(edu_exp$Year == 2016) |&gt;
  ggplot(aes(x = Region, y = Income)) +
  geom_violin(aes(fill = Region), width = 1.5, show.legend = FALSE) +
  # geom_jitter(width = .1, height = 0, col = &quot;grey&quot;) +
  geom_boxplot(width = .1, fill = &quot;transparent&quot;, outlier.shape = NA) +
  labs(x = &quot;GPD per Person&quot;,
       y = &quot;&quot;, 
       title =&quot;Distribution of income across countries in 2016&quot;,
       caption = &quot;Source: gapminder&quot;) +
  scale_x_discrete(labels = c(&quot;Africa&quot;, &quot;Americas&quot;, &quot;Asia&quot;, &quot;Europe&quot;)) + 
  theme_fivethirtyeight()</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
</div>
<div id="ridgeline" class="section level2">
<h2>Ridgeline Plot</h2>
<p>Für das gleiche Datenbeispiel wie im Boxplot und Violin Plot oben (Verteilung des Einkommens (GDP/Person) für das Jahr 2016 separat nach Weltregion) fordern wir nun ein sog. Ridgleline Plot mit <code>geom_density_ridges()</code> aus dem Paket <code>ggridges</code> an. Auch hier wird die Dichte der Verteilung dargestellt. Die Gruppen sind nun übereinander dargestellt (<code>aes(y=Region</code>). Auch dadurch ist ein Vergleich leicht möglich.l</p>
<p>Die Grafik wird mit dem Theme <code>theme_tufte</code> aus dem Paket <code>ggthemes</code> angepasst.</p>
<pre class="r"><code>library(ggthemes)
library(ggridges)

edu_exp |&gt;
  subset(edu_exp$Year == 2016) |&gt;
  ggplot(aes(x = Income, y = Region)) +
  geom_density_ridges(aes(fill = Region), alpha=.8, show.legend = FALSE) +
  scale_y_discrete(labels = c(&quot;Africa&quot;, &quot;Americas&quot;, &quot;Asia&quot;, &quot;Europe&quot;)) + 
  labs(x = &quot;GPD per Person&quot;,
       y = &quot;&quot;, 
       title =&quot;Distribution of income across countries in 2016&quot;,
       caption = &quot;Source: gapminder&quot;) +
  scale_x_discrete(labels = c(&quot;Africa&quot;, &quot;Americas&quot;, &quot;Asia&quot;, &quot;Europe&quot;)) + 
  theme_tufte()</code></pre>
<pre><code>## Picking joint bandwidth of 5090</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="torten" class="section level2">
<h2>Torten und Donuts</h2>
<p>Bevor wir uns damit befassen, <em>wie</em> man in <code>ggplot2</code> ein Torten-Diagramm erstellen kann (und die Donut-förmige Abwandlung davon) wird in <a href="https://www.data-to-viz.com/caveat/pie.html">vielen Ecken des Internets</a> die Frage nach dem <em>ob</em> man ein Torten-Diagramm erstellen sollte mit einem vehementen “nein” beantwortet (es gibt auch <a href="https://hci.stanford.edu/publications/2010/crowd-perception/heer-chi2010.pdf">wissenschaftliche Untersuchungen</a>, die zeigen, dass Daten undeutlicher vermittelt werden). Dennoch werden beide Arten von Plots gerne und häufig genutzt und haben in einigen Fällen ihre Anwendungsgebiete. Im normalen R können wir <code>pie()</code> nutzen, um ein Tortendiagramm anzulegen, in <code>ggplot2</code> ist das allerdings ein wenig umständlicher.</p>
<p>Generell werden Tortendiagramme nur dann empfohlen, wenn man Anteile von einem Gesamten darstellen möchte. Leider haben wir keine dafür direkt geeignete Variable in <a href="/post/ggplotting-daten">unserem Datensatz</a>, aber wir können uns etwas erstellen. Wir betrachten im Folgenden die Ausgaben für die drei unterschiedlichen Bildungsbreiche und wie diese in unterschiedlichen Ländern aussehen. Dafür erstellen wir zunächst Proportionen:</p>
<pre class="r"><code>edu_exp$Total &lt;- subset(edu_exp, select = c(&#39;Primary&#39;, &#39;Secondary&#39;, &#39;Tertiary&#39;)) |&gt;
  rowSums()
tmp &lt;- edu_exp[, c(&#39;Primary&#39;, &#39;Secondary&#39;, &#39;Tertiary&#39;)] / edu_exp$Total
names(tmp) &lt;- c(&#39;PrimaryProp&#39;, &#39;SecondaryProp&#39;, &#39;TertiaryProp&#39;)
edu_exp &lt;- cbind(edu_exp, tmp)</code></pre>
<p>Wie immer, nehmen wir 2013 und beschränken uns auf die Länder, die in diesem Jahr für alle drei Ausgaben Daten vorhanden haben. Wie wir schon <a href="/post/ggplotting-intro">im ersten Beitrag gesehen haben</a>, müssen wir die Daten mehrerer Variablen für die ordentliche Darstellung ins lange Format übertragen.</p>
<pre class="r"><code>prop_long &lt;- subset(edu_exp, Year == 2013 &amp; !is.na(Total), 
  select = c(&#39;Country&#39;, &#39;Year&#39;,  
    &#39;PrimaryProp&#39;, &#39;SecondaryProp&#39;, &#39;TertiaryProp&#39;)) |&gt;
  reshape(direction = &#39;long&#39;,
    varying = c(&#39;PrimaryProp&#39;, &#39;SecondaryProp&#39;, &#39;TertiaryProp&#39;),
    v.names = &#39;Proportion&#39;,
    timevar = &#39;Type&#39;,
    times = c(&#39;Primary&#39;, &#39;Secondary&#39;, &#39;Tertiary&#39;))</code></pre>
<p><code>geom_rect()</code> ist der Umweg über den wir uns in <code>ggplot2</code> an das Kreisdiagramm heranpirschen müssen. Dafür benötigen wir klare Enden unserer Rechtecke, also bei welchen y-Werten die Balken anfangen und aufhören sollen. Weil die Balken ja bündig einen Kreis ergeben sollen, brauchen wir erstmal auch einen bündigen Balken, das heißt jede Kategorie muss das aufhören, wo die nächste beginnt. Damit wir das nicht gleichzeitig und unübersichtlich für alle Länder gleicheztig machen, beschränken wir uns wieder auf Spanien:</p>
<pre class="r"><code>spain &lt;- subset(prop_long, Country == &#39;Spain&#39;)
spain$Max &lt;- cumsum(spain$Proportion)
spain$Min &lt;- c(0, head(spain$Max, n = -1))

spain</code></pre>
<pre><code>##              Country Year      Type Proportion id       Max       Min
## 26.Primary     Spain 2013   Primary  0.2966316 26 0.2966316 0.0000000
## 26.Secondary   Spain 2013 Secondary  0.3113845 26 0.6080161 0.2966316
## 26.Tertiary    Spain 2013  Tertiary  0.3919839 26 1.0000000 0.6080161</code></pre>
<p>Mit <code>geom_rect()</code> können wir jetzt einen Balken erstellen, der genau bündig von einem Bildungstyp in den nächsten übergeht:</p>
<pre class="r"><code>bar &lt;- ggplot(spain, 
  aes(ymin = Min, ymax = Max, 
    xmin = 2, xmax = 3,
    fill = Type)) +
  geom_rect(color = &#39;white&#39;) +
  theme_void() + scale_fill_pandar()
bar</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/stacked-bar-1.png" width="672" /></p>
<p>Wir nutzen statt des <code>theme_pandar()</code> hier <code>theme_void()</code>, um den Plot von Achsen und anderen Kennzeichnungen zu befreien. <code>color = 'white'</code> setze ich hier, um eine sauber aussehende Grenze zwischen den Abschnitten herzustellen.</p>
<p>Jetzt müssen wir aus diesem Türmchen nur noch einen Kreis formen. Dafür transformieren wir die Koordinaten ins polare System, sodass (0, 0) in der Mitte liegt und sich die Datenpunkte von dort entfernen:</p>
<pre class="r"><code>pie &lt;- bar + coord_polar(&quot;y&quot;)
pie</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/simple-pie-1.png" width="672" /></p>
<p>Jetzt können wir über <code>geom_text</code> noch die Prozente in die Abschnitte eintragen. Dabei müssen wir nur ordentliche Positionen für die Labels bestimmen. Ich setze diese einfach mal in die Mitte. Danach erzeugen wir noch die Prozentzahlen und <code>paste</code>n sie mit dem Prozentzeichen zusammen. Das sollte für unsere Label genügen.</p>
<pre class="r"><code>spain$Position &lt;- (spain$Max + spain$Min) / 2
spain$Percent &lt;- paste0(round(spain$Proportion * 100, 1), &#39;%&#39;)</code></pre>
<p>Weil wir Änderungen an den Daten vorgenommen haben, müssen wir den neuen Datensatz direkt über das <code>data</code>-Argument ansprechen (sonst wüsste <code>geom_text()</code> nichts von den neuen Variablen)</p>
<pre class="r"><code>pie &lt;- pie +
  geom_text(data = spain, x = 2.5,
    aes(y = Position, label = Percent), 
      color = &#39;white&#39;, size = 5) +
  labs(fill = &#39;Education Type&#39;) + 
  ggtitle(&#39;Proportional Education Spending&#39;, &#39;Spain, 2013&#39;)
pie</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/fancy-pie-1.png" width="672" /></p>
<p>Um aus diesem Kuchen jetzt einen Donut zu machen, müssen wir nur das mittlere Stück herausnehmen, indem wir die x-Achse in eine Region erweitern, in die unser <code>geom_rect()</code> nicht reicht.</p>
<pre class="r"><code>pie + xlim(c(1, 3))</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/donut-1.png" width="672" /></p>
</div>
<div id="bubble" class="section level2">
<h2>Bubble Chart</h2>
<p>In Übung 1 sollten Sie <a href="https://www.gapminder.org/tools/#$model$markers$bubble$encoding$frame$value=2015;;;;;&amp;chart-type=bubbles&amp;url=v1">diese</a> auf <a href="https://www.gapminder.org">gapminder.org</a> erzeugte Grafik nachbasteln:</p>
<p><img src="/post/ggplotting-gapminder-original.png" /></p>
<p>Die Variablen liegen alle im <code>edu_exp</code>-Datensatz vor. Allerdings sieht die ggplot-Grafik ohne Anpassungen wie folgt aus:</p>
<pre class="r"><code>edu_exp |&gt;
  subset(Year == 2011) |&gt; 
  ggplot(aes(x=Income, y=Expectancy)) +
  geom_point() </code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>Zunächst wird der Datensatz noch so sortiert, dass kleine Länder “hinten” stehen und “zuletzt” ins Plot kommen, also vorne (unverdeckt) zu sehen sind. Außerdem hinterlege ich schon mal die vier Farben als rgb-Vektor, nachdem ich sie mit gimp “gemessen” hatte.</p>
<pre class="r"><code># Datensatz sortieren
edu_exp &lt;- edu_exp[order(edu_exp$Population, decreasing = T),]

# Farben der vier Weltregionen 
tuerkis &lt;- rgb(0,213,233, max=255)
gruen &lt;- rgb(127,235,0, max=255)
rot &lt;- rgb(255,88,114, max=255)
gelb &lt;- rgb(255,231,0, max=255)</code></pre>
<p>Im nachfolgenden Code sind alle Schritte kommentiert:</p>
<pre class="r"><code>edu_exp |&gt;
  # Auswahl der Daten von 2015:
  subset(Year == 2015) |&gt; 
  # Grund-Grafik anfordern:
  ggplot(aes(x=Income, y=Expectancy)) +
  # Neu: Text für die Jahreszahl (&quot;2015&quot;) einfügen, sodass diese ganz im Hintergrund steht
  annotate(&quot;text&quot;, x=8000, y=50, label=&quot;2015&quot;, size=50, colour =&quot;grey90&quot;, family=&quot;courier new&quot;, fontface=2) +
  # Neu: Farbthema: heller Hintergrund, schwarze Linien an x- und y-Achse
  theme_classic() + 
  # Wie bisher: Punkte einzeichnen --&gt; Streu-Punkt-Diagramm,
  # Neu: Unterscheidung der Punkte nach Farbe (Region) und Größe (Population);  
  # Transparenz der Datenpunkte (alpha), Rand um die Punkte (shape) 
  geom_point(aes(fill = Region, size = Population), shape=21, alpha=.7, show.legend=F) +
  # Skalieren der Größe der Punkte, sodass die Unterschiede deutlicher sind
  scale_size(range = c(1, 30)) +
  # Neu: Beschriftung der Achsen
  labs(x=&quot;Income&quot;, y=&quot;Life expectancy&quot;) +
  # Neu: Beschriftung an den Innenseiten der Achsen
  annotate(&quot;text&quot;, x=125000, y=11, label=&quot;per Person (GDP/capita, PPP$ inflation-adjusted)&quot;, hjust = 1, vjust = 1) +
  annotate(&quot;text&quot;, x=410, y=90, label=&quot;years&quot;, hjust = 1, vjust = -2, angle=90) +
  # Neu: manuelle Spezifikation der y-Achse: Wertebereich, Position der Beschriftungen (10er-Schritte)
  scale_y_continuous(limits = c(10, 92), 
                     breaks = seq(10,92, by=10)) +
  # Neu: manuelle Spezifikation der x-Achse: Wertebereich, log-Transformation, Position und Name der Beschriftungen
  scale_x_continuous(limits = c(400,128000),
                     trans = &quot;log2&quot;, 
                     breaks = c(500, 1000, 2000, 4000, 8000, 16000, 32000, 64000, 128000),
                     labels = c(&quot;500&quot;, &quot;1000&quot;, &quot;2000&quot;, &quot;4000&quot;, &quot;8000&quot;, &quot;16k&quot;, &quot;32k&quot;, &quot;64k&quot;, &quot;128k&quot;)) +
  # Neu: manuelle Spezifikation der Farben
  scale_fill_manual(
    values = c(tuerkis, gruen, rot, gelb),
    breaks = c(&quot;africa&quot;, &quot;americas&quot;, &quot;asia&quot;, &quot;europe&quot;)) +
  # Neu: Theme (Anpassung der Schriftgroesse, relativ zur Groesse 12, blaues Raster im Hintergrund, Rand für die Legende)
  theme(text = element_text(size=12),
        axis.text = element_text(size=rel(.8)),
        axis.title = element_text(size=rel(1.2)),
        panel.grid.major = element_line(colour = &quot;azure2&quot;),
        plot.margin = margin(1, 6, 1, 1, &quot;cm&quot;)) -&gt; plot_ohne_Legende</code></pre>
<p>Die Grafik ohne Legende sieht nun so aus:</p>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-16-1.png" width="960" /></p>
<p>Um die Legende für die Farben (Weltregionen) anzufügen, habe ich einen Screenshot der Weltkarte von der gapminder-Webseite gemacht und als Bilddatei gespeichert (“5_gapminder-map.png”). Diese lese ich nun mit der <code>image_read()</code>-Funktion aus dem Paket <code>magick</code> ein. Anschließend füge ich sie “oben rechts” (x = 1, y = .95) in das zuvor erzeugte ggplot ein. Dafür verwende ich wieder die Funktion <code>draw_image()</code> aus dem Paket <code>cowplot</code>.</p>
<pre class="r"><code>library(magick)
library(cowplot)

# Weltkarte (Screenshot von der gapminder Webseite)
weltkarte &lt;- image_read(&quot;ggplotting-gapminder-map.png&quot;)

ggdraw(plot_ohne_Legende) +
  draw_image(weltkarte, x = 1, y = .95, hjust = 1, vjust = 1, halign = 1, valign = 1, width = .2)</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-17-1.png" width="960" /></p>
<p>Und schließlich können wir die Grafik auch noch animieren, sodass sie dem Vorbild auf (www.gapminder.org) sogar noch ähnlicher wird. Leider scheinen sich <code>cowplot</code> und <code>gganimate</code> nicht so gut zu vertragen - daher muss ich die Farblegende rechts weglassen. Ansonsten kann ich den Code der statischen Grafik oben weitgehend übernehmen; lediglich die folgenden Dinge musste ich entfernen:</p>
<ul>
<li>Fallauswahl für das Jahr 2015 <code>subset()</code>)<br />
</li>
<li>Textbox mit “2015” im Hintergrund der Grafik (<code>annotate()</code>)<br />
</li>
<li>der große Rand rechts (<code>plot.margin</code>), weil es ja nun keine Legende gibt</li>
</ul>
<pre class="r"><code>edu_exp |&gt;
  ggplot(aes(x=Income, y=Expectancy)) +
  theme_classic() + 
  geom_point(aes(fill = Region, size = Population), shape=21, alpha=.7, show.legend=F) +
  scale_size(range = c(1, 30)) +
  labs(x=&quot;Income&quot;, y=&quot;Life expectancy&quot;) +
  annotate(&quot;text&quot;, x=125000, y=11, label=&quot;per Person (GDP/capita, PPP$ inflation-adjusted)&quot;, hjust = 1, vjust = 1) +
  annotate(&quot;text&quot;, x=410, y=90, label=&quot;years&quot;, hjust = 1, vjust = -2, angle=90) +
  scale_y_continuous(limits = c(10, 92), 
                     breaks = seq(10,92, by=10)) +
  scale_x_continuous(limits = c(400,128000),
                     trans = &quot;log2&quot;, 
                     breaks = c(500, 1000, 2000, 4000, 8000, 16000, 32000, 64000, 128000),
                     labels = c(&quot;500&quot;, &quot;1000&quot;, &quot;2000&quot;, &quot;4000&quot;, &quot;8000&quot;, &quot;16k&quot;, &quot;32k&quot;, &quot;64k&quot;, &quot;128k&quot;)) +
  scale_fill_manual(
    values = c(tuerkis, gruen, rot, gelb),
    breaks = c(&quot;africa&quot;, &quot;americas&quot;, &quot;asia&quot;, &quot;europe&quot;)) +
  theme(text = element_text(size=12),
        axis.text = element_text(size=rel(.8)),
        axis.title = element_text(size=rel(1.2)),
        panel.grid.major = element_line(colour = &quot;azure2&quot;)) -&gt; plot_ohne_Legende</code></pre>
<pre class="r"><code>library(gganimate)

anim &lt;- plot_ohne_Legende +
  transition_time(Year) +
  labs(title = &quot;{frame_time}&quot;) +
  theme(plot.title = element_text(hjust=.5))

animate(anim, start_pause = 20, end_pause = 20,
        height = 15, width = 30, units = &quot;cm&quot;, res = 150)</code></pre>
<p><img src="/post/ggplotting-Bubble-Chart.gif" /></p>
</div>
<div id="karten" class="section level2">
<h2>Karten</h2>
<p>Bei psychologischen Daten eher selten, aber mit dem <a href="/post/ggplotting-daten">Gapminder Datensatz</a> natürlich sehr naheliegend, ist die Datenvisualisierung auf Karten. Für komplexere Karten (z.B. mit Google Maps) gibt es das <code>ggmap</code> Paket. Für unsere Zwecke reichen allerdings die von <code>ggplot2</code> mitgelieferten Karten aus.</p>
<p>Karten benötigen eine sehr eigene Art der Datenaufbereitung, die häufig nicht gerade platzsparend ist. Daher sind die meisten Karten in R nicht als Datensätze vorhanden, sondern müssen erst einmal in solche überführt werden. Dafür gibt es die <code>map_data</code> Funktion. Um die Weltkarte in einen Datensatz zu übertragen, z.B.:</p>
<pre class="r"><code>welt &lt;- map_data(&#39;world&#39;)
head(welt)</code></pre>
<pre><code>##        long      lat group order region subregion
## 1 -69.89912 12.45200     1     1  Aruba      &lt;NA&gt;
## 2 -69.89571 12.42300     1     2  Aruba      &lt;NA&gt;
## 3 -69.94219 12.43853     1     3  Aruba      &lt;NA&gt;
## 4 -70.00415 12.50049     1     4  Aruba      &lt;NA&gt;
## 5 -70.06612 12.54697     1     5  Aruba      &lt;NA&gt;
## 6 -70.05088 12.59707     1     6  Aruba      &lt;NA&gt;</code></pre>
<p>Was man in den Daten sieht sind Länge- und Breitengrade von Landesgrenzen. Außerdem bestimmt die Variable <code>group</code> das Land (anhand dessen die Landesgrenzen gruppiert werden sollten). Damit Linie der Grenzen nicht hin und her springt gibt es außerdem die Variable <code>order</code> die angibt, welcher Punkt in der Grenze als nächstes kommt. Anhand dieser Punkte werden in <code>ggplot2</code> mit der allgemeinen <code>geom_polygon</code> Funktion Karten gezeichnet. Um eine leere Weltkarte zu erzeugen reicht Folgendes aus:</p>
<pre class="r"><code>ggplot(welt, aes(x = long, y = lat, group = group)) +
  geom_polygon()</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Wie man sieht, hat dieser Plot die gleichen Eigenschaften wie normale <code>ggplot</code>s - weil es ein ganz normaler Plot ist. Um einzelne Länder erkennen zu können, sollten wir z.B. die Länder weiß und nicht schwarz füllen. Außerdem brauchen wir nicht unbedingt x- und y-Achse, sodass wir das komplett leere Theme <code>theme_void</code> nutzen können:</p>
<pre class="r"><code>ggplot(welt, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = &#39;white&#39;, color = &#39;black&#39;, lwd = .25) +
  theme_void()</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>Um die Karten-Daten mit den Daten in Verbindung zu bringen steht uns leider - wie so häufig - im Weg, dass die Daten nicht einheitlich kodiert wurden. In diesem Fall sind es die Benennungen der Länder, die uneinheitlich sind. Um herauszufinden, wo Unterschiede bestehen, können wir die normalen Operatoren der Mengenvergleiche in R nutzen:</p>
<pre class="r"><code>setdiff(unique(welt$region), unique(edu_exp$Country))</code></pre>
<pre><code>##  [1] &quot;Aruba&quot;                               &quot;Anguilla&quot;                           
##  [3] &quot;American Samoa&quot;                      &quot;Antarctica&quot;                         
##  [5] &quot;French Southern and Antarctic Lands&quot; &quot;Antigua&quot;                            
##  [7] &quot;Barbuda&quot;                             &quot;Saint Barthelemy&quot;                   
##  [9] &quot;Bermuda&quot;                             &quot;Ivory Coast&quot;                        
## [11] &quot;Democratic Republic of the Congo&quot;    &quot;Republic of Congo&quot;                  
## [13] &quot;Cook Islands&quot;                        &quot;Curacao&quot;                            
## [15] &quot;Cayman Islands&quot;                      &quot;Canary Islands&quot;                     
## [17] &quot;Falkland Islands&quot;                    &quot;Reunion&quot;                            
## [19] &quot;Mayotte&quot;                             &quot;French Guiana&quot;                      
## [21] &quot;Martinique&quot;                          &quot;Guadeloupe&quot;                         
## [23] &quot;Faroe Islands&quot;                       &quot;Micronesia&quot;                         
## [25] &quot;UK&quot;                                  &quot;Guernsey&quot;                           
## [27] &quot;Greenland&quot;                           &quot;Guam&quot;                               
## [29] &quot;Heard Island&quot;                        &quot;Isle of Man&quot;                        
## [31] &quot;Cocos Islands&quot;                       &quot;Christmas Island&quot;                   
## [33] &quot;Chagos Archipelago&quot;                  &quot;Jersey&quot;                             
## [35] &quot;Siachen Glacier&quot;                     &quot;Kyrgyzstan&quot;                         
## [37] &quot;Nevis&quot;                               &quot;Saint Kitts&quot;                        
## [39] &quot;Kosovo&quot;                              &quot;Laos&quot;                               
## [41] &quot;Saint Lucia&quot;                         &quot;Saint Martin&quot;                       
## [43] &quot;Macedonia&quot;                           &quot;Northern Mariana Islands&quot;           
## [45] &quot;Montserrat&quot;                          &quot;New Caledonia&quot;                      
## [47] &quot;Norfolk Island&quot;                      &quot;Niue&quot;                               
## [49] &quot;Bonaire&quot;                             &quot;Sint Eustatius&quot;                     
## [51] &quot;Saba&quot;                                &quot;Pitcairn Islands&quot;                   
## [53] &quot;Puerto Rico&quot;                         &quot;Madeira Islands&quot;                    
## [55] &quot;Azores&quot;                              &quot;French Polynesia&quot;                   
## [57] &quot;Western Sahara&quot;                      &quot;South Sandwich Islands&quot;             
## [59] &quot;South Georgia&quot;                       &quot;Saint Helena&quot;                       
## [61] &quot;Ascension Island&quot;                    &quot;Saint Pierre and Miquelon&quot;          
## [63] &quot;Slovakia&quot;                            &quot;Swaziland&quot;                          
## [65] &quot;Sint Maarten&quot;                        &quot;Turks and Caicos Islands&quot;           
## [67] &quot;Trinidad&quot;                            &quot;Tobago&quot;                             
## [69] &quot;USA&quot;                                 &quot;Vatican&quot;                            
## [71] &quot;Grenadines&quot;                          &quot;Saint Vincent&quot;                      
## [73] &quot;Virgin Islands&quot;                      &quot;Wallis and Futuna&quot;</code></pre>
<pre class="r"><code>setdiff(unique(edu_exp$Country), unique(welt$region))</code></pre>
<pre><code>##  [1] &quot;United States&quot;                  &quot;Congo, Dem. Rep.&quot;              
##  [3] &quot;United Kingdom&quot;                 &quot;Cote d&#39;Ivoire&quot;                 
##  [5] &quot;Hong Kong, China&quot;               &quot;Lao&quot;                           
##  [7] &quot;Kyrgyz Republic&quot;                &quot;Slovak Republic&quot;               
##  [9] &quot;Congo, Rep.&quot;                    &quot;North Macedonia&quot;               
## [11] &quot;Trinidad and Tobago&quot;            &quot;Eswatini&quot;                      
## [13] &quot;St. Lucia&quot;                      &quot;Micronesia, Fed. Sts.&quot;         
## [15] &quot;St. Vincent and the Grenadines&quot; &quot;Antigua and Barbuda&quot;           
## [17] &quot;St. Kitts and Nevis&quot;            &quot;Tuvalu&quot;                        
## [19] &quot;Holy See&quot;</code></pre>
<p>Im Folgenden werden die Namen der Länder mit dem <code>recode</code> Befehl des <code>car</code>-Pakets umkodiert. Leider gibt es schon vorab ein Land, nach dem man in Datenaufbereitungen immer vorab schauen sollte: wie auch hier ist es häufiger der Fall, dass die Elfenbeiküste als <code>Cote d'Ivoire</code> kodiert ist. Leider bewirkt das <code>'</code> in diesem Namen bei Umkodierungen immer einiges an Problemen, sodass wir es vorab direkt umstellen:</p>
<pre class="r"><code>edu_exp[grepl(&#39;Cote&#39;, edu_exp$Country), &#39;Country&#39;] &lt;- &#39;Ivory Coast&#39;</code></pre>
<p>die verbleindenden Ländern können dann umkodiert werden:</p>
<pre class="r"><code># Recodes
edu_exp$Country &lt;- car::recode(edu_exp$Country,
  &quot;&#39;Antigua and Barbuda&#39; = &#39;Antigua&#39;;
  &#39;Congo, Rep.&#39; = &#39;Republic of Congo&#39;;
  &#39;Congo, Dem. Rep.&#39; = &#39;Democratic Republic of the Congo&#39;;
  &#39;Micronesia, Fed. Sts.&#39; = &#39;Micronesia&#39;;
  &#39;United Kingdom&#39; = &#39;UK&#39;;
  &#39;Holy See&#39; = &#39;Vatican&#39;;
  &#39;Kyrgyz Republic&#39; = &#39;Kyrgyzstan&#39;; 
  &#39;St. Kitts and Nevis&#39; = &#39;Saint Kitts&#39;;
  &#39;Lao&#39; = &#39;Laos&#39;;
  &#39;St. Lucia&#39; = &#39;Saint Lucia&#39;;
  &#39;North Macedonia&#39; = &#39;Macedonia&#39;;
  &#39;Slovak Republic&#39; = &#39;Slovakia&#39;;
  &#39;Eswatini&#39; = &#39;Swaziland&#39;;
  &#39;Trinidad and Tobago&#39; = &#39;Trinidad&#39;;
  &#39;United States&#39; = &#39;USA&#39;;
  &#39;Saint Vincent and the Grenadines&#39; = &#39;Saint Vincent&#39;&quot;)</code></pre>
<p>Diese Umkodierung ist nicht auf andere Datensätze übertragbar - wir müssen immer in den Daten die vorliegen nachgucken, welche Schritte zum Angleichen verschiedener Datensätze notwendig sind.</p>
<p>Wir können den Datensatz auf das letzte Jahr beschränken, das wir vorliegen haben (2017):</p>
<pre class="r"><code>edu_2017 &lt;- subset(edu_exp, Year == 2017)</code></pre>
<p>Anschließend können wir den Datensatz mit der Weltkarte zusammenführen. Dafür verwenden wir wieder den <code>merge</code> Befehl. Damit nach dem <code>merge</code> die Grenzen richtig gezeichnet werden, müssen wieder die Reihenfolge der Daten wiederherstellen. Dazu wird mit <code>order</code> nach Land (<code>group</code>) und dann nach Reihenfolge der Grenzpunkte (<code>order</code>) sortiert.</p>
<pre class="r"><code>edu_map &lt;- merge(welt, edu_2017, 
  by.x = &#39;region&#39;, by.y = &#39;Country&#39;, 
  all.x = TRUE, all.y = FALSE)
edu_map &lt;- edu_map[order(edu_map$group, edu_map$order), ]</code></pre>
<p>Mit den neuen Daten können wir unsere vorherige Karte jetzt so ergänzen, dass wir die Länder nach der Anzahl der Fälle einfärben:</p>
<pre class="r"><code>ggplot(edu_map, aes(x = long, y = lat, group = group)) +
  geom_polygon(color = &#39;black&#39;, lwd = .25, 
    aes(fill = Index)) +
  theme_void() + 
  scale_fill_pandar(discrete = FALSE, na.value = &#39;grey95&#39;)</code></pre>
<p><img src="/post/2021-07-07-ggplotting-ggplotpourri_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
</div>
<div id="wordcloud" class="section level2">
<h2>Wordcloud</h2>
<p>Nicht nur Zahlen, sondern auch Texte können visualisiert werden! Glauben Sie nicht? Naja stimmt, am Ende werden in Wordclouds ja auch wieder Zahlen dargestellt - nämlich die Häufigkeiten, mit der die Wörter im Textkorpus aufgetreten sind. Um so eine Wordcloud anzufordern, muss zunächst (a) der Text eingelesen werden, (b) eine sortierte Häufigkeitstabelle erstellt, und (3) die Wordcloud spezifiziert werden.</p>
<p>Zur Illustration lese ich zunächst die Texte aller <a href="https://pandar.netlify.app/extras/#ggplotting">pandaR</a> Seiten aus, in denen wir die Inhalte schriftlich ausgearbeitet hatten.</p>
<p>Zum Auslesen der Texte verwende ich Funktionen aus <code>rvest</code>, mit dem sich prima Webscraping betreiben lässt. Außerdem habe ich herausgefunden, dass der relevante CSS-Selektor “p” heißt, in dem die Fließtexte stehen.</p>
<pre class="r"><code>library(rvest)

# Funktion zum Einlesen der Texte von Websites
make.text &lt;- function(website){
  read_html(website) |&gt; 
    html_nodes(&quot;p&quot;) |&gt;
    html_text() |&gt;
    paste(collapse = &quot;&quot;)
}

# Anwenden der Funktion auf die relevanten pandaR-Seiten:
texte &lt;- paste(
  make.text(&#39;https://pandar.netlify.app/post/ggplotting-intro&#39;), 
  make.text(&#39;https://pandar.netlify.app/post/ggplotting-daten&#39;),
  make.text(&#39;https://pandar.netlify.app/post/ggplotting-themes/&#39;),
  make.text(&#39;https://pandar.netlify.app/post/ggplotting-ggplotpourri/&#39;),
  make.text(&#39;https://pandar.netlify.app/post/ggplotting-gganimate/&#39;),
  make.text(&#39;https://pandar.netlify.app/post/ggplotting-plotly/&#39;),
  make.text(&#39;https://pandar.netlify.app/post/ggplotting-exploration/&#39;), 
  collapse = &quot;&quot;)</code></pre>
<p>Nun liegt ein sehr langer Fließtext vor, der sich aus den Texten der einzelnen Seiten zusammensetzt. Als nächstes muss dieser Text bereinigt werden, d.h., alle Großbuchstaben ersetzen, Sonderzeichen, Zahlen und stopwords entfernen, Satzzeichen entfernen, … Dafür bietet sich das Paket <code>tm</code> an.</p>
<pre class="r"><code>library(tm)</code></pre>
<pre><code>## Loading required package: NLP</code></pre>
<pre><code>## 
## Attaching package: &#39;NLP&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:ggplot2&#39;:
## 
##     annotate</code></pre>
<pre class="r"><code># Erstellen der Wort-Häufigkeitstabelle 
docs &lt;- Corpus(VectorSource(texte))
toSpace &lt;- content_transformer(function (x , pattern ) gsub(pattern, &quot; &quot;, x))
docs &lt;- tm_map(docs, toSpace, &#39;[/@\\|\\&quot;]&#39;)
docs &lt;- tm_map(docs, content_transformer(tolower))
docs &lt;- tm_map(docs, removeNumbers)
docs &lt;- tm_map(docs, removeWords, stopwords(&quot;german&quot;))
docs &lt;- tm_map(docs, removeWords, c(&quot;dass&quot;))
docs &lt;- tm_map(docs, removePunctuation)
docs &lt;- tm_map(docs, stripWhitespace)
tdm  &lt;- as.matrix(TermDocumentMatrix(docs))
vec &lt;- sort(rowSums(tdm), decreasing=TRUE)
table &lt;- data.frame(word = names(vec), freq = vec)</code></pre>
<p>Die ersten Zeilen der resultierenden Häufigkeitstabelle sehen nun so aus:</p>
<pre class="r"><code>head(table)</code></pre>
<pre><code>##                word freq
## daten         daten   76
## ggplot       ggplot   72
## variablen variablen   44
## datensatz datensatz   42
## abbildung abbildung   40
## funktion   funktion   39</code></pre>
<p>Diese Tabelle bildet nun die Grundlage für die Wordcloud. Zur Erstellung der Wordcloud nutze ich das Paket <code>ggwordcloud</code>. Es enthält eine Funktion für die entsprechende Geometrie, und es lassen sich alle sonstigen ggplot-Funktionen damit kombinieren. So kann ich beispielsweise über <code>theme</code> die Hintergrundfarbe spezifizieren.</p>
<pre class="r"><code># Erstellen der wordcloud
library(ggwordcloud)

table$angle &lt;- 90 * sample(c(0, 1), nrow(table), replace = TRUE, prob = c(60, 40))
ggplot(table[1:200,],) +
  geom_text_wordcloud(aes(label = word, size = freq,
                          color = factor(sample.int(10, 200, replace = TRUE)),
                          angle = angle)) +
  scale_size(range = c(1, 20)) +
  theme(panel.background = element_rect(fill = &quot;grey90&quot;))</code></pre>
<p><img src="/post/ggplotting-wordcloud.png" /></p>
</div>
