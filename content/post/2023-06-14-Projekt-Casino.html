---
title: Casino   
date: '2019-12-14T23:00:00'
slug: projekt_casino
categories:
  - Projekt 2
tags: []
subtitle: ''
summary: ''
authors: [mehler, rouchi]
lastmod: '2023-06-14'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
header:
  image: "/header/casino_post.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/1071839)"
---



<p>Dieses Projekt befasst sich mit dem Thema Glücksspiel. Es existieren zahlreiche Glücksspiele, beispielsweise Glücksspielautomaten (z.B. der “Einarmige Bandit”), Roulette, Kartenspiele (z.B. Blackjack und Poker), Würfelspiele, Sportwetten, Lotto, Rubbellose und Bingo sowie im weiteren Sinne auch die Börsenspekulation. In diesem Projekt möchten wir uns auf das Roulette konzentrieren. Roulette ist ein weltweit verbreitetes, traditionelles Glücksspiel, bei dem es darum geht, auf bestimmte Zahlen oder Eigenschaften von Zahlen zu setzen, die durch den zufälligen Lauf einer Kugel in einem Kessel bestimmt werden. (<a href="https://de.wikipedia.org/wiki/Roulette">Klicke hier für weitere Informationen</a>.) Ziel ist in diesem Projekt, dass du dir am Ende den Weg ins Casino sparen kannst, weil du dir in <code>R</code> ein Roulette nachgebaut hast!</p>
<div id="zielsetzung" class="section level2">
<h2>Zielsetzung</h2>
<p>In diesem Projekt soll es um den Umgang mit Funktionen in <code>R</code>, den Umgang mit Wenn-Dann-Bedingungen (<code>if</code> und <code>else</code>) und um das Erzeugen von Schleifen mit <code>for</code>, <code>while</code> oder <code>repeat</code> gehen. In diesem Projekt soll mithilfe dieser Funktionen ein Roulette-Spiel rekonstruiert und mithilfe dessen verschieden Situationen nachgestellt werden. Hierdurch sollst du dich mit dem Gebrauch dieser Funktionen vertraut machen und verschiedene, kombinierte Verwendungsmöglichkeiten kennenlernen.</p>
</div>
<div id="vorbereitung" class="section level2">
<h2>Vorbereitung</h2>
<p>Für die Bearbeitung dieses Projektes solltest du dich zunächst mit Funktionen in <code>R</code> beschäftigen. Dazu kannst du dich entweder selbst im Internet informieren oder du nutzt diesen <a href="https://r-coding.de/blog/if-else/">R-Blog</a> zu <code>if</code> und <code>else</code> - Bedingungen in <code>R</code>. In der statistischen Lehre an der Goethe Universität werden diese Arten von Funktionen in dem Tutorial <a href="/post/loops-und-funktionen">Loops und Funktionen</a> für PsyBSc7 näher behandelt.</p>
<p>Desweiteren solltest du dich ein wenig mit dem Spiel Roulette auseinandersetzen. Auf <a href="https://www.spielbank.com.de/online-casinos/roulette/regeln/">SpielBank.com.de</a> kannst du dir die Regeln und den Ablauf des französischen Roulettes durchlesen, um mögliche Wetten und die dazugehörigen Wettquoten kennenzulernen. Kurz zusammengefasst wird eine Roulettekugel in den Roulettekessel geworfen, welcher mit 37 Fächern (für die Zahlen 0-36) in abwechselnd roter und schwarzer Farbe - oder grün im Falle der 0 - bestückt ist. <strong>Ziel des Spieles ist es, die Zahl oder die Farbe vorherzusagen, auf welcher die Kugel in der folgenden Spielrunde liegenbleiben wird.</strong></p>
<p>In der folgenden Tabelle sind die möglichen Einsatzvarianten samt ihrer dazugehörigen Gewinnquoten abgebildet. Je höher die Gewinnquote - also je statistisch unwahrscheinlicher - , desto größer die Auszahlung!
(Anmerkung: Bei der Berechnung der Gewinnquote wird die 0 nicht berücksichtigt.)</p>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>Einsatzvariante</th>
<th>Ereignis</th>
<th>Gewinnquote</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Die Einfache Chance</td>
<td>“Rot” oder “Schwarz”, “Ungerade” oder “Gerade”, “Niedrig” oder “Hoch”</td>
<td>1:1</td>
</tr>
<tr class="even">
<td>Douzaines (Dutzend)</td>
<td>12 aufeinanderfolgende Zahlen (1-12 / 13-24 / 25-36)</td>
<td>2:1</td>
</tr>
<tr class="odd">
<td>Colonnes (Kolonne)</td>
<td>Kolonne 34, Kolonne 35, Kolonne 36</td>
<td>2:1</td>
</tr>
<tr class="even">
<td>Transversale Simple (Große Straße)</td>
<td>6 Zahlen in zwei Querreihen untereinander</td>
<td>5:1</td>
</tr>
<tr class="odd">
<td>Transversale Pleine (Straße)</td>
<td>3 Zahlen in einer Querreihe</td>
<td>11:1</td>
</tr>
<tr class="even">
<td>Les Trois Premiers</td>
<td>Die ersten 3 Zahlen (0-2)</td>
<td>11:1</td>
</tr>
<tr class="odd">
<td>Les Quatre Premiers</td>
<td>Die ersten 4 Zahlen (0-3)</td>
<td>8:1</td>
</tr>
<tr class="even">
<td>Carré</td>
<td>Schnittpunkt zwischen vier Zahlen (z.B. 2-3-4-5)</td>
<td>8:1</td>
</tr>
<tr class="odd">
<td>Cheval</td>
<td>Wette auf zwei angrenzende Zahlen</td>
<td>17:1</td>
</tr>
<tr class="even">
<td>Plain</td>
<td>Wette auf eine einzelne Zahl</td>
<td>35:1</td>
</tr>
</tbody>
</table>
<p>Anhand der Gewinnquote lässt sich berechnen, wie hoch die Auszahlung ist, sollte die Kugel auf dem gemachten Einsatz landen. Wenn jemand beispielsweise 10 Euro auf die 2 gesetzt hat und die Kugel tatsächlich auf der 2 liegenbleibt, werden 350 Euro plus der Einsatz von 10 Euro ausgezahlt.</p>
<p>Der Wetttisch beim französischen Roulette sieht folgendermaßen aus:</p>
<p><img src="/post/Projekt2_Roulette_table.png" /></p>
</div>
<div id="Beispiel" class="section level2">
<h2>Beispiel zur Verwendung von Funktionen</h2>
<p>Im Folgenden bekommst du ein kleines Beispiel zur Verwendung von den Funktionen <code>if</code>, <code>else</code>, <code>for</code> und <code>while</code>. Stell dir vor, du spielst mit ein paar Freund:innen Monopoly und sitzt im Gefängnis fest. Um aus dem Gefängnis zu kommen, ist es notwendig, einen Pasch zu würfeln (die gleiche Augenzahl bei den beiden Würfeln). Zunächst möchten wir schauen, bei wie vielen von 50 Würfen ein günstiges Ergebnis - also ein Pasch - herauskommt.</p>
<pre class="r"><code>Ergebnis1 &lt;- NULL
Ergebnis2 &lt;- NULL
Bedeutung &lt;- NULL
Konsequenz &lt;- NULL</code></pre>
<p>Zuerst erstellt man dazu die Objekte, in denen man im Folgenden die Werte aus der Schleife speichern möchte. <code>Ergebnis1</code> sehen wir dafür vor, jeweils die Augenzahl des ersten Würfels zu speichern; <code>Ergebnis2</code> soll das gleiche für den zweiten Würfel tun. Die beiden Objekte <code>Bedeutung</code> und <code>Konsequenz</code> sollen jeweils die beiden Augenzahlen kombinieren und zum einen die Bedeutung ( “Pasch” oder “kein Pasch”) und zum anderen die daraus folgende Implikation für das Spiel “Du bist frei!” oder “Bleib im Gefängnis!” ausgeben. Die Funktion, die das umsetzt, sieht folgendermaßen aus:</p>
<pre class="r"><code>for (i in 1:50) {         # Wie lang soll die Schleife sein? - 50 Wiederholungen
  wuerfel1 &lt;- sample(1:6, 1)  # Zufallsziehung von Würfel 1
  Ergebnis1[i] &lt;- wuerfel1    # Das Ergebnis von Würfel 1 wird jeweils in einem neuen Eintrag (Eintrag &quot;i&quot; für die i-te Runde/den i-ten Durchlauf) im Objekt &quot;Ergebnis1&quot; gespeichert.
  wuerfel2 &lt;- sample(1:6, 1)  # Zufallsziehung von Würfel 2
  Ergebnis2[i] &lt;- wuerfel2    # Abspeicherung des Ergebnisses von Würfel 2
  if (wuerfel1 == wuerfel2) {     # Wenn die beiden Würfel die gleiche Augenzahl haben, dann soll in dem Objekt &quot;Bedeutung&quot; abgespeichert werden, dass ein Pasch gewürfelt wurde. Ebenso soll in dem Objekt &quot;Konsequenz&quot; die Anweisung &quot;Du bist frei!&quot; ausgegeben werden.
    Bedeutung[i] &lt;- &quot;Pasch&quot;
    Konsequenz[i] &lt;- &quot;Du bist frei!&quot;
  } else {                # Ansonsten soll im Objekt &quot;Bedeutung&quot; abgespeichert werden, dass kein Pasch gewürfelt wurde und im Objekt &quot;Konsequenz&quot; die Anweisung &quot;Bleib im Gefängnis!&quot;
    Bedeutung[i] &lt;- &quot;kein Pasch&quot;
    Konsequenz[i] &lt;- &quot;Bleib im Gefängnis!&quot;
  }
}
Monopoly_Gefaengnis &lt;- data.frame(Ergebnis1, Ergebnis2, Bedeutung, Konsequenz) # Datensatz aus den drei Objekten erstellen</code></pre>
<pre class="r"><code>View(Monopoly_Gefaengnis)     # Datensatz anschauen</code></pre>
<p>Mit dieser Funktion “würfelt” man also 50 Mal, speichert die Augenzahlen jeweils ab und fügt <code>Bedeutung</code> und die daraus folgende <code>Konsequenz</code> für das Spiel hinzu. Am Ende liegen in allen 4 Variablen (<code>Ergebnis1</code>, <code>Ergebnis2</code>, <code>Bedeutung</code> und <code>Konsequenz</code>) 50 zusammengehörige Ausprägungen vor. Diese kann man dann in einen Datensatz zusammenfügen und erhält folgende Tabelle:</p>
<table>
<thead>
<tr>
<th style="text-align:right;">
Ergebnis1
</th>
<th style="text-align:right;">
Ergebnis2
</th>
<th style="text-align:left;">
Bedeutung
</th>
<th style="text-align:left;">
Konsequenz
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
3
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
<tr>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
<tr>
<td style="text-align:right;">
6
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
<tr>
<td style="text-align:right;">
2
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:left;">
Pasch
</td>
<td style="text-align:left;">
Du bist frei!
</td>
</tr>
<tr>
<td style="text-align:right;">
6
</td>
<td style="text-align:right;">
3
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
<tr>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
6
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
<tr>
<td style="text-align:right;">
6
</td>
<td style="text-align:right;">
3
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
<tr>
<td style="text-align:right;">
3
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
<tr>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
5
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
<tr>
<td style="text-align:right;">
3
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:left;">
kein Pasch
</td>
<td style="text-align:left;">
Bleib im Gefängnis!
</td>
</tr>
</tbody>
</table>
<p>Desweiteren kann man überprüfen, wie lange es dauert, bis man einen Pasch würfelt. Dazu benutzt man folgenden Code:</p>
<pre class="r"><code>wuerfel1 &lt;- 0    # Würfel 1
wuerfel2 &lt;- 1    # Würfel 2
m &lt;- 0       # Anzahl Würfe</code></pre>
<p>Zunächst muss man wiederum 3 Objekte erstellen, die man im Folgenden benutzen möchte. <code>wuerfel1</code> und <code>wuerfel2</code> sollen jeweils die Augenzahl eines Würfels abspeichern. Das wichtige dabei ist, dass man diesen beiden Objekten am Anfang ungleiche Zahlen zuordnet, denn ansonsten ist die Bedingung der Funktion direkt erfüllt.</p>
<p><code>m</code> soll dann die Anzahl der Durchgänge zählen, die man bis zum Erfolg (“Pasch”) benötigt. Diese Variable sollte (logischerweise) bei Null beginnen. Warum das so ist, wird in der folgenden Funktion deutlich:</p>
<pre class="r"><code>while (wuerfel1 != wuerfel2) {      # Bedingung
  m &lt;- m + 1                # zählt die Durchgänge - pro Durchlauf +1
  wuerfel1 &lt;- sample(1:6, 1)    # Würfel 1
  wuerfel2 &lt;- sample(1:6, 1)    # Würfel 2
  print(c(wuerfel1, wuerfel2))      # Die beiden Augenzahlen werden pro Wurf ausgegeben, um die Ergebnisse nachvollziehen zu können.
}</code></pre>
<pre><code>## [1] 4 2
## [1] 3 6
## [1] 6 3
## [1] 3 2
## [1] 3 1
## [1] 1 4
## [1] 1 1</code></pre>
<p>Jetzt kann man an der Variable <code>m</code> ablesen, wie viele Versuche man bis zu einem Pasch gebraucht hat. Denn angefangen bei 0 wurde <code>m</code> in jedem Durchlauf um 1 erhöht. In diesem Fall hat es erst im siebten Versuch geklappt.</p>
<pre class="r"><code>m</code></pre>
<pre><code>## [1] 7</code></pre>
<p>Das war es erst einmal mit der Einführung. Viel Spaß bei diesem Projekt!</p>
</div>
<div id="aufgabe-1-grundprinzip-roulette" class="section level2">
<h2>Aufgabe 1: Grundprinzip Roulette</h2>
<p>Erstelle in <code>R</code> die Zufallsziehung, die bei einem einzelnen Roulette-Spiel stattfindet. Simuliere dann 50 Roulette-Spiele, am besten unter Verwendung einer Schleife. Versuche nun (mithilfe eines bestimmten Befehls, den du im <strong>Tipp zur Gewinnberechnung</strong> findest) zu ermitteln, wie viel du bei diesen 50 Spielen gewonnen hättest, wenn du jedes Mal 5 Euro auf die 9 gesetzt hättest.</p>
</div>
<div id="tipps-zu-aufgabe-1-grundprinzip-roulette" class="section level2">
<h2>Tipps zu Aufgabe 1: Grundprinzip Roulette</h2>
<details>
<summary>
Tipp zur Zufallsziehung
</summary>
<p>Für eine einfache Simulation der Zufallsziehung beim Roulette in <code>R</code> benutzt man den <code>sample</code>-Befehl. Für weitere Informationen zu dieser Funktion und den Argumenten schau dir die interne Hilfe an. Roulette ist nicht sehr kompliziert, du brauchst also nur die Basics.</p>
<p>Wenn du 50 Ziehungen durchführen und in einem Objekt speichern willst, gibt es zwei Möglichkeiten:</p>
<ul>
<li>Entweder du bleibst bei der <code>sample</code>-Funktion und benutzt passende Argumente dafür</li>
<li>oder du benutzt eine <code>for</code>-Schleife, um 50 Mal den gleichen Befehl auszuführen und das Ergebnis jeweils einem Objekt hinzuzufügen.</li>
</ul>
</details>
<details>
<summary>
Tipp zur Gewinnberechnung
</summary>
<p>Im vorherigen Teil hast du einen Vektor mit 50 Ziehungen angelegt. Wie berechnet man jetzt daraus den Gewinn für eine Wette auf die 9?</p>
<p>Dafür benötigst du eine Art der <code>if</code>-Funktion und zwar die <code>ifelse</code>-Funktion. Diese Funktion ist auf Vektoren anwendbar und überführt die einzelnen Zufallsziehungen entweder in ein <em>Ergebnis A</em> (falls die Bedingung “Zahl = 9” erfüllt ist) oder in ein <em>Ergebnis B</em> (falls die Bedingung “Zahl = 9” nicht erfüllt ist). Die <em>Ergebnisse A &amp; B</em> musst du hier festlegen als den einem Einsatz von 5 Euro ensprechenden <em>Gewinn</em>, den man macht, wenn die Kugel auf der 9 landet bzw. wenn sie es nicht tut. (Der <em>Gewinn</em> kann natürlich auch negativ sein, falls man die Wette und somit seinen Einsatz verliert.) Es entsteht dadurch also ein neuer Vektor, der nicht mehr die Zufallsziehungen jeder Runde, sondern nur noch den <em>Gewinn</em> jeder Runde enthält. Aus diesem Vektor lässt sich dann durch einfache Addition der Gesamtgewinn berechnen.
Sieh dir die interne Hilfe an, um nachzuschauen, wie genau die Funktion funktioniert und welche Argumente sie besitzt.</p>
</details>
</div>
<div id="lösung-zu-aufgabe-1-grundprinzip-roulette" class="section level2">
<h2>Lösung zu Aufgabe 1: Grundprinzip Roulette</h2>
<details>
<summary>
Lösung anzeigen
</summary>
<p>
<p>Das europäische Roulette verwendet eine Scheibe mit den Zahlen von 0 bis 36, also hat sie 37 verschiedene Fächer. Demnach entspricht das einer einfachen Zufallsziehung aus den Zahlen 0 bis 36, bei der jede Zahl mit gleicher Wahrscheinlichkeit auftritt, da die Fächer alle die gleiche Fläche einnehmen.</p>
<p>Mit <code>sample</code> kannst du - ohne Zurücklegen - alle Nummern ziehen. Es wird als eine zufällige Reihenfolge der Zahlen generiert:</p>
<pre class="r"><code>sample(0:36)</code></pre>
<pre><code>##  [1]  0 27  8 24 22 23 19 15  2 17 33  1 36  7 20  5  4 18 21 34 29  3 11  9 16
## [26] 28 13 32 30 14 31 35 12 25  6 26 10</code></pre>
<p>Was hier nun passiert, ist eine Urnenziehung “ohne Zurücklegen” bis alle Nummern gezogen wurden. Das entspricht jedoch nicht der Zufallsziehung beim Roulette. Dort wird jeweils “mit Zurücklegen” gespielt. Das kann man nun auf zwei Wegen erreichen:</p>
<p>Man könnte jeweils nur eine Ziehung durchführen. Dafür beschränkt man den Befehl auf eine Ziehung aus allen Zahlen. Möchte man nun mehrere Durchgänge simulieren, führt man diesen Befehl einfach mehrfach aus.</p>
<pre class="r"><code>sample(0:36, 1)</code></pre>
<pre><code>## [1] 35</code></pre>
<p>Man könnte auch mit dem Argument <code>replace = T</code> festlegen, dass die gezogenen Zahlen immer wieder zurückgelegt werden. Jetzt kann man mit dem zweiten Argument festlegen, wie oft man die Zufallsziehung durchführen möchte und man erhält eine mathematische Simulation der Zufallsziehung beim Roulette.</p>
<pre class="r"><code>sample(0:36, 5, replace = T)</code></pre>
<pre><code>## [1]  9  9 24  5 27</code></pre>
<p>Jetzt lassen wir die Roulettekugel 50 Mal rollen und speichern die Ergebnisse in der Variable “Ziehungen”.</p>
<p>Das kann entweder, wie bereits beschrieben, über das <code>replace</code>-Argument im <code>sample</code>-Befehl gemacht werden. (Das Ergebnis ist ein numerischer Vektor, den wir hier dem Objekt <code>Ziehungen</code> zuweisen.)</p>
<pre class="r"><code>Ziehungen &lt;- sample(0:36, 50, replace = T)
Ziehungen</code></pre>
<pre><code>##  [1] 31 35  5  5  3  9 17 16 28 31  5 35 14  3 13  1 29 24 12 32 17 34 18 18  0
## [26] 19 12 15 34  6  9 16  8 25 34 22 12 17 34 16  8  7 25 20 36 31  9 17 27 23</code></pre>
<p>Oder man geht einen etwas schwierigeren Weg über eine <code>for</code>-Schleife. Dafür erstellt man zuerst ein leeres Objekt, in dem man dann im Folgenden die einzelnen Ziehungen speichern kann, und führt dann die Schleife aus.</p>
<pre class="r"><code>Ziehungen &lt;- NULL
for (i in 1:50) {
  Ziehungen[i] &lt;- sample(0:36, 1)
}
Ziehungen</code></pre>
<pre><code>##  [1] 10 33  9 21 14 36 32 10 21 24 29  6 27 29 33 14 30  7 26 21 26 33 36 15 20
## [26] 10  6 25 35  6  2  9 21 28 30  4 20 22  6 35 35 35 21  2  5 25  2  2 13 17</code></pre>
<p>Die erste Variante ist zwar wesentlich einfacher zu schreiben (und für <code>R</code> auch wesentlich einfacher und schneller auszuführen), aber die zweite erlaubt es uns, nach dem Rollen jeder einzelnen Kugel noch andere Dinge zu tun.</p>
<p>Nun können wir die Zufallsziehung im Roulette simulieren und auch mehrfach ablaufen lassen. Was jetzt noch fehlt, sind die Wetten und die Berechnung des Gewinns.</p>
<p>Dazu wenden wir uns erst einmal der Frage zu: Wie hoch wäre mein Gewinn, wenn ich in jeder Runde 5 Euro auf die 9 gesetzt hätte?</p>
<p>Bei der Wette auf die 9 handelt es sich um eine einfache Wette auf eine Zahl. Die Wahrscheinlichkeit liegt bei 1:37 bei einer Gewinnausschüttung mit dem Faktor 36. (Die Gewinnausschüttung berechnet sich, wie bereits erwähnt, immer ohne Einbezug der Null - aus diesem Grund geht das Casino auf Dauer als Sieger in diesem Spiel hervor.) Setzt man nun 5 Euro auf eine einzelne Zahl und liegt damit richtig, so erhält man seinen ursprünglichen Einsatz von 5 Euro zurück und bekommt zusätzlich das 36-fache davon, also 180 Euro ausgezahlt. Liegt man nicht richtig, verliert man seinen Einsatz, hat also einen Verlust von 5 Euro.</p>
<p>Nun können wir eine Funktion auf das Objekt <code>Ziehungen</code> (Vektor) anwenden, die einen weiteren Vektor mit den Gewinnen zu den Ziehungen erstellt. Diesen weisen wir dem Objekt <code>Gewinne</code> zu.</p>
<pre class="r"><code>Gewinne &lt;- ifelse(Ziehungen == 9, 180, -5)</code></pre>
<p>Die <code>ifelse</code>-Funktion ist folgendermaßen aufgebaut:</p>
<ol style="list-style-type: decimal">
<li>Man gibt die Bedingung an.</li>
<li>Man gibt die Ausgabe für den Fall an, dass die Bedingung zutrifft.</li>
<li>Man gibt die Ausgabe für den Fall an, dass die Bedingung nicht zutrifft.</li>
</ol>
<p>Wenn also eine 9 herausgekommen ist, soll ein Gewinn von <code>180</code> eingesetzt werden; ansonsten der Gewinn von <code>-5</code> (= Verlust). Der dadurch bestimmte Vektor sieht dann folgendermaßen aus:</p>
<pre><code>##  [1]  -5  -5 180  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5
## [20]  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5 180  -5  -5  -5  -5  -5  -5
## [39]  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5</code></pre>
<p>Jetzt kann man zu jeder Runde den Gewinn ablesen. Insgesamt ergibt das eine Ausbeute von:</p>
<pre class="r"><code>Gesamtgewinn &lt;- sum(Gewinne)
Gesamtgewinn</code></pre>
<pre><code>## [1] 120</code></pre>
<p>Wie man sehen kann, hatten wir in diesem Fall sehr viel Glück. Die 9 wurde in 5 Durchläufen gezogen. Dadurch ergab sich ein phänomenaler Gewinn von 120 Euro.</p>
</details>
</div>
<div id="aufgabe-2-implementierung-verschiedener-wettmöglichkeiten" class="section level2">
<h2>Aufgabe 2: Implementierung verschiedener Wettmöglichkeiten</h2>
<p>Die Funktion aus Aufgabe 1 ist aktuell nur auf die Überprüfung einer Zahl bei einem bestimmten Einsatz spezialisiert. Für jede andere Wette und/ oder jeden anderen Einsatz müsste eine neue Funktion geschrieben werden.</p>
<p>Schreibe also eine Funktion, mit der sich der Gewinn ermitteln lässt und zwar so, dass alle einzelnen Zahlen in dieser Funktion erfasst werden. Implementiere dabei auch die Wetten <code>RED</code>, <code>BLACK</code>, <code>ODD</code>, <code>EVEN</code> sowie das erste, zweite und letzte Drittel. Wähle dabei entweder einen Einsatz von 10 Euro oder (noch besser) verwende den Platzhalter <code>y</code> und speichere zur Überprüfung deiner Funktion beispielsweise den Wert 10 auf dem Objekt <code>y</code> ab.</p>
<p>Erstelle dann wieder eine Schleife mit 50 Spielen, die unter Verwendung der gerade erstellten Funktion jeweils die Zufallsziehung und den Gewinn abspeichert und teste dein “<code>R</code>-Roulette”, indem du auf <code>ODD</code> tippst.</p>
<p>Nicht vergessen: Die Zahlengruppen, wie z.B. <code>RED</code> und <code>BLACK</code>, müssen zuvor erstellt werden. Fange am besten damit an. Dafür erstellt man Objekte, die die jeweiligen Zahlen enthalten.</p>
</div>
<div id="tipps-zu-aufgabe-2-implementierung-verschiedener-wettmöglichkeiten" class="section level2">
<h2>Tipps zu Aufgabe 2: Implementierung verschiedener Wettmöglichkeiten</h2>
<details>
<summary>
Tipp zu Bedingungsüberprüfungen
</summary>
<p>Mehrere Dinge müssen verändert werden, um weitere Wettmöglichkeiten in die Gewinnberechnung zu implementieren.</p>
<p>So muss unter anderem die Bedingung verändert werden. <code>==</code> eignet sich nicht dafür, zu überprüfen, ob eine Zahl Element einer Zahlengruppe ist. Aus diesem Grund sollte man hierfür nun <code>is.element()</code> benutzen. Sofern dir nicht klar ist, was diese Funktion macht und wie sie aufgebaut ist, schau dir die Funktion in der Hilfefunktion von <code>R</code> an.</p>
<p>Auch um zu überprüfen, ob zwei Vektoren identisch sind, eignet sich <code>==</code> nicht. Zu diesem Zweck kann man z.B. die <code>identical</code>-Abfrage verwenden.</p>
</details>
<details>
<summary>
Tipp zur Überarbeitung der Gewinnberechnung
</summary>
<p>Bei dieser Aufgabe muss man beachten, dass es nun unterschiedliche Quoten für die verschiedenen Wetten gibt. Aus diesem Grund kann man eine weitere <code>if</code>-Funktion mit mehreren <code>elseif</code>-Fortsätzen einfügen, die für jede Wettmöglichkeit die Gewinnausschüttung angibt [z.B. <code>if (identical(z, RED){y} else if (identical(z, firstThird){2y}</code> mit <code>x</code> = Wette und <code>y</code> = Einsatz]. Für das Beispiel heißt das: Wenn auf <code>RED</code> gewettet wurde, so liegt der Gewinn bei Eintreffen der Wette bei <code>y</code>, man erhält den eigenen Einsatz also doppelt zurück.</p>
<p>Viele verschiedene Wettmöglichkeiten führen zu einer identischen Gewinnberechnung (z.B. <code>RED</code> und <code>BLACK</code>). Dadurch wiederholen sich in der Funktion möglicherweise einige Befehle. Versuche das durch die Verwendung des mathematischen “oder”, was in <code>R</code> durch <code>|</code> (“Alt Gr” + “&lt;”) dargestellt wird, zu vermeiden.</p>
</details>
<details>
<summary>
Tipp zur Erstellung der neuen Schleife
</summary>
<p>Im letzten Schritt benutzt man eine <code>for</code>-Schleife. In diese setzt du die Zufallsziehung und die Gewinnberechnung ein, sodass in jedem Durchlauf direkt auch der Gewinn ausgegeben werden kann. Wichtig: Beide Variablen (<code>Ziehungen</code> und <code>Gewinne</code>) müssen in einem Objekt abgespeichert werden! Falls du nicht weißt, wie man das bei einer Schleife macht, schau dir noch einmal das <a href="#Beispiel"><strong>Beispiel zur Verwendung von Funktionen</strong></a> an.</p>
<p>Falls du die Objektnamen aus Aufgabe 1 übernimmst, vergiss nicht, diese zunächst von allen Daten zu befreien.</p>
</details>
</div>
<div id="lösung-zu-aufgabe-2-implementierung-verschiedener-wettmöglichkeiten" class="section level2">
<h2>Lösung zu Aufgabe 2: Implementierung verschiedener Wettmöglichkeiten</h2>
<details>
<summary>
Lösung anzeigen
</summary>
<p>Beim Roulette kann man auf beinahe jede vorstellbare Kombination von Zahlen wetten. In dieser Aufgabe bauen wir aber nur die in der Aufgabe verlangten 7 Möglichkeiten ein: rote Zahlen (<code>RED</code>), schwarze Zahlen (<code>BLACK</code>), gerade (<code>EVEN</code>) und ungerade (<code>ODD</code>) Zahlen, sowie die drei <em>Douzaines</em> - Dutzende - in die sich die Zahlen 1 bis 36 einteilen lassen. Wir müssen diese Möglichkeiten zunächst als Objekte mit den dazugehörigen Zahlen füllen. Außer <code>RED</code> und <code>BLACK</code> können wir dabei alle Vektoren abkürzen:</p>
<pre class="r"><code>RED &lt;- c(1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36)
BLACK &lt;- c(2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35)
EVEN &lt;- seq(2, 36, by = 2)
ODD &lt;- seq(1, 35, by = 2)
firstThird &lt;- 1:12
secondThird &lt;- 13:24
lastThird &lt;- 25:36</code></pre>
<p>Grundsätzlich gibt es beim Roulette drei Variablen: den Einsatz, die Wette und die Zufallsziehung. Alle drei gehen in die Berechnung des Gewinns mit ein. Der Einsatz ist die Basis zur Berechnung des Gewinns. Dazu kommt die Wette im Abgleich mit der Zufallsziehung: je nachdem, wie man tippt und ob man richtig tippt oder nicht, ergibt sich eine andere Gewinnberechnung.</p>
<pre class="r"><code># x = Ergebnis Roulette
x &lt;- sample(0:36, 1)
# y = Einsatz (beispielhaft 10 Euro)
y &lt;- 10
# z = Zahl/Gruppe von Zahlen, auf die gesetzt wurde (beispielhaft ungerade Zahlen)
z &lt;- ODD</code></pre>
<p>Zur Gewinnberechnung haben wir in Aufgabe 1 die <code>ifelse</code>-Funktionen verwendet. Allerdings lässt sich diese Funktion nicht so gut auf kompliziertere Fälle anwenden als den aus Aufgabe 1, wo es nur eine Bedingung gab (und zwar dass eine einzelne Zahl gedreht wurde) und auch nur einen potenziell möglichen Gewinn.</p>
<p>Aus diesem Grund wurde die Aufgabe so gestellt, dass die Gewinnberechnung “einen Schritt früher stattfindet” und in die Schleife mit den 50 Spielen integriert wird, statt erst danach stattzufinden. Damit wie schon bei Aufgabe 1 auch die gedrehten Zahlen mitausgegeben werden, müssen diese weiterhin innerhalb der Schleife in einem eigenen Objekt abgespeichert und später mitausgegeben werden.</p>
<p>Bei der Gewinnberechnung nutzt man die “normale” <code>if</code>-Funktion. Die Bedingung wie in Aufgabe 1 nach dem Prinzip “Wenn die Zufallsziehung x der Wette z entspricht, dann gewinnt man” zu schreiben, funktioniert nach wie vor, wenn die Wette eine einzelne Zahl ist. Allerdings geht das bei den neu hinzugefügten Wetten (wie zum Beispiel auf die ungeraden Zahlen) nicht. Also formulieren wir die Bedingung mit dem <code>is.element</code>-Argument. Wenn <code>x</code> (die Zufallsziehung) ein Element von <code>z</code> (der Wette) ist, hat man gewonnen.</p>
<p>Zusätzlich zu der Bedingung, die prüft, ob man richtig getippt hat, baut man nun bei Zutreffen der Bedingung eine weitere <code>if</code>-Funktion ein, die die unterschiedlichen Berechnungen des Gewinns für die unterschiedlichen Wetten beinhaltet. In diesem Rahmen muss abgefragt werden, welcher der verschiedenen möglichen Wetten die getätigte Wette <code>z</code> entspricht.</p>
<p>Hierfür können wir nicht die logische Abfrage <code>==</code> verwenden, weil diese nur einzelne Zahlen miteinander vergleichen kann und nicht ganze Vektoren. Stattdessen bietet sich der <code>identical</code>-Befehl an. Dieser Befehl überprüft, ob zwei Elemente identisch sind, unabhängig von der Struktur bzw. Größe dieser beiden Elemente.</p>
<p>Abhängig von Zufallsziehung, Einsatz und Wette könnte man den Gewinn also folgendermaßen ermitteln:</p>
<pre class="r"><code>if (is.element(x, z)) {
  if (identical(z, RED)) {
    y
  } else if (identical(z, BLACK)) {
    y
  } else if (identical(z, ODD)) {
    y
  } else if (identical(z, EVEN)) {
    y
  } else if (identical(z, firstThird)) {
    y * 2
  } else if (identical(z, secondThird)) {
    y * 2
  } else if (identical(z, lastThird)) {
    y * 2
  } else {
    y * 35
  }
} else {
  -y
}</code></pre>
<pre><code>## [1] -10</code></pre>
<p>Wie man sehen kann, berechnet diese Funktion den korrekten Gewinn für unser Beispiel.</p>
<p>Ein kleiner Kritikpunkt dieser Funktion ist die mehrfache Wiederholung fast identischer Befehle. Das kann man durch die Verwendung logischer Verknüpfungen; und zwar dem <code>|</code> (das “oder” in <code>R</code>) verhindern. Im Folgenden kann man die optimierte Version des Befehls sehen:</p>
<pre class="r"><code>if (is.element(x, z)) {
  if (identical(z, RED) | identical(z, BLACK) | 
      identical(z, ODD) | identical(z, EVEN)) {
    y
  } else if (identical(z, firstThird) | 
      identical(z, secondThird) | 
      identical(z, lastThird)) {
    y * 2
  } else {
    y * 35
  }
} else {
  -y
}</code></pre>
<pre><code>## [1] -10</code></pre>
<p>Da die Funktion nun okönomisch und ohne Fehler läuft, können wir das Ganze nun in die Schleife einsetzen, die wir bereits in Aufgabe 1 benutzt haben. Damit enthält diese Schleife die Verbesserung, dass in jedem Durchlauf auch der Gewinn ermittelt wird.</p>
<p>Um das jetzt auch einmal auszuprobieren, müssen wir die beiden Variablen <code>Ziehungen</code> und <code>Gewinne</code> von den Daten aus der ersten Aufgabe befreien und die Wette beispielhaft auf <code>ODD</code> festlegen:</p>
<pre class="r"><code>Gewinne &lt;- NULL
Ziehungen &lt;- NULL
z &lt;- ODD</code></pre>
<p>Die Schleife sieht nun folgendermaßen aus:</p>
<pre class="r"><code>for (i in 1:50) {
  x &lt;- sample(0:36, 1)
  Ziehungen[i] &lt;- x
  Gewinne[i] &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) | 
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) | 
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
}</code></pre>
<p>Die Ergebnisse können wir uns nun entweder einzeln anschauen oder wir verbinden beide Objekte zu einem Datensatz.</p>
<pre class="r"><code>Ziehungen</code></pre>
<pre><code>##  [1] 15 13 15 10 34 30 33  7 23 18 23 16 25 22 34  8 24  6 22  2  9 30  1 24 35
## [26] 17 16 35 30  6 30  2 27 17 22  9 13 20 36 12 25 35 12 17 10 20 21  2  8  0</code></pre>
<pre class="r"><code>Gewinne</code></pre>
<pre><code>##  [1]  10  10  10 -10 -10 -10  10  10  10 -10  10 -10  10 -10 -10 -10 -10 -10 -10
## [20] -10  10 -10  10 -10  10  10 -10  10 -10 -10 -10 -10  10  10 -10  10  10 -10
## [39] -10 -10  10  10 -10  10 -10 -10  10 -10 -10 -10</code></pre>
<pre class="r"><code>Spiel_Odd_50 &lt;- data.frame(Ziehungen, Gewinne)
head(Spiel_Odd_50)</code></pre>
<pre><code>##   Ziehungen Gewinne
## 1        15      10
## 2        13      10
## 3        15      10
## 4        10     -10
## 5        34     -10
## 6        30     -10</code></pre>
<p>Den Gesamtgewinn kann man sich dann auch noch für jede Runde mithilfe der <code>cumsum</code>-Funktion anzeigen lassen oder man benutzt die <code>sum</code>-Funktion, um nur das Endergebnis zu erhalten.</p>
<pre class="r"><code>cumsum(Gewinne)</code></pre>
<pre><code>##  [1]  10  20  30  20  10   0  10  20  30  20  30  20  30  20  10   0 -10 -20 -30
## [20] -40 -30 -40 -30 -40 -30 -20 -30 -20 -30 -40 -50 -60 -50 -40 -50 -40 -30 -40
## [39] -50 -60 -50 -40 -50 -40 -50 -60 -50 -60 -70 -80</code></pre>
<pre class="r"><code>sum(Gewinne)</code></pre>
<pre><code>## [1] -80</code></pre>
</details>
</div>
<div id="aufgabe-3-spiele-bis-du-x-euro-gewonnen-hast." class="section level2">
<h2>Aufgabe 3: Spiele, bis du X Euro gewonnen hast.</h2>
<p>Hast du dich schon mal gefragt, wie lang es dauert, bis du einen bestimmten Betrag beim Roulette gewonnen hast? Lege dich beispielsweise darauf fest, dass du jede Runde 10 Euro auf “ROT” setzt und am Ende einen Gewinn von 50 Euro haben möchtest.
Schreibe nun eine Funktion, die so lange läuft, bis du das gewünschte Geld gewonnen hast.
Achtung: Die Funktion zählt die Durchläufe nicht von selbst mit. Sorge dafür, dass eine Variable deiner Schleife die Durchläufe zählt. Wie lang hat es bis zu deinem gewünschten Gewinn gedauert?</p>
<p>Tipp: Mit etwas Glück hält die Schleife irgendwann an und du gewinnst tatsächlich 50 Euro, unter Umständen wird der Fall aber nie eintreten. Besonders wenn du “zu viel” gewinnen möchtest, könnte es passieren, dass die Schleife immer weiter läuft. Stoppe die Schleife dann in deiner Konsole manuell und probier es noch einmal mit einer anderen Wette oder baue eine weitere Bedingung ein, die die Durchläufe begrenzt. So könntest du für das obige Beispiel festlegen, dass die Schleife nach 500 Durchgängen anhält, sofern du bis dahin keine 50 Euro gewonnen hast.</p>
</div>
<div id="tipps-zu-aufgabe-3-spiele-bis-du-x-euro-gewonnen-hast." class="section level2">
<h2>Tipps zu Aufgabe 3: Spiele, bis du X Euro gewonnen hast.</h2>
<p>Hier erhältst du zwei verschiedene Möglichkeiten, um dasselbe Problem zu lösen. Die erste Möglichkeit wird dich etwas mehr fordern. Probiere es also zuerst damit. Falls du es damit nicht schaffst, die Aufgabe zu lösen, schau dir die zweite Möglichkeit an. Diese gibt dir Hinweise zu den einzelnen Schritten, bis du zur Lösung des Problems kommst.</p>
<details>
<summary>
Möglichkeit 1: Übertragen von Modell
</summary>
<p>Falls du noch nicht darauf gekommen bist, schau dir noch einmal das <a href="#Beispiel"><strong>Beispiel zur Verwendung von Funktionen</strong></a> an. Dort findest du eine Funktion nach dem gleichen Schema, wie es auch hier gefordert ist. Falls dir das nicht ausreicht, kannst du zusätzlich dazu auch noch Möglichkeit 2 nutzen.</p>
</details>
<details>
<summary>
Möglichkeit 2: Schrittweise Anleitung
</summary>
<p>Zunächst schau dir einmal an, was du aus den vorherigen Abschnitten übernehmen kannst. Ändert sich etwas an der Zufallsziehung und der Gewinnberechnung? Was kommt neu hinzu?</p>
<p>Kurz gesagt: Zufallsziehung und Gewinnberechnung bleiben gleich, können also 1:1 übernommen werden. Neu sind die Bedingung mit dem Gesamtgewinn, das Updaten des Gesamtgewinns und das Zählen der Durchgänge.</p>
<p>Beginnen wir bei der Bedingung: Die Bedingung lässt sich umsetzen durch den Befehl, dass die Schleife so lange wiederholt wird, bis der tatsächliche Gesamtgewinn nicht mehr kleiner als der gewünschte Gesamtgewinn ist. Zu diesem Zweck wird eine <code>while</code>-Schleife benötigt. Eventuell ist es hilfreich, sich das <a href="#Beispiel"><strong>Beispiel zur Verwendung von Funktionen</strong></a> noch einmal anzuschauen, weil hier eine <code>while</code>-Schleife zum Einsatz kommt. Außerdem kannst du <a href="https://www.uni-muenster.de/Stochastik/lehre/SS14/PrakStat/R-Befehle.pdf">hier unter dem Reiter “Programmierung”</a> nachlesen, wann eine <code>while</code>-Schleife angewandt wird.</p>
<p>Die Berechnung des Gesamtgewinns erfordert eine neue “Technik”, da dieser jeden Durchgang aktualisiert werden muss. Dazu muss vor der Durchführung der Funktion ein <code>Gesamtgewinn</code>-Objekt mit dem Wert 0 erstellt werden. Jede Runde soll dieser Gesamtgewinn dann erneuert werden, indem man den alten Gesamtgewinn und den Gewinn der aktuellen Runde addiert.</p>
<p>Achtung: Diese Berechnung muss nach der Berechnung des aktuellen Gewinns geschehen, ansonsten rechnet man mit dem Gewinn aus der vorherigen Runde.</p>
<p>Der letzte Schritt sollte sein, die Durchgänge zu zählen. Das beruht auf der gleichen Methode, wie die Berechnung des Gesamtgewinns.</p>
<p>Möglicherweise erreicht man den erwünschten Gewinn nie und in Folge dessen würde die Schleife unendlich weiterlaufen. (Sofern du die Schleife bereits gestartet hast, aber die Funktion nicht zum Ende kommt, nutze den “STOP”-Button in der oberen rechten Ecke der Konsole, um die Funktion manuell zu stoppen!) Wenn wir ein Abbrechen der Schleife bei einer bestimmten Anzahl an Durchgängen in die Funktion integrieren wollen, bietet sich der <code>break</code>-Befehl an. Du kannst <a href="https://www.uni-muenster.de/Stochastik/lehre/SS14/PrakStat/R-Befehle.pdf">hier unter dem Reiter “Programmierung”</a> nachlesen, wie er anzuwenden ist.</p>
<p>Natürlich kannst du auch eine weitere Bedingung zum Abschluss der Funktion mit einem logischen “oder” hinzufügen. Das sollte dann so aussehen: <code>while (cond1 | cond2) {...}</code>, wobei <code>cond1</code> die Bedingung beschreibt, dass der Gesamtgewinn noch nicht erreicht wurde und <code>cond2</code> entspricht der Bedingung, dass noch nicht mehr als 500 Durchgänge durchlaufen wurden.</p>
</details>
</div>
<div id="lösung-zu-aufgabe-3-spiele-bis-du-x-euro-gewonnen-hast" class="section level2">
<h2>Lösung zu Aufgabe 3: Spiele, bis du X Euro gewonnen hast</h2>
<details>
<summary>
Lösung anzeigen
</summary>
<p>Wir spielen nun beispielhaft mit einem Einsatz von 10 Euro auf <code>RED</code>. Dafür erstellen wir außerdem ein Objekt, das den Gewinn in der jeweiligen Runde kurzzeitig abspeichert, damit wir damit arbeiten können.</p>
<pre class="r"><code>y &lt;- 10
z &lt;- RED
Gewinn &lt;- NULL</code></pre>
<p>Nun fehlen noch genau zwei Dinge:</p>
<ol style="list-style-type: decimal">
<li>Wie ermitteln wir jeden Durchgang erneut den Gesamtgewinn, sodass dieser immer wieder mit der Bedingung abgeglichen werden kann?</li>
<li>Wie zählen wir die Durchgänge?</li>
</ol>
<p>Zu 1. - Für die Bedingung entscheiden wir uns für 50 Euro. Das heißt, dass wir so lange spielen wollen, bis wir 50 Euro gewonnen haben. Dafür brauchen wir ein weiteres Objekt für den Gesamtgewinn. Dieses Objekt soll in jedem Durchgang geupdatet werden. Starten soll es (logischerweise) bei Null. Also erstellen wir dafür das Objekt <code>Gesamtgewinn</code> mit dem Wert 0.</p>
<pre class="r"><code>Gesamtgewinn &lt;- 0</code></pre>
<p>Dieses Objekt soll dann in jedem Durchgang mit dem Gewinn addiert werden; also schreibt man in die Funktion: <code>Gesamtgewinn &lt;- Gesamtgewinn + Gewinn</code>. So wird der Gesamtgewinn in jedem Durchgang geupdatet und mit der Bedingung <code>Gesamtgewinn &lt; 50</code> verglichen. Damit wäre das erste Problem gelöst.</p>
<p>Zu 2. - Für das Zählen der Durchgänge wendet man eine identische Technik an. Dafür erstellt man wiederum ein Objekt (<code>Durchgaenge</code>) mit dem Wert 0.</p>
<pre class="r"><code>Durchgaenge &lt;- 0</code></pre>
<p>Dieses Objekt updatet man auch in jedem Durchgang, indem man jedes Mal 1 addiert: <code>Durchgaenge &lt;- Durchgaenge + 1</code>. Somit zählt man automatisch die Durchgänge mit.</p>
<p>Damit wären die beiden Probleme gelöst und wir kommen zu einem vorläufigen Ergebnis der Schleife.</p>
<p>Wenn man möchte, kann man sich auch in jedem Durchgang noch den Zwischenstand (<code>Gesamtgewinn</code>) oder den Gewinn der Runde (<code>Gewinn</code>) mithilfe der <code>print</code>-Funktion ausgeben lassen. Das Endergebnis sieht dann folgendermaßen aus:</p>
<pre class="r"><code>while (Gesamtgewinn &lt; 50) {
  x &lt;- sample(0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
  Gesamtgewinn &lt;- Gesamtgewinn + Gewinn
  print (Gesamtgewinn)
  Durchgaenge &lt;- Durchgaenge + 1
}</code></pre>
<p>Die Funktion wird nun so lange alle Schritte wiederholen, bis die Bedingung <code>Gesamtgewinn &lt; 50</code> nicht mehr zutrifft. Bis dahin werden auch die Durchgänge gezählt. Das heißt, dass man, sofern die Funktion irgendwann stoppt, an dem Objekt <code>Durchgaenge</code> ablesen kann, wie lange man für einen Gewinn von 50 Euro hätte spielen müssen.</p>
<p>Wie man vielleicht merkt, hat das Ganze einen Haken. Wenn man Pech hat, dann kommt diese Funktion nie zum Ende, weil man nie oft genug in Folge gewinnt, um auf einen Gesamtgewinn von 50 Euro zu kommen. Keep in mind: Das Casino gewinnt letztlich immer; und das ist ein Fakt! Die Gewinnausschüttung beim Roulette berechnet sich nämlich derart, dass eine Person, je öfter sie spielt, umso wahrscheinlicher mit leeren Händen nach Hause gehen wird.</p>
<p>Aus diesem Grund sollten wir eine weitere Bedingung einbauen, die die Schleife nach einer bestimmten Zeit unterbricht. Eine Möglichkeit ist es, eine maximale Anzahl an Durchgängen festzulegen, bei der die Schleife beendet wird. Dafür kann man den <code>break</code>-Befehl benutzen. Diesen kann man in eine Schleife integrieren und bei Eintreten der dazugehörigen Bedingung (<code>if</code>) wird die Schleife unterbrochen. Im folgenden Beispiel brechen wir die Schleife nach 500 Durchgängen ab.</p>
<pre class="r"><code>Gesamtgewinn &lt;- 0
Durchgaenge &lt;- 0
while (Gesamtgewinn &lt; 50) {
  x &lt;- sample(0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
  Gesamtgewinn &lt;- Gesamtgewinn + Gewinn
  Durchgaenge &lt;- Durchgaenge + 1
  if (Durchgaenge == 500) break
}
Gesamtgewinn</code></pre>
<pre><code>## [1] -320</code></pre>
<p>Das heißt, dass man nun so lange spielt, bis man entweder 50 Euro gewonnen oder 500 Runden gespielt hat.</p>
</details>
</div>
<div id="aufgabe-4-funktionen" class="section level2">
<h2>Aufgabe 4: Funktionen</h2>
<p>In <code>R</code> gibt es die Möglichkeit, eigene Funktionen mit dem Befehl <code>function</code> zu erstellen. Nutze dies nun dafür, eine Roulette-Funktion zu erstellen. Diese Funktion sollte es dir dann ganz einfach ermöglichen, nur durch Angabe von Einsatz und Wette deinen Gewinn in einer Runde zu ermitteln.</p>
<p>Die Funktion sollte in <code>R</code> folgendermaßen aussehen:</p>
<pre class="r"><code>Roulette(Einsatz, Wette)</code></pre>
<p>Ihr Output sollte zunächst die Zufallsziehung und der Gewinn sein.
Wenn du das geschafft hast, verschönere die Ausgabe mit ein paar Nachrichten und Pausen, um das Spiel etwas authentischer zu gestalten. Nutze dafür den <code>message</code>-Befehl und den <code>Sys.sleep</code>-Befehl.</p>
<p>Die Nachrichten sollten mindestens folgende Informationen vermitteln:</p>
<ul>
<li>Verkünde, dass die Kugel startet.</li>
<li>Verkünde nach bestimmter Zeit, dass keine Wetten mehr möglich sind.</li>
<li>Welche Zahl kam heraus?</li>
<li>Welche Bedeutung hat das für meine Wette?</li>
<li>Je nach Ausgang unterschiedliche Nachrichten, bspw. bei Gewinn Glückwünsche oder Höhe des Gewinns und bei Verlust aufmunternde Worte.</li>
</ul>
<p>Wenn du das geschafft hast, probiere dich an einer Funktion, bei der man zusätzlich dazu angeben kann, wie viele Runden man mit gleichbleibender Wette und gleichem Einsatz spielen möchte. Passe das Spiel dementsprechend mit abgeänderten Nachrichten und Pausen an.</p>
<p>Die Funktion sollte letztlich so funktionieren:</p>
<pre class="r"><code>Roulette_2(Einsatz, Wette, Runden)</code></pre>
<p>Die Nachrichten im Output sollten hierbei folgende Fragen beantworten:</p>
<ul>
<li>Welche Runde wird gerade gespielt?</li>
<li>Verkünde, dass die Kugel startet.</li>
<li>Verkünde nach bestimmter Zeit, dass keine Wetten mehr möglich sind.</li>
<li>Welche Zahl kam heraus?</li>
<li>Welche Bedeutung hat das für meine Wette in dieser Runde?</li>
<li>Wie groß ist mein Gewinn in dieser Runde?</li>
<li>Wie sieht mein Gesamtergebnis zu diesem Zeitpunkt aus?</li>
<li>Je nach Ergebnis unterschiedliche Nachrichten, bspw. bei Gewinn Glückwünsche oder Höhe des Gewinns und bei Verlust aufmunternde Worte und wenn man weder einen Gewinn noch einen Verlust erzielt hat, irgendeine Nachricht.</li>
<li>Zum Schluss: Eine abschließende Nachricht, die das gesamte Spiel für beendet erklärt und es noch einmal zusammenfasst, sowie das Gesamtergebnis beinhaltet.</li>
</ul>
</div>
<div id="tipps-zu-aufgabe-4-funktionen" class="section level2">
<h2>Tipps zu Aufgabe 4: Funktionen</h2>
<p>In diesem Abschnitt beschäftigen wir uns mit dem Erstellen von eigenen Funktionen, um eine authentische Roulette-bezogene Ausgabe in <code>R</code> zu erhalten. Da die Problemstellung in zwei Teile geteilt ist und man zwei Funktionen erstellen soll, teilen wir auch die Tipps in zwei Teile.</p>
<details>
<summary>
Teil 1
</summary>
<p>Als allererstes solltest du dir diesen <a href="/post/loops-und-funktionen/#function">PandaR Beitrag</a> oder diesen <a href="https://de.wikibooks.org/wiki/GNU_R:_Eigene_Funktionen_programmieren">Wikipedia Artikel</a> zu der <code>function</code>-Funktion in <code>R</code> durchlesen, falls du dich damit noch nicht auskennst. Hierin wird erklärt, wie diese Funktion in <code>R</code> funktioniert. Sobald du das verstanden hast, kannst du mit dem Erstellen der Funktion beginnen.</p>
<p>Ein wichtiger Bestandteil der Funktion sind die Parameter in der normalen Klammer. Hier stellt sich die Frage: Wie viele “Unbekannte” wird meine Funktion haben? Welche Information braucht meine Funktion? - In unserem Fall handelt es sich nur um zwei Unbekannte, die man als Spieler im vorhinein angeben muss:</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>Der Einsatz: Wie viel will ich setzen?</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>Die Wette: Auf was will ich setzen?</li>
</ol></li>
</ul>
<p>Diese zwei Variablen müssen also in der normalen Klammer benannt werden. (Dafür kannst du jegliche sich unterscheidende Buchstaben verwenden.)</p>
<p>Jetzt kannst du mit dem Schreiben der Funktion beginnen. Einige Operationen aus den vorherigen Aufgaben können dabei übernommen werden. Beachte dabei nur, die Variablen aus der normalen Klammer bei den Operationen an der richtigen Stelle einzusetzen.</p>
<p>Das Grundgerüst für Roulette sollte nun stehen, nur gibt die Funktion noch keinen Output aus. Dafür können wir den <code>message</code>-Befehl benutzen. Dieser ermöglicht es uns, auch Variablen in den Text einzufügen. Hier ein Beispiel:</p>
<pre class="r"><code>Wuerfeln1 &lt;- function (){
  message (&quot;Bitte jetzt würfeln!&quot;)
  Augenzahl &lt;- sample (1:6, 1)
  message (&quot;Du hast eine &quot;, Augenzahl, &quot; geworfen!&quot;)}
Wuerfeln1 ()</code></pre>
<pre><code>## Bitte jetzt würfeln!</code></pre>
<pre><code>## Du hast eine 1 geworfen!</code></pre>
<p>Nutze das für deine Nachricht(en) aus!</p>
<p>Um das Ganze noch authentischer zu gestalten, kannst du jetzt Pausen für die Ausgabe einbauen. Dafür benutzt man den <code>Sys.sleep</code>-Befehl, der in Klammern die Pausenzeit in Sekunden enthält. So kann beim Würfeln zum Beispiel die Zeit zum Fallen des Würfels simuliert werden:</p>
<pre class="r"><code>Wuerfeln2 &lt;- function (){
  message (&quot;Bitte jetzt würfeln!&quot;)
  Augenzahl &lt;- sample (1:6, 1)
  Sys.sleep (3.0)
  message (&quot;Du hast eine &quot;, Augenzahl, &quot; geworfen!&quot;)}
Wuerfeln2 ()</code></pre>
<pre><code>## Bitte jetzt würfeln!</code></pre>
<pre><code>## Du hast eine 1 geworfen!</code></pre>
</details>
<details>
<summary>
Teil 2
</summary>
<p>Diese Funktion gestaltet sich etwas komplexer als die vorherige Funktion. Hier werden wir mit dem <code>repeat</code>-Befehl und <code>if (condition) break</code> arbeiten. Schau dir die Funktionsweise davon im Internet oder im <a href="/post/loops-und-funktionen/#AppendixA">Appendix A dieses PandaR Beitrag</a> an. An sich funktioniert dieser Befehl genauso wie eine <code>for</code>- oder <code>while</code>-Schleife, nur dass wir die Schleife hier erst dann stoppen wollen, wenn ein explizites Ereignis eintritt.</p>
<p>Wie bereits in allen anderen Aufgaben solltest du auch hier auf den bereits vorhandenen Operationen aufbauen. Für diese Funktion eignet sich logischerweise die Funktion aus Teil 1 dieses Abschnitts. Es kommt nur eine weitere Variable - neben Einsatz und Wette - hinzu und zwar die Rundenzahl. Das ist die erste Ergänzung, die du vornehmen kannst: Erstelle eine neue Variable für die Rundenzahl in der normalen Klammer. (Außerdem solltest du dieser Funktion einen neuen Namen geben, um die erste Funktion nicht zu überschreiben.)</p>
<p>Hier soll es nun darum gehen, wie wir diese Rundenvariable (die durch den/die Spieler:in angegeben wird) mit der gerade gespielten Runde abgleichen können, sodass die Schleife entsprechend endet. Dafür muss nach bereits angewendetem Prinzip eine weitere Variable erstellt werden, die die aktuelle Runde zählt (also jede Runde 1 addiert wird). Diese muss dann ganz am Ende der <code>repeat</code>-Schleife mit der durch den/die Spieler:in angegebenen Rundenzahl abgeglichen werden. Wenn beide Variablen den gleichen Wert haben, soll die Schleife abgebrochen werden.</p>
<p>Das Rundenproblem sollte damit gelöst sein. Hinzu kommt jedoch noch der Gesamtgewinn. Dieser wird bis jetzt nicht ermittelt (, vielmehr wird immer wieder der Gewinn der gerade laufenden Runde ermittelt und dann in der nächsten Runde überschrieben). Natürlich kann der Gewinn jeder Runde in einer Nachricht ausgegeben werden, dadurch erhält man jedoch keinen Gesamtgewinn. Dieser sollte auch nach bereits bekanntem und angewendetem Schema ermittelt werden: eine Variable mit dem Wert “0” <strong>vor</strong> der <code>repeat</code>-Schleife erstellen; dann jede Runde updaten.</p>
<p>Der letzte Schritt sind Nachrichten und Pausen. Hier kann man kreativ werden; auf jeden Fall kann man die Nachrichten aus der Funktion in Teil 1 übernehmen. Diese werden in jeder Runde ausgegeben. Außerdem sollte man (auch in jeder Runde) den Gesamtgewinn angeben. Neben diesen Nachrichten sollten auch bei Beenden der Schleife Nachrichten folgen, die das Spiel zusammenfassen. Hierbei kann man auch, je nach Gesamtgewinn, verschiedene “Pfade” erstellen.</p>
<p>Zu bedenken ist dabei, in welcher Reihenfolge die Funktion die Informationen für die Nachrichten berechnet, sodass jede Runde die aktuellen Daten ausgegeben werden und nicht die Daten der vorherigen Runde. Schreibe daher die Nachrichten, die man nach jeder Runde erhält, an das Ende der <code>repeat</code>-Funktion (direkt über <code>if (cond) break</code>). Die anderen Nachrichten, die sich auf das gesamte Spiel beziehen, schreibst du an das Ende der gesamten Funktion. So gehst du in jedem Fall auf Nummer sicher.</p>
</details>
</div>
<div id="lösung-zu-aufgabe-4-funktionen" class="section level2">
<h2>Lösung zu Aufgabe 4: Funktionen</h2>
<details>
<summary>
Abschnitt 1 anzeigen
</summary>
<p>Für das Erstellen einer Funktion kann man den <code>function</code>-Befehl benutzen. Dieser Befehl ist folgendermaßen aufgebaut: <code>function(Variable1, Variable2, ...){Funktion}</code>. Man gibt in den normalen Klammern an, welche Variablen in der Funktion verwendet und zur Durchführung benötigt werden. In den geschwungenen Klammern gibt man dann die Operationen der Funktion an, die unter Verwendung der Variablen durchgeführt werden. Dem Ganzen kann man mithilfe der Zuweisung mit dem Pfeil einen Namen geben.</p>
<p>Für das Roulette ergeben sich zwei Variablen: der Einsatz <code>y</code> und die Wette <code>z</code>. Die Funktion kann man aus den vorherigen Aufgaben kopieren. Das ist zum einen die Zufallsziehung und zum anderen die Funktion zur Ermittlung des Gewinns in Abhängigkeit von Einsatz <code>y</code> und Wette <code>z</code>.</p>
<p>Das Problem ist nun, dass die Funktion noch keine Ergebnisse ausgibt. Dafür können wir zunächst ganz einfach den <code>print</code>-Befehl nutzen. Wichtig: der <code>print</code>-Befehl kann nur ein Objekt ausgeben, deshalb muss man Zufallsziehung und Gewinn in einen Vektor packen. Das sieht dann folgendermaßen aus:</p>
<pre class="r"><code>Roulette &lt;- function (y, z) {
  x &lt;- sample (0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
  print(c(x, Gewinn))
}
Roulette(10,7)</code></pre>
<pre><code>## [1]  23 -10</code></pre>
<p>Nun kann man ganz einfach Roulette spielen, indem man Einsatz und Wette angibt und dann Zufallsziehung und Gewinn erhält. Wie man in diesem Beispiel sieht, wurden 10 Euro auf die Zahl 7 gesetzt. Ausgegeben wird, welche Zahl bei der Ziehung herauskam sowie der Gewinn.</p>
<p>Das Ganze ist aber noch nicht so schön. Deshalb versuchen wir, das Roulettespiel mit Pausen und Nachrichten etwas authentischer zu gestalten. Das Praktische dabei ist, dass man auch Variablen in diese Nachrichten schreiben kann, sodass man zum Beispiel eine Nachricht, die das Ergebnis enthält, allgemein formulieren kann: <code>message("Es wurde eine ", x, " gedreht!")</code>. Des Weiteren kann man, je nach Resultat (Sieg oder Niederlage) unterschiedliche Nachrichten mithilfe einer <code>if</code>-Funktion ausgeben lassen. Das könnte dann folgendermaßen aussehen:</p>
<pre class="r"><code>Roulette &lt;- function (y, z) {
  x &lt;- sample (0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
  message (&quot;Roulettekugel startet&quot;)
  Sys.sleep (2.0)
  message (&quot;Rien ne va plus!&quot;)
  Sys.sleep (2.0)
  message (&quot;Es ist eine &quot;, x, &quot;.&quot;)
  Sys.sleep (2.0)
  if (is.element (x, z)) {
    message (&quot;Du hast gewonnen!&quot;)
    Sys.sleep (2.0)
    message (&quot;Dein Gewinn beträgt &quot;, Gewinn, &quot; Euro.&quot; )
  } else {
    message (&quot;Du hast verloren!&quot;)
    Sys.sleep (2.0)
    message (&quot;Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.&quot;)
  }
}</code></pre>
<p>Das testen wir jetzt, indem wir die Funktion einmal benutzen. In diesem Beispiel setzen wir 10 Euro auf <code>RED</code>.</p>
<pre class="r"><code>Roulette(10,RED)</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 33.</code></pre>
<pre><code>## Du hast verloren!</code></pre>
<pre><code>## Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.</code></pre>
<p>Die Ausgabe in diesem Beispiel ist schon deutlich schöner/authentischer und beinhaltet alle nötigen Informationen.</p>
<p>In dieser Funktion kann man jedoch nur einmal spielen und muss die Funktion dann erneut starten. Dafür können wir eine neue Funktion schreiben, die die alte Funktion dahingehend erweitert, als dass man mehrere Runden auf einmal spielen kann. Das wird im zweiten Abschnitt erläutert.</p>
</details>
<details>
<summary>
Abschnitt 2 anzeigen
</summary>
<p>Für das Umsetzen einer Roulette-Funktion mit variabler Rundenzahl müssen wir einige Anpassungen und Erweiterungen an der Funktion in Abschnitt 1 vornehmen. Übernehmen können wir wiederum die Zufallsziehung und die Gewinnberechnung aus den vorherigen Aufgaben. Wir wissen auch schon, dass wir drei Variablen haben werden: <code>y</code> = Einsatz, <code>z</code> = Wette und <code>o</code> = Anzahl der Runden. Die Funktion nennen wir <code>Roulette_Schleife</code>. Das sieht dann vorerst folgendermaßen aus:</p>
<pre class="r"><code>Roulette_Schleife &lt;- function(y, z, o) {
  x &lt;- sample(0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
}</code></pre>
<p>Jetzt müssen wir uns überlegen, wie wir Zufallsziehung und Gewinnberechnung wiederholt durchführen können bis eine bestimmte Anzahl an Runden gespielt wurde. Wir wissen, dass die Variable <code>o</code> angibt, wie viele Runden gespielt werden sollen. Wir erstellen also eine weitere Variable <code>Durchgaenge</code>, die die gespielten Runden zählen soll. Das Vorgehen dabei sollte bereits aus den vorherigen Aufgaben bekannt sein. Mithilfe dieser beiden Variablen <code>o</code> und <code>Durchgaenge</code> können wir nun eine Bedingung erstellen, sodass gespielt wird bis <code>o == Durchgaenge</code> gilt.</p>
<p>Dafür verwenden wir eine neue Funktion: die <code>repeat</code>-Funktion. Diese Funktion führt alle ihre Operationen durch, bis die Bedingung (in unserem Fall <code>o == Durchgaenge</code>) erfüllt ist. Anders als bei bereits bekannten Funktionen schreibt man die Bedingung hier an das Ende der Funktion. Und zwar ist die <code>repeat</code>-Funktion folgendermaßen aufgebaut: <code>repeat {Operation 1 ENTER Operation 2 ENTER etc. ENTER if (o == Durchgaenge) break}</code>. Das sieht dann bei uns folgendermaßen aus:</p>
<pre class="r"><code>Roulette_Schleife &lt;- function (y, z, o) {
  Durchgaenge &lt;- 0
  repeat {
    Durchgaenge &lt;- Durchgaenge + 1
    x &lt;- sample (0:36, 1)
    Gewinn &lt;- if (is.element(x, z)) {
      if (identical(z, RED) | identical(z, BLACK) |
          identical(z, ODD) | identical(z, EVEN)) {
        y
      } else if (identical(z, firstThird) |
          identical(z, secondThird) |
          identical(z, lastThird)) {
        y * 2
      } else {
        y * 35
      }
    } else {
      -y
    }
  if(Durchgaenge == o) break
  }
}</code></pre>
<p>Ebenso wie bei der Funktion im ersten Abschnitt fehlt nun eine Ausgabe mit den wichtigen Informationen/Ergebnissen. Dazu können wir unsere Funktion nun um die Pausen und Nachrichten aus dem ersten Abschnitt erweitern.</p>
<pre class="r"><code>Roulette_Schleife &lt;- function (y, z, o) {
  Durchgaenge &lt;- 0
  repeat {
    Durchgaenge &lt;- Durchgaenge + 1
    x &lt;- sample (0:36, 1)
    Gewinn &lt;- if (is.element(x, z)) {
      if (identical(z, RED) | identical(z, BLACK) |
          identical(z, ODD) | identical(z, EVEN)) {
        y
      } else if (identical(z, firstThird) |
          identical(z, secondThird) |
          identical(z, lastThird)) {
        y * 2
      } else {
        y * 35
      }
    } else {
      -y
    }
    message (&quot;Roulettekugel startet&quot;)
    Sys.sleep (2.0)
    message (&quot;Rien ne va plus!&quot;)
    Sys.sleep (2.0)
    message (&quot;Es ist eine &quot;, x, &quot;.&quot;)
    Sys.sleep (2.0)
    if (is.element (x, z)) {
      message (&quot;Du hast gewonnen!&quot;)
      Sys.sleep (2.0)
      message (&quot;Dein Gewinn beträgt &quot;, Gewinn, &quot; Euro.&quot; )
      Sys.sleep (1.0)
    } else {
      message (&quot;Du hast verloren!&quot;)
      Sys.sleep (2.0)
      message (&quot;Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.&quot;)
      Sys.sleep (1.0)
    }
  if(Durchgaenge == o) break
  }
}</code></pre>
<p>Jetzt ist die Ausgabe schon um einiges schöner, doch einige relevante Informationen fehlen noch. In dieser Funktion besteht nämlich die Möglichkeit, mehrere Runden auf einmal zu spielen. Damit kann man noch zusätzlich Information zur aktuellen Runde und zum aktuellen Gesamtgewinn ausgeben.</p>
<p>Die Ausgabe des Gesamtgewinns gestaltet sich jedoch nicht so leicht wie die Rundenzahl, denn den Gesamtgewinn muss man jede Runde aufs Neue updaten. Das Prinzip für solche Operationen wurde bereits in einer vorherigen Aufgabe beschrieben. Bevor die Schleife beginnt erstellt man ein Objekt <code>Gesamtgewinn</code> beginnend mit der Null. In der Schleife nutzt man dann dieses Objekt und überschreibt diesen Wert jede Runde aufs Neue, indem man immer wieder den <code>Gewinn</code> aus der gerade laufenden Runde addiert. [Achtung: Die Nachricht zum Gesamtgewinn muss nach dieser erneuten Gesamtgewinn-Berechnung erfolgen, ansonsten gibt man jeweils den Gesamtgewinn nach der vorherigen Runde an.]</p>
<p>Nachdem man diese beiden Dinge impliziert hat, sieht die Funktion folgendermaßen aus:</p>
<pre class="r"><code>Roulette_Schleife &lt;- function (y, z, o) {
  Durchgaenge &lt;- 0
  Gesamtgewinn &lt;- 0
  repeat {
    Durchgaenge &lt;- Durchgaenge + 1
    message (&quot;Runde &quot;, Durchgaenge, &quot;!&quot;)
    x &lt;- sample (0:36, 1)
    Gewinn &lt;- if (is.element(x, z)) {
      if (identical(z, RED) | identical(z, BLACK) |
          identical(z, ODD) | identical(z, EVEN)) {
        y
      } else if (identical(z, firstThird) |
          identical(z, secondThird) |
          identical(z, lastThird)) {
        y * 2
      } else {
        y * 35
      }
    } else {
      -y
    }
    Gesamtgewinn &lt;- Gesamtgewinn + Gewinn
    message (&quot;Roulettekugel startet&quot;)
    Sys.sleep (2.0)
    message (&quot;Rien ne va plus!&quot;)
    Sys.sleep (2.0)
    message (&quot;Es ist eine &quot;, x, &quot;.&quot;)
    Sys.sleep (2.0)
    if (is.element (x, z)) {
      message (&quot;Du hast gewonnen!&quot;)
      Sys.sleep (2.0)
      message (&quot;Dein Gewinn beträgt &quot;, Gewinn, &quot; Euro.&quot; )
      Sys.sleep (1.0)
      message (&quot;Damit liegt dein Gesamtgewinn bisher bei &quot;, Gesamtgewinn, &quot; Euro.&quot;)
      Sys.sleep (1.0)
    } else {
      message (&quot;Du hast verloren!&quot;)
      Sys.sleep (2.0)
      message (&quot;Damit liegt dein Gesamtgewinn bisher bei &quot;, Gesamtgewinn, &quot; Euro.&quot;)
      Sys.sleep (1.0)
      message (&quot;Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.&quot;)
      Sys.sleep (1.0)
    }
  if(Durchgaenge == o) break
  }
}</code></pre>
<p>Insgesamt funktioniert die Funktion, jedoch endet das Spiel nun ganz abrupt ohne irgendeine abschließende Nachricht. Aus diesem Grund fügen wir nun noch mehrere Nachrichten ein:</p>
<ul>
<li>Eine Nachricht, dass die <code>o</code> Runden nun gespielt sind.</li>
<li>Eine Nachricht, die Einsatz, Wette und Rundenzahl noch einmal zusammenfasst und den daraus folgenden Gesamtgewinn beinhaltet.</li>
<li>Eine Nachricht, die vom Gesamtgewinn abhängt. (Ob Geld gewonnen oder verloren wurde oder ob am Ende bei Null rauskam, soll durch verschiedene Nachrichten angezeigt werden.)</li>
</ul>
<p>Das kann dann folgendermaßen aussehen:</p>
<pre class="r"><code>Roulette_Schleife &lt;- function (y, z, o) {
  Durchgaenge &lt;- 0
  Gesamtgewinn &lt;- 0
  repeat {
    Durchgaenge &lt;- Durchgaenge + 1
    message (&quot;Runde &quot;, Durchgaenge, &quot;!&quot;)
    x &lt;- sample (0:36, 1)
    Gewinn &lt;- if (is.element(x, z)) {
      if (identical(z, RED) | identical(z, BLACK) |
          identical(z, ODD) | identical(z, EVEN)) {
        y
      } else if (identical(z, firstThird) |
          identical(z, secondThird) |
          identical(z, lastThird)) {
        y * 2
      } else {
        y * 35
      }
    } else {
      -y
    }
    Gesamtgewinn &lt;- Gesamtgewinn + Gewinn
    message (&quot;Roulettekugel startet&quot;)
    Sys.sleep (2.0)
    message (&quot;Rien ne va plus!&quot;)
    Sys.sleep (2.0)
    message (&quot;Es ist eine &quot;, x, &quot;.&quot;)
    Sys.sleep (2.0)
    if (is.element (x, z)) {
      message (&quot;Du hast gewonnen!&quot;)
      Sys.sleep (2.0)
      message (&quot;Dein Gewinn beträgt &quot;, Gewinn, &quot; Euro.&quot; )
      Sys.sleep (1.0)
      message (&quot;Damit liegt dein Gesamtgewinn bisher bei &quot;, Gesamtgewinn, &quot; Euro.&quot;)
      Sys.sleep (1.0)
    } else {
      message (&quot;Du hast verloren!&quot;)
      Sys.sleep (2.0)
      message (&quot;Damit liegt dein Gesamtgewinn bisher bei &quot;, Gesamtgewinn, &quot; Euro.&quot;)
      Sys.sleep (1.0)
      message (&quot;Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.&quot;)
      Sys.sleep (1.0)
    }
  if(Durchgaenge == o) break
  }
  message (&quot;Deine &quot;, Durchgaenge, &quot; Runden sind durch.&quot;)
  Sys.sleep (3.0)
  message (&quot;Du hast heute in &quot;, Durchgaenge, &quot; Spielrunden jeweils mit einem Einsatz von &quot;, y, &quot; Euro auf &quot;, z, &quot; einen Gesamtgewinn von &quot;, Gesamtgewinn, &quot; Euro erzielt!&quot;)
  Sys.sleep (3.0)
  if (Gesamtgewinn &gt; 0) {
    message(&quot;Herzlichen Glueckwunsch!&quot;)
  } else if (Gesamtgewinn == 0) {
    message(&quot;Sie haben heute nichts gewonnen. Wollen Sie wirklich schon gehen?&quot;)
  } else {
    message(&quot;Schade. Aber seien Sie nicht traurig. Das nächste Mal steht das Glueck wieder auf Ihrer Seite!&quot;)
  }
}</code></pre>
<p>Hier seht ihr jetzt zwei Beispiele:</p>
<ul>
<li>Ein Mal wurden in 3 Runden jeweils 5 Euro auf BLACK gesetzt.</li>
<li>Ein Mal wurden in 4 Runden jeweils 100 Euro auf ODD gesetzt.</li>
</ul>
<pre class="r"><code>Roulette_Schleife(5, BLACK, 3)</code></pre>
<pre><code>## Runde 1!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 23.</code></pre>
<pre><code>## Du hast verloren!</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei -5 Euro.</code></pre>
<pre><code>## Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.</code></pre>
<pre><code>## Runde 2!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 5.</code></pre>
<pre><code>## Du hast verloren!</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei -10 Euro.</code></pre>
<pre><code>## Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.</code></pre>
<pre><code>## Runde 3!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 26.</code></pre>
<pre><code>## Du hast gewonnen!</code></pre>
<pre><code>## Dein Gewinn beträgt 5 Euro.</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei -5 Euro.</code></pre>
<pre><code>## Deine 3 Runden sind durch.</code></pre>
<pre><code>## Du hast heute in 3 Spielrunden jeweils mit einem Einsatz von 5 Euro auf 24681011131517202224262829313335 einen Gesamtgewinn von -5 Euro erzielt!</code></pre>
<pre><code>## Schade. Aber seien Sie nicht traurig. Das nächste Mal steht das Glueck wieder auf Ihrer Seite!</code></pre>
<pre class="r"><code>Roulette_Schleife(100, ODD, 4)</code></pre>
<pre><code>## Runde 1!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 2.</code></pre>
<pre><code>## Du hast verloren!</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei -100 Euro.</code></pre>
<pre><code>## Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.</code></pre>
<pre><code>## Runde 2!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 23.</code></pre>
<pre><code>## Du hast gewonnen!</code></pre>
<pre><code>## Dein Gewinn beträgt 100 Euro.</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei 0 Euro.</code></pre>
<pre><code>## Runde 3!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 26.</code></pre>
<pre><code>## Du hast verloren!</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei -100 Euro.</code></pre>
<pre><code>## Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.</code></pre>
<pre><code>## Runde 4!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 7.</code></pre>
<pre><code>## Du hast gewonnen!</code></pre>
<pre><code>## Dein Gewinn beträgt 100 Euro.</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei 0 Euro.</code></pre>
<pre><code>## Deine 4 Runden sind durch.</code></pre>
<pre><code>## Du hast heute in 4 Spielrunden jeweils mit einem Einsatz von 100 Euro auf 1357911131517192123252729313335 einen Gesamtgewinn von 0 Euro erzielt!</code></pre>
<pre><code>## Sie haben heute nichts gewonnen. Wollen Sie wirklich schon gehen?</code></pre>
</details>
</div>
