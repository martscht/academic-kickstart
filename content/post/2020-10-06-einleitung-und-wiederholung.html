---
title: Einleitung und Wiederholung
date: '2020-10-06'
slug: einleitung-und-wiederholung
categories:
  - MSc1
tags:
  - R Intro
subtitle: ''
summary: ''
authors: [irmer]
lastmod: '2020-10-06T16:40:21+02:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<div id="einleitung" class="section level2">
<h2>Einleitung</h2>
<p>Im Verlauf des Seminars <em>Forschungsmethoden und Evaluation I</em> soll neben der Einführung in die Theorie und Hintergründe multivariater Verfahren auch eine Einführung in deren Umsetzung gegeben werden, sodass Sie in der Lage sind, diese Verfahren in Ihrem zukünftigen akademischen und beruflichen Werdegang zu benutzen. <code>R</code> ist eine freie Software, die vor allem für (statistische) Datenanalysen verwendet wird. Bevor wir uns die Regressionsanalyse in <code>R</code> ansehen wollen, sollten Sie sich etwas mit <code>R</code> vertraut gemacht sowie die nötige Software (<code>R</code> als Programmiersprache und <code>R</code>-Studio als schöneres Interface) installiert haben. Hierzu eignet sich hervorragend der ebenfalls auf <a href="https://pandar.netlify.com/"><svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 640 512"><path d="M622.34 153.2L343.4 67.5c-15.2-4.67-31.6-4.67-46.79 0L17.66 153.2c-23.54 7.23-23.54 38.36 0 45.59l48.63 14.94c-10.67 13.19-17.23 29.28-17.88 46.9C38.78 266.15 32 276.11 32 288c0 10.78 5.68 19.85 13.86 25.65L20.33 428.53C18.11 438.52 25.71 448 35.94 448h56.11c10.24 0 17.84-9.48 15.62-19.47L82.14 313.65C90.32 307.85 96 298.78 96 288c0-11.57-6.47-21.25-15.66-26.87.76-15.02 8.44-28.3 20.69-36.72L296.6 284.5c9.06 2.78 26.44 6.25 46.79 0l278.95-85.7c23.55-7.24 23.55-38.36 0-45.6zM352.79 315.09c-28.53 8.76-52.84 3.92-65.59 0l-145.02-44.55L128 384c0 35.35 85.96 64 192 64s192-28.65 192-64l-14.18-113.47-145.03 44.56z"/></svg> Pandar</a> zu findende <a href="/post/r-crash-kurs"><svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 640 512"><path d="M622.34 153.2L343.4 67.5c-15.2-4.67-31.6-4.67-46.79 0L17.66 153.2c-23.54 7.23-23.54 38.36 0 45.59l48.63 14.94c-10.67 13.19-17.23 29.28-17.88 46.9C38.78 266.15 32 276.11 32 288c0 10.78 5.68 19.85 13.86 25.65L20.33 428.53C18.11 438.52 25.71 448 35.94 448h56.11c10.24 0 17.84-9.48 15.62-19.47L82.14 313.65C90.32 307.85 96 298.78 96 288c0-11.57-6.47-21.25-15.66-26.87.76-15.02 8.44-28.3 20.69-36.72L296.6 284.5c9.06 2.78 26.44 6.25 46.79 0l278.95-85.7c23.55-7.24 23.55-38.36 0-45.6zM352.79 315.09c-28.53 8.76-52.84 3.92-65.59 0l-145.02-44.55L128 384c0 35.35 85.96 64 192 64s192-28.65 192-64l-14.18-113.47-145.03 44.56z"/></svg><code>R</code>-Crash Kurs</a>. Dort gibt es die Intro und Installationsanweisung sowohl in deutscher als auch in englischer Sprache. <em>Wir gehen davon aus, dass Sie diese durchgearbeitetet haben und schauen uns als Einführung zunächst ein paar zentrale Befehle für das Dateneinlesen und -verarbeiten noch einmal an.</em></p>
<p>Nach dem Ende der Übung finden Sie in dem zu dieser Veranstaltung gehörenden OLAT Kurs Aufgaben (ein Quiz), die die Inhalte dieser Sitzung ergänzen.</p>
</div>
<div id="daten-einlesen-und-verarbeiten" class="section level2">
<h2>Daten einlesen und verarbeiten</h2>
<p>Falls Sie an der Goehte-Universität studiert haben, kennen Sie den Datensatz, den wir in dieser Sitzung untersuchen wollen, vielleicht aus dem Bachelorstudium: Eine Stichprobe von 100 Schülerinnen und Schülern hat einen Lese- und einen Mathematiktest, sowie zusätzlich einen allgemeinen Intelligenztest, bearbeitet. Im Datensatz enthalten ist zudem das Geschlecht (<code>female</code>, 0=m, 1=w). Sie können den <a href="/post/Schulleistungen.rda"><svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 512 512"><path d="M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z"/></svg> Datensatz “Schulleistungen.rda” hier herunterladen</a>.</p>
<div id="daten-laden" class="section level3">
<h3>Daten laden</h3>
<p>Der Datensatz ist im <code>R</code>-internen “.rda” Format abgepeichert - einem datensatzspezifisichen Dateiformat. Wir können diesen Datensatz einfach mit der <code>load</code> Funktion laden. Wir müssen <code>R</code> nur mitteilen, wo der Datensatz liegt und è vola, er wird uns zur Verfügung gestellt. Liegt der Datensatz bspw. auf dem Desktop, so müssen wir den Dateipfad dorthin legen und können dann den Datensatz laden (wir gehen hier davon aus, dass Ihr PC “Musterfrau” heißt):</p>
<pre class="r"><code>load(&quot;C:/Users/Musterfrau/Desktop/Schulleistungen.rda&quot;)</code></pre>
<p>Nun sollte in <code>R</code>-Studio oben rechts in dem Fenster unter der Rubrik “Data” unser Datensatz mit dem Namen “<em>Schulleistungen</em>” erscheinen.</p>
<p>Bei Dateipfaden ist darauf zu achten, dass bei Linux <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 448 512"><path d="M220.8 123.3c1 .5 1.8 1.7 3 1.7 1.1 0 2.8-.4 2.9-1.5.2-1.4-1.9-2.3-3.2-2.9-1.7-.7-3.9-1-5.5-.1-.4.2-.8.7-.6 1.1.3 1.3 2.3 1.1 3.4 1.7zm-21.9 1.7c1.2 0 2-1.2 3-1.7 1.1-.6 3.1-.4 3.5-1.6.2-.4-.2-.9-.6-1.1-1.6-.9-3.8-.6-5.5.1-1.3.6-3.4 1.5-3.2 2.9.1 1 1.8 1.5 2.8 1.4zM420 403.8c-3.6-4-5.3-11.6-7.2-19.7-1.8-8.1-3.9-16.8-10.5-22.4-1.3-1.1-2.6-2.1-4-2.9-1.3-.8-2.7-1.5-4.1-2 9.2-27.3 5.6-54.5-3.7-79.1-11.4-30.1-31.3-56.4-46.5-74.4-17.1-21.5-33.7-41.9-33.4-72C311.1 85.4 315.7.1 234.8 0 132.4-.2 158 103.4 156.9 135.2c-1.7 23.4-6.4 41.8-22.5 64.7-18.9 22.5-45.5 58.8-58.1 96.7-6 17.9-8.8 36.1-6.2 53.3-6.5 5.8-11.4 14.7-16.6 20.2-4.2 4.3-10.3 5.9-17 8.3s-14 6-18.5 14.5c-2.1 3.9-2.8 8.1-2.8 12.4 0 3.9.6 7.9 1.2 11.8 1.2 8.1 2.5 15.7.8 20.8-5.2 14.4-5.9 24.4-2.2 31.7 3.8 7.3 11.4 10.5 20.1 12.3 17.3 3.6 40.8 2.7 59.3 12.5 19.8 10.4 39.9 14.1 55.9 10.4 11.6-2.6 21.1-9.6 25.9-20.2 12.5-.1 26.3-5.4 48.3-6.6 14.9-1.2 33.6 5.3 55.1 4.1.6 2.3 1.4 4.6 2.5 6.7v.1c8.3 16.7 23.8 24.3 40.3 23 16.6-1.3 34.1-11 48.3-27.9 13.6-16.4 36-23.2 50.9-32.2 7.4-4.5 13.4-10.1 13.9-18.3.4-8.2-4.4-17.3-15.5-29.7zM223.7 87.3c9.8-22.2 34.2-21.8 44-.4 6.5 14.2 3.6 30.9-4.3 40.4-1.6-.8-5.9-2.6-12.6-4.9 1.1-1.2 3.1-2.7 3.9-4.6 4.8-11.8-.2-27-9.1-27.3-7.3-.5-13.9 10.8-11.8 23-4.1-2-9.4-3.5-13-4.4-1-6.9-.3-14.6 2.9-21.8zM183 75.8c10.1 0 20.8 14.2 19.1 33.5-3.5 1-7.1 2.5-10.2 4.6 1.2-8.9-3.3-20.1-9.6-19.6-8.4.7-9.8 21.2-1.8 28.1 1 .8 1.9-.2-5.9 5.5-15.6-14.6-10.5-52.1 8.4-52.1zm-13.6 60.7c6.2-4.6 13.6-10 14.1-10.5 4.7-4.4 13.5-14.2 27.9-14.2 7.1 0 15.6 2.3 25.9 8.9 6.3 4.1 11.3 4.4 22.6 9.3 8.4 3.5 13.7 9.7 10.5 18.2-2.6 7.1-11 14.4-22.7 18.1-11.1 3.6-19.8 16-38.2 14.9-3.9-.2-7-1-9.6-2.1-8-3.5-12.2-10.4-20-15-8.6-4.8-13.2-10.4-14.7-15.3-1.4-4.9 0-9 4.2-12.3zm3.3 334c-2.7 35.1-43.9 34.4-75.3 18-29.9-15.8-68.6-6.5-76.5-21.9-2.4-4.7-2.4-12.7 2.6-26.4v-.2c2.4-7.6.6-16-.6-23.9-1.2-7.8-1.8-15 .9-20 3.5-6.7 8.5-9.1 14.8-11.3 10.3-3.7 11.8-3.4 19.6-9.9 5.5-5.7 9.5-12.9 14.3-18 5.1-5.5 10-8.1 17.7-6.9 8.1 1.2 15.1 6.8 21.9 16l19.6 35.6c9.5 19.9 43.1 48.4 41 68.9zm-1.4-25.9c-4.1-6.6-9.6-13.6-14.4-19.6 7.1 0 14.2-2.2 16.7-8.9 2.3-6.2 0-14.9-7.4-24.9-13.5-18.2-38.3-32.5-38.3-32.5-13.5-8.4-21.1-18.7-24.6-29.9s-3-23.3-.3-35.2c5.2-22.9 18.6-45.2 27.2-59.2 2.3-1.7.8 3.2-8.7 20.8-8.5 16.1-24.4 53.3-2.6 82.4.6-20.7 5.5-41.8 13.8-61.5 12-27.4 37.3-74.9 39.3-112.7 1.1.8 4.6 3.2 6.2 4.1 4.6 2.7 8.1 6.7 12.6 10.3 12.4 10 28.5 9.2 42.4 1.2 6.2-3.5 11.2-7.5 15.9-9 9.9-3.1 17.8-8.6 22.3-15 7.7 30.4 25.7 74.3 37.2 95.7 6.1 11.4 18.3 35.5 23.6 64.6 3.3-.1 7 .4 10.9 1.4 13.8-35.7-11.7-74.2-23.3-84.9-4.7-4.6-4.9-6.6-2.6-6.5 12.6 11.2 29.2 33.7 35.2 59 2.8 11.6 3.3 23.7.4 35.7 16.4 6.8 35.9 17.9 30.7 34.8-2.2-.1-3.2 0-4.2 0 3.2-10.1-3.9-17.6-22.8-26.1-19.6-8.6-36-8.6-38.3 12.5-12.1 4.2-18.3 14.7-21.4 27.3-2.8 11.2-3.6 24.7-4.4 39.9-.5 7.7-3.6 18-6.8 29-32.1 22.9-76.7 32.9-114.3 7.2zm257.4-11.5c-.9 16.8-41.2 19.9-63.2 46.5-13.2 15.7-29.4 24.4-43.6 25.5s-26.5-4.8-33.7-19.3c-4.7-11.1-2.4-23.1 1.1-36.3 3.7-14.2 9.2-28.8 9.9-40.6.8-15.2 1.7-28.5 4.2-38.7 2.6-10.3 6.6-17.2 13.7-21.1.3-.2.7-.3 1-.5.8 13.2 7.3 26.6 18.8 29.5 12.6 3.3 30.7-7.5 38.4-16.3 9-.3 15.7-.9 22.6 5.1 9.9 8.5 7.1 30.3 17.1 41.6 10.6 11.6 14 19.5 13.7 24.6zM173.3 148.7c2 1.9 4.7 4.5 8 7.1 6.6 5.2 15.8 10.6 27.3 10.6 11.6 0 22.5-5.9 31.8-10.8 4.9-2.6 10.9-7 14.8-10.4s5.9-6.3 3.1-6.6-2.6 2.6-6 5.1c-4.4 3.2-9.7 7.4-13.9 9.8-7.4 4.2-19.5 10.2-29.9 10.2s-18.7-4.8-24.9-9.7c-3.1-2.5-5.7-5-7.7-6.9-1.5-1.4-1.9-4.6-4.3-4.9-1.4-.1-1.8 3.7 1.7 6.5z"/></svg> oder Mac OS Rechnern <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 384 512"><path d="M318.7 268.7c-.2-36.7 16.4-64.4 50-84.8-18.8-26.9-47.2-41.7-84.7-44.6-35.5-2.8-74.3 20.7-88.5 20.7-15 0-49.4-19.7-76.4-19.7C63.3 141.2 4 184.8 4 273.5q0 39.3 14.4 81.2c12.8 36.7 59 126.7 107.2 125.2 25.2-.6 43-17.9 75.8-17.9 31.8 0 48.3 17.9 76.4 17.9 48.6-.7 90.4-82.5 102.6-119.3-65.2-30.7-61.7-90-61.7-91.9zm-56.6-164.2c27.3-32.4 24.8-61.9 24-72.5-24.1 1.4-52 16.4-67.9 34.9-17.5 19.8-27.8 44.3-25.6 71.9 26.1 2 49.9-11.4 69.5-34.3z"/></svg> immer Front-Slashes (“/”) zum Anzeigen von Hierarchien zwischen Ordnern verwendet werden, während auf Windows Rechnern <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 448 512"><path d="M0 93.7l183.6-25.3v177.4H0V93.7zm0 324.6l183.6 25.3V268.4H0v149.9zm203.8 28L448 480V268.4H203.8v177.9zm0-380.6v180.1H448V32L203.8 65.7z"/></svg> im System aber bei Dateipfaden mit Back-Slashes gearbeitet wird (“\”). <code>R</code> nutzt auf Windows Rechnern <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 448 512"><path d="M0 93.7l183.6-25.3v177.4H0V93.7zm0 324.6l183.6 25.3V268.4H0v149.9zm203.8 28L448 480V268.4H203.8v177.9zm0-380.6v180.1H448V32L203.8 65.7z"/></svg> ebenfalls Front-Slashes (“/”). Das bedeutet, dass, wenn wir auf Windows Rechnern <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 448 512"><path d="M0 93.7l183.6-25.3v177.4H0V93.7zm0 324.6l183.6 25.3V268.4H0v149.9zm203.8 28L448 480V268.4H203.8v177.9zm0-380.6v180.1H448V32L203.8 65.7z"/></svg> den Dateipfad aus dem Explorer kopieren, wir die Slashes “umdrehen” müssen.</p>
<p>Genauso sind Sie in der Lage den Datensatz direkt aus dem Internet zu laden. Hierzu brauchen Sie nur die URL und müssen <code>R</code> sagen, dass es sich bei dieser um eine URL handelt, indem Sie die Funktion <code>url</code> auf den Link anwenden. Der funktioniernde Befehl sieht so aus (wobei die URL in Anführungszeichen geschrieben werden muss):</p>
<pre class="r"><code>load(url(&quot;https://pandar.netlify.app/post/Schulleistungen.rda&quot;))</code></pre>
</div>
<div id="ein-überblick-über-die-daten" class="section level3">
<h3>Ein Überblick über die Daten</h3>
<p>Wir können uns die ersten (6) Zeilen des Datensatzes mit der Funktion <code>head</code> ansehen. Dazu müssen wir diese Funktion auf den Datensatz (das Objekt) <code>Schulleistungen</code> anwenden:</p>
<pre class="r"><code>head(Schulleistungen)</code></pre>
<pre><code>##   female        IQ  reading     math
## 1      1  81.77950 449.5884 451.9832
## 2      1 106.75898 544.8495 589.6540
## 3      0  99.14033 331.3466 509.3267
## 4      1 111.91499 531.5384 560.4300
## 5      1 116.12682 604.3759 659.4524
## 6      0 106.14127 308.7457 602.8577</code></pre>
<p>Wir erkennen die 4 Spalten mit dem Geschlecht, dem IQ, der Lese- und der Mathematikleistung. &lt;mark style=&quot;background-color: Außerdem sehen wir, dass die Variablen mit den Namen <code>IQ</code>, <code>reading</code> und <code>math</code> einige Dezimalstellen aufweisen, was daran liegt, dass diese Daten simuliert wurden (allerdings echten Daten nachempfunden sind). Da es sich bei unserem Datensatz um ein Objekt vom Typ <code>data.frame</code> handelt, können wir die Variablennamen des Datensatzes außerdem mit der <code>names</code> Funktion abfragen. Weitere interessante Funktionen sind die <code>nrow</code> und <code>ncol</code> Funktion, die, wie Sie sich sicher schon gedacht haben, die Zeilen- und die Spaltenanzahl widergeben (wir könnten auch <code>dim</code> verwenden, was diese beiden Informationen auf einmal ausgibt).</p>
<pre class="r"><code># Namen der Variablen abfragen
names(Schulleistungen)</code></pre>
<pre><code>## [1] &quot;female&quot;  &quot;IQ&quot;      &quot;reading&quot; &quot;math&quot;</code></pre>
<pre class="r"><code># Anzahl der Zeilen
nrow(Schulleistungen)</code></pre>
<pre><code>## [1] 100</code></pre>
<pre class="r"><code># Anzahl der Spalten
ncol(Schulleistungen)</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code># Anzahl der Zeilen und Spalten kombiniert
dim(Schulleistungen)</code></pre>
<pre><code>## [1] 100   4</code></pre>
<pre class="r"><code># Struktur des Datensatzes - Informationen zu Variablentypen
str(Schulleistungen)</code></pre>
<pre><code>## &#39;data.frame&#39;:    100 obs. of  4 variables:
##  $ female : num  1 1 0 1 1 0 1 1 1 1 ...
##  $ IQ     : num  81.8 106.8 99.1 111.9 116.1 ...
##  $ reading: num  450 545 331 532 604 ...
##  $ math   : num  452 590 509 560 659 ...</code></pre>
<p>Wir entnehmen dem Output, dass die Variablen im Datensatz <code>female</code>, <code>IQ</code>, <code>reading</code> und <code>math</code> heißen, dass es insgesamt <span class="math inline">\(n = 100\)</span> Schulkinder zu 4 Merkmalen befragt/untersucht wurden und dass alle diese Variablen “<em>numerisch</em>”, also als Zahlen, vorliegen. Eine einzelne Variable eines Datensatzes (vom Typ <code>data.frame</code>) können wir ansprechen, indem wir hinter den Datensatz <code>$</code> schreiben und anschließend den Variablennamen. Zugriff auf den <code>IQ</code> der Kinder erhalten wir mit:</p>
<pre class="r"><code>Schulleistungen$IQ</code></pre>
<pre><code>##   [1]  81.77950 106.75898  99.14033 111.91499 116.12682 106.14127  85.44854
##   [8]  93.24323 135.19738  89.90152  92.72073 115.90123 114.54088  83.28294
##  [15] 126.41670 107.20436  90.03418  98.34044 117.06874 115.55140  68.11351
##  [22] 125.64776  93.34804 106.93651  98.78466  78.93267 113.05378  92.86905
##  [29]  86.44483  70.17249 111.44613  93.78654  87.54754  87.01957  69.32581
##  [36]  92.85801  70.56712  74.17486 105.61195 110.63901  91.54624 105.73141
##  [43] 125.26215 101.14873 111.09582  79.99545  84.45429  84.50532  96.60821
##  [50] 103.90556  81.03395 126.12813  89.47650  80.78064 106.48847 103.58060
##  [57]  84.88878 115.90930  97.28407  91.60586 121.77877 110.26187 100.32137
##  [64] 112.65157 122.84032  96.45124  75.48471  91.27550 111.85776  92.72890
##  [71]  76.84326  92.93814 103.25579  81.15462  92.27190 106.40950  96.70280
##  [78] 104.06385 107.98499  60.76781  94.55947 103.55973 101.83276 113.06302
##  [85]  76.56824  97.56684 104.28662 106.08550 120.97759  82.65717 108.41181
##  [92] 103.38963 100.59534 122.79791  97.91853  92.96729  77.51862 105.01989
##  [99]  54.05485 106.12641</code></pre>
<p><em><strong>Tipp:</strong> In <code>R</code>-Studio können Sie sich Ihren Umgang mit der Software in vielen Dingen vereinfachen, indem Sie die automatische Vervollständigung der Software nutzen. Dies tun Sie, indem Sie bspw. <code>Schulleistungen$</code> tippen und dann den Tabulator [oder “Strg” + “Leertaste” auf Windows <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 448 512"><path d="M0 93.7l183.6-25.3v177.4H0V93.7zm0 324.6l183.6 25.3V268.4H0v149.9zm203.8 28L448 480V268.4H203.8v177.9zm0-380.6v180.1H448V32L203.8 65.7z"/></svg> oder Linux Rechner <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 448 512"><path d="M220.8 123.3c1 .5 1.8 1.7 3 1.7 1.1 0 2.8-.4 2.9-1.5.2-1.4-1.9-2.3-3.2-2.9-1.7-.7-3.9-1-5.5-.1-.4.2-.8.7-.6 1.1.3 1.3 2.3 1.1 3.4 1.7zm-21.9 1.7c1.2 0 2-1.2 3-1.7 1.1-.6 3.1-.4 3.5-1.6.2-.4-.2-.9-.6-1.1-1.6-.9-3.8-.6-5.5.1-1.3.6-3.4 1.5-3.2 2.9.1 1 1.8 1.5 2.8 1.4zM420 403.8c-3.6-4-5.3-11.6-7.2-19.7-1.8-8.1-3.9-16.8-10.5-22.4-1.3-1.1-2.6-2.1-4-2.9-1.3-.8-2.7-1.5-4.1-2 9.2-27.3 5.6-54.5-3.7-79.1-11.4-30.1-31.3-56.4-46.5-74.4-17.1-21.5-33.7-41.9-33.4-72C311.1 85.4 315.7.1 234.8 0 132.4-.2 158 103.4 156.9 135.2c-1.7 23.4-6.4 41.8-22.5 64.7-18.9 22.5-45.5 58.8-58.1 96.7-6 17.9-8.8 36.1-6.2 53.3-6.5 5.8-11.4 14.7-16.6 20.2-4.2 4.3-10.3 5.9-17 8.3s-14 6-18.5 14.5c-2.1 3.9-2.8 8.1-2.8 12.4 0 3.9.6 7.9 1.2 11.8 1.2 8.1 2.5 15.7.8 20.8-5.2 14.4-5.9 24.4-2.2 31.7 3.8 7.3 11.4 10.5 20.1 12.3 17.3 3.6 40.8 2.7 59.3 12.5 19.8 10.4 39.9 14.1 55.9 10.4 11.6-2.6 21.1-9.6 25.9-20.2 12.5-.1 26.3-5.4 48.3-6.6 14.9-1.2 33.6 5.3 55.1 4.1.6 2.3 1.4 4.6 2.5 6.7v.1c8.3 16.7 23.8 24.3 40.3 23 16.6-1.3 34.1-11 48.3-27.9 13.6-16.4 36-23.2 50.9-32.2 7.4-4.5 13.4-10.1 13.9-18.3.4-8.2-4.4-17.3-15.5-29.7zM223.7 87.3c9.8-22.2 34.2-21.8 44-.4 6.5 14.2 3.6 30.9-4.3 40.4-1.6-.8-5.9-2.6-12.6-4.9 1.1-1.2 3.1-2.7 3.9-4.6 4.8-11.8-.2-27-9.1-27.3-7.3-.5-13.9 10.8-11.8 23-4.1-2-9.4-3.5-13-4.4-1-6.9-.3-14.6 2.9-21.8zM183 75.8c10.1 0 20.8 14.2 19.1 33.5-3.5 1-7.1 2.5-10.2 4.6 1.2-8.9-3.3-20.1-9.6-19.6-8.4.7-9.8 21.2-1.8 28.1 1 .8 1.9-.2-5.9 5.5-15.6-14.6-10.5-52.1 8.4-52.1zm-13.6 60.7c6.2-4.6 13.6-10 14.1-10.5 4.7-4.4 13.5-14.2 27.9-14.2 7.1 0 15.6 2.3 25.9 8.9 6.3 4.1 11.3 4.4 22.6 9.3 8.4 3.5 13.7 9.7 10.5 18.2-2.6 7.1-11 14.4-22.7 18.1-11.1 3.6-19.8 16-38.2 14.9-3.9-.2-7-1-9.6-2.1-8-3.5-12.2-10.4-20-15-8.6-4.8-13.2-10.4-14.7-15.3-1.4-4.9 0-9 4.2-12.3zm3.3 334c-2.7 35.1-43.9 34.4-75.3 18-29.9-15.8-68.6-6.5-76.5-21.9-2.4-4.7-2.4-12.7 2.6-26.4v-.2c2.4-7.6.6-16-.6-23.9-1.2-7.8-1.8-15 .9-20 3.5-6.7 8.5-9.1 14.8-11.3 10.3-3.7 11.8-3.4 19.6-9.9 5.5-5.7 9.5-12.9 14.3-18 5.1-5.5 10-8.1 17.7-6.9 8.1 1.2 15.1 6.8 21.9 16l19.6 35.6c9.5 19.9 43.1 48.4 41 68.9zm-1.4-25.9c-4.1-6.6-9.6-13.6-14.4-19.6 7.1 0 14.2-2.2 16.7-8.9 2.3-6.2 0-14.9-7.4-24.9-13.5-18.2-38.3-32.5-38.3-32.5-13.5-8.4-21.1-18.7-24.6-29.9s-3-23.3-.3-35.2c5.2-22.9 18.6-45.2 27.2-59.2 2.3-1.7.8 3.2-8.7 20.8-8.5 16.1-24.4 53.3-2.6 82.4.6-20.7 5.5-41.8 13.8-61.5 12-27.4 37.3-74.9 39.3-112.7 1.1.8 4.6 3.2 6.2 4.1 4.6 2.7 8.1 6.7 12.6 10.3 12.4 10 28.5 9.2 42.4 1.2 6.2-3.5 11.2-7.5 15.9-9 9.9-3.1 17.8-8.6 22.3-15 7.7 30.4 25.7 74.3 37.2 95.7 6.1 11.4 18.3 35.5 23.6 64.6 3.3-.1 7 .4 10.9 1.4 13.8-35.7-11.7-74.2-23.3-84.9-4.7-4.6-4.9-6.6-2.6-6.5 12.6 11.2 29.2 33.7 35.2 59 2.8 11.6 3.3 23.7.4 35.7 16.4 6.8 35.9 17.9 30.7 34.8-2.2-.1-3.2 0-4.2 0 3.2-10.1-3.9-17.6-22.8-26.1-19.6-8.6-36-8.6-38.3 12.5-12.1 4.2-18.3 14.7-21.4 27.3-2.8 11.2-3.6 24.7-4.4 39.9-.5 7.7-3.6 18-6.8 29-32.1 22.9-76.7 32.9-114.3 7.2zm257.4-11.5c-.9 16.8-41.2 19.9-63.2 46.5-13.2 15.7-29.4 24.4-43.6 25.5s-26.5-4.8-33.7-19.3c-4.7-11.1-2.4-23.1 1.1-36.3 3.7-14.2 9.2-28.8 9.9-40.6.8-15.2 1.7-28.5 4.2-38.7 2.6-10.3 6.6-17.2 13.7-21.1.3-.2.7-.3 1-.5.8 13.2 7.3 26.6 18.8 29.5 12.6 3.3 30.7-7.5 38.4-16.3 9-.3 15.7-.9 22.6 5.1 9.9 8.5 7.1 30.3 17.1 41.6 10.6 11.6 14 19.5 13.7 24.6zM173.3 148.7c2 1.9 4.7 4.5 8 7.1 6.6 5.2 15.8 10.6 27.3 10.6 11.6 0 22.5-5.9 31.8-10.8 4.9-2.6 10.9-7 14.8-10.4s5.9-6.3 3.1-6.6-2.6 2.6-6 5.1c-4.4 3.2-9.7 7.4-13.9 9.8-7.4 4.2-19.5 10.2-29.9 10.2s-18.7-4.8-24.9-9.7c-3.1-2.5-5.7-5-7.7-6.9-1.5-1.4-1.9-4.6-4.3-4.9-1.4-.1-1.8 3.7 1.7 6.5z"/></svg> oder “Control” + “Leertaste” auf Mac OS Rechnern <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 384 512"><path d="M318.7 268.7c-.2-36.7 16.4-64.4 50-84.8-18.8-26.9-47.2-41.7-84.7-44.6-35.5-2.8-74.3 20.7-88.5 20.7-15 0-49.4-19.7-76.4-19.7C63.3 141.2 4 184.8 4 273.5q0 39.3 14.4 81.2c12.8 36.7 59 126.7 107.2 125.2 25.2-.6 43-17.9 75.8-17.9 31.8 0 48.3 17.9 76.4 17.9 48.6-.7 90.4-82.5 102.6-119.3-65.2-30.7-61.7-90-61.7-91.9zm-56.6-164.2c27.3-32.4 24.8-61.9 24-72.5-24.1 1.4-52 16.4-67.9 34.9-17.5 19.8-27.8 44.3-25.6 71.9 26.1 2 49.9-11.4 69.5-34.3z"/></svg>] auf Ihrer Tastatur drücken. Ihnen werden dann Vorschläge für mögliche Argumente aufgezeigt. Das gleiche funktioniert auch in Funktionen. Hier müssen Sie zunächst den Funktionnamen schreiben und die Klammern öffnen. Mit dem Tabulator erhalten Sie anschließend Vorschläge für mögliche Argumente, die Sie der Funktion übergeben können. Schauen Sie sich dies doch einmal an! Dies funktioniert übrigens auch für das Vervollständigen von Dateipfaden. Hierbei muss allerdings darauf geachtet werden, dass diese in Anführungsstrichen geschrieben werden und Sie müssen beachten, wo ihr aktuelles Working-Directory liegt. Sie können allerdings auch den vollständigen Pfad eingeben, indem Sie auf Windows PCs <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 448 512"><path d="M0 93.7l183.6-25.3v177.4H0V93.7zm0 324.6l183.6 25.3V268.4H0v149.9zm203.8 28L448 480V268.4H203.8v177.9zm0-380.6v180.1H448V32L203.8 65.7z"/></svg> mit “C:/Users/” und auf Mac OS Rechnern <svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 384 512"><path d="M318.7 268.7c-.2-36.7 16.4-64.4 50-84.8-18.8-26.9-47.2-41.7-84.7-44.6-35.5-2.8-74.3 20.7-88.5 20.7-15 0-49.4-19.7-76.4-19.7C63.3 141.2 4 184.8 4 273.5q0 39.3 14.4 81.2c12.8 36.7 59 126.7 107.2 125.2 25.2-.6 43-17.9 75.8-17.9 31.8 0 48.3 17.9 76.4 17.9 48.6-.7 90.4-82.5 102.6-119.3-65.2-30.7-61.7-90-61.7-91.9zm-56.6-164.2c27.3-32.4 24.8-61.9 24-72.5-24.1 1.4-52 16.4-67.9 34.9-17.5 19.8-27.8 44.3-25.6 71.9 26.1 2 49.9-11.4 69.5-34.3z"/></svg> mit “/Users/” beginnen und dann den Tabulator drücken und den jeweilig richtigen Ordner auswählen, bis Sie an Ihrer Zieldatei angekommen sind!</em></p>
</div>
<div id="einfache-deskriptivstatistiken" class="section level3">
<h3>Einfache Deskriptivstatistiken</h3>
<p>Bevor wir jetzt direkt zu komplexeren Analysen springen, wollen wir uns noch schnell mit dem Bestimmen einfacher deskriptivstatistischer Größen vertraut machen. Mit der Funktion <code>sum</code> können wir die Summe und mit <code>mean</code> können wir den Mittelwert einer Variable bestimmen. Eine Schätzung für die Populationsvarianz erhalten wir mit <code>var</code>. Die zugehörige Populationsschätzung für die Standardabweichung, Sie vermuten es vielleicht, erhalten wir mit <code>sd</code>. <em>Es handelt sich hierbei um Populations- und nicht um Stichprobenschätzungen, da in diesen Funktionen der Vorfaktor <span class="math inline">\(\frac{1}{n-1}\)</span> genutzt wird, um einen unverzerrten Schätzer für eben die Variation in der Population zu erhalten (für mehr Informationen siehe bspw. <a href="https://hds.hebis.de/ubffm/Record/HEB366849158">Eid, Gollwitzer und Schmitt, 2017</a>, S. 162-163 in Kapitel 6.4.4 und S. 246-247 in Kapitel 8.5.1 oder <a href="https://hds.hebis.de/ubffm/Record/HEB369761391">Agresti, &amp; Finlay, 2013</a>, Kapitel 3.2 und folgend).</em></p>
<pre class="r"><code># Summe
sum(Schulleistungen$IQ)</code></pre>
<pre><code>## [1] 9813.425</code></pre>
<pre class="r"><code># Mittelwert
mean(Schulleistungen$IQ)</code></pre>
<pre><code>## [1] 98.13425</code></pre>
<pre class="r"><code>1/100*sum(Schulleistungen$IQ) # auch der Mittelwert</code></pre>
<pre><code>## [1] 98.13425</code></pre>
<pre class="r"><code># Varianz
var(Schulleistungen$IQ)</code></pre>
<pre><code>## [1] 248.1075</code></pre>
<pre class="r"><code># SD
sd(Schulleistungen$IQ)</code></pre>
<pre><code>## [1] 15.75143</code></pre>
<pre class="r"><code>sqrt(var(Schulleistungen$IQ)) # die Wurzel aus der Varianz ist die SD, hier: sqrt() ist die Wurzel Funktion</code></pre>
<pre><code>## [1] 15.75143</code></pre>
<p>Mit <code>summary</code> können wir uns die Zusammenfassung einer Variable ansehen.</p>
<pre class="r"><code>summary(Schulleistungen$IQ)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   54.05   87.42   98.56   98.13  108.09  135.20</code></pre>
<p>Als Ausgabe erhalten wir den kleinsten Wert 54.05 (das Minimum, welches hier bspw. auf 2 Nachkommastellen gerunden ist; Originalwert = 54.0548457), das erste Quartil 87.42, also den 25.-Prozentrang (25% PR), den Median 98.56 (2. Quartil; 50% PR), den Mittelwert 98.13, das 3. Quartil 108.09 (75% PR) und den größten Wert 135.2 (Maximum). Wenden wir diese Funktion auf ein <code>R</code>-Objekt an, so gibt uns diese eine Zusammenfassung dieses Objekts aus, was häufig auch einfach die Zusammenfassung einer Analyse ist. Dies schauen wir uns später nochmals genauer an.</p>
<p>Als letztes gucken wir uns noch den Befehl <code>colMeans</code> an, welcher Mittelwerte eines Datensatzes über die Spalten (also pro Variable über alle Personen) bestimmt. Somit lassen sich ganz einfach für alle Variablen eines Datensatzes auf einmal die Mittelwerte bestimmen (<code>rowMeans</code> bestimmt, wie Sie sich wahrscheinlich denken, die Mittelwerte pro Zeile, also die Mittelwerte über alle Variablen pro Person):</p>
<pre class="r"><code>colMeans(Schulleistungen)</code></pre>
<pre><code>##    female        IQ   reading      math 
##   0.54000  98.13425 496.06605 561.46446</code></pre>
<p>Da <code>female</code> 0-1 kodiert ist und <code>1</code> für Mädchen steht, bedeutet die hier beobachtete Zahl von .54, dass gerade ca. 54% der ProbandInnen weiblich waren.</p>
</div>
</div>
<div id="der-t-test" class="section level2">
<h2>Der <span class="math inline">\(t\)</span>-Test</h2>
<p>Ein sehr einfacher statistischer Test, ist der <span class="math inline">\(t\)</span>-Test (für eine Wiederholung siehe bspw. <a href="https://hds.hebis.de/ubffm/Record/HEB366849158">Eid, et al., 2017</a>, Kapitel 11.1 oder <a href="https://hds.hebis.de/ubffm/Record/HEB369761391">Agresti, &amp; Finlay, 2013,</a> Kapitel 6.2 und folgend). Mit Hilfe dieses Tests soll untersucht werden, ob die Mittelwerte in zwei Gruppen gleich sind. Dazu brauchen wir drei wichtige Annahmen: 1) die Beobachtungen stammen aus einer <em>independent and identically distributed</em> (i.i.d., deutsch: unabhängig und identisch verteilt) Population (dies bedeutet, dass alle Beobachtungen unabhängig sind und den gleichen Verteilungs- und Modellannahmen unterleigen), 2) die Daten in beiden Gruppen sind normalverteilt mit 3) gleicher Varianz (Varianzhomogenität). Die 1. Annahme ist sehr kritisch und lässt sich leider nicht prüfen. Für die anderen beiden Annahmen gibt es verschiedene Tests und deskriptive Verfahren, um ein Gefühl für ihr Vorliegen zu erhalten - diese schauen wir uns in der nächsten Sitzung zur Regression an. Unter diesen Annahmen stellen wir die folgenden Null-Hypothese auf - die Gleichheit der Mittelwerte in den beiden Gruppen:
<span class="math display">\[H_0: \mu_1=\mu_2\]</span>
Diese Hypothese gilt nicht, wenn <span class="math inline">\(\mu_1\neq\mu_2\)</span>. In diesem Fall gilt irgendeine Alternativhypothese (<span class="math inline">\(H_1\)</span>) mit einer Mittelwertsdifferenz <span class="math inline">\(d=\mu_1-\mu_2\)</span>, die nicht Null ist <span class="math inline">\((\neq0)\)</span>. Wir sprechen hier von einer Alternativhypothese, da in der (frequentistischen) Statistik immer ein fester Wert für die Population angenommen werden muss, welcher, wenn die <span class="math inline">\(H_0\)</span> nicht gilt, eine feste Differenz <span class="math inline">\(d\)</span> für die Mittelwerte annimmt.</p>
<div id="simulieren-von-daten" class="section level3">
<h3>Simulieren von Daten</h3>
<p>Wir können in <code>R</code> auch Daten simulieren. Bspw. erzeugt der Befehl <code>rnorm</code> normalverteile Zufallsvariablen. Für weitere Informationen siehe bspw. <a href="https://en.wikibooks.org/wiki/R_Programming/Probability_Distributions"><svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 640 512"><path d="M622.34 153.2L343.4 67.5c-15.2-4.67-31.6-4.67-46.79 0L17.66 153.2c-23.54 7.23-23.54 38.36 0 45.59l48.63 14.94c-10.67 13.19-17.23 29.28-17.88 46.9C38.78 266.15 32 276.11 32 288c0 10.78 5.68 19.85 13.86 25.65L20.33 428.53C18.11 438.52 25.71 448 35.94 448h56.11c10.24 0 17.84-9.48 15.62-19.47L82.14 313.65C90.32 307.85 96 298.78 96 288c0-11.57-6.47-21.25-15.66-26.87.76-15.02 8.44-28.3 20.69-36.72L296.6 284.5c9.06 2.78 26.44 6.25 46.79 0l278.95-85.7c23.55-7.24 23.55-38.36 0-45.6zM352.79 315.09c-28.53 8.76-52.84 3.92-65.59 0l-145.02-44.55L128 384c0 35.35 85.96 64 192 64s192-28.65 192-64l-14.18-113.47-145.03 44.56z"/></svg> <code>R</code>-Verteilungen auf Wiki</a>). Wir müssen diesem Befehl lediglich übergeben wie viele Replikationen wir wünschen und welchen Mittelwert und Standardabweichung die Zufallsvariablen haben sollen. Wir simulieren die Standardnormalverteilung <span class="math inline">\(\mathcal{N}(0,1)\)</span> und legen die generierte (realisierte) Zufallsvariable in einem Objekt mit dem Namen <code>X</code> ab, um später gezeigte Informationen wie den Mittelwert oder die Standardabweichung abrufen zu können - dies machen wir mit dem “Zuordnungspfeil” <code>&lt;-</code> (zur Erinnerung: links davon steht der Name, den wir uns ausdenken; hier: <code>X</code>; rechts steht das zugeordnetete Objekt):</p>
<pre class="r"><code>X &lt;- rnorm(n = 1000, mean = 0, sd = 1) # Standardnormalverteilung mit n = 1000
hist(X)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-10-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>mean(X)</code></pre>
<pre><code>## [1] -0.002997332</code></pre>
<pre class="r"><code>sd(X)</code></pre>
<pre><code>## [1] 0.9956916</code></pre>
<p>Natürlich liegt der geschätzte Mittelwert und die Standardabweichung nicht genau auf den wahren Werten, was am Sampling-Error liegt. Gehen wir nun her und simulieren noch eine zweite Stichprobe standardnormalverteilter Zufallsvariablen, so können wir diese beiden Stichproben mit Hilfe des <span class="math inline">\(t\)</span>-Tests vergleichen. Die Funktion in <code>R</code> hierzu heißt <code>t.test</code> (wir müssen hier <code>var.equal = T</code> wählen, da sonst eine Näherung verwendet wird, die unterschiedliche Varianzen ausgleichen soll, nämlich Welch’s Two Sample <span class="math inline">\(t\)</span>-Test):</p>
<pre class="r"><code>Y &lt;- rnorm(n = 1000, mean = 0, sd = 1)
t.test(X, Y, var.equal = T)</code></pre>
<pre><code>## 
##  Two Sample t-test
## 
## data:  X and Y
## t = -1.4456, df = 1998, p-value = 0.1484
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.15317201  0.02317988
## sample estimates:
##    mean of x    mean of y 
## -0.002997332  0.061998736</code></pre>
<p>Der Output enthält folgende Informationen:</p>
<pre><code>## 
## Two Sample t-test</code></pre>
<p>zeigt an, dass es sich um einen Zweistichproben <span class="math inline">\(t\)</span>-Test handelt.</p>
<pre><code>##  data:  X and Y
##  t = -1.4456, df = 1998, p-value = 0.1484</code></pre>
<p>zeigt uns die Datengrundlage (<code>X</code> und <code>Y</code>), den <span class="math inline">\(t\)</span>-Wert, die <span class="math inline">\(df\)</span> und den <span class="math inline">\(p\)</span>-Wert. Wir erkennen, dass die Mittelwertsdifferenz <span class="math inline">\(d\)</span>= -0.065 mit zugehörigen <span class="math inline">\(t\)</span>-Wert t(1998)=-1.4456 und <span class="math inline">\(p\)</span>-Wert p=0.1484, somit ist dieser Mittelwertsvergleich auf dem 5% Niveau nicht signifikant (<span class="math inline">\(p\)</span>&gt;.05).</p>
<pre><code>##  alternative hypothesis: true difference in means is not equal to 0
##  95 percent confidence interval:
##   -0.15317201  0.02317988
##  sample estimates:
##     mean of x    mean of y 
##  -0.002997332  0.061998736</code></pre>
<p>zeigt uns die Hypothese (<span class="math inline">\(H_0:d=0\)</span>), das Konfidenzintervall der Mittelwertsdifferenz sowie die Mittelwerte in den beiden Gruppen (<span class="math inline">\(\bar{X}=\)</span> -0.0029973, <span class="math inline">\(\bar{Y}=\)</span> 0.0619987).</p>
<p>Wir können den Test auch als <code>R</code> Objekt abspeichern und ähnlich wie den Datensätzen anschließend diese Informationen entlocken. Dazu müssen wir das ausgegebene Objekt <code>t.test</code> lediglich einem Namen zuordnen und anschließend mit <code>$</code> ansprechen. Wieso nennen wir das Objekt nicht einfach <code>ttest</code>. Wenn wir <code>names</code> darauf anwenden, sehen wir alle Namen, die wir hinter <code>$</code> schreiben können:</p>
<pre class="r"><code>ttest &lt;- t.test(X, Y, var.equal = T)
names(ttest)    # alle möglichen Argumente, die wir diesem Objekt entlocken können</code></pre>
<pre><code>##  [1] &quot;statistic&quot;   &quot;parameter&quot;   &quot;p.value&quot;     &quot;conf.int&quot;    &quot;estimate&quot;   
##  [6] &quot;null.value&quot;  &quot;stderr&quot;      &quot;alternative&quot; &quot;method&quot;      &quot;data.name&quot;</code></pre>
<pre class="r"><code>ttest$statistic # (empirischer) t-Wert</code></pre>
<pre><code>##       t 
## -1.4456</code></pre>
<pre class="r"><code>ttest$p.value   # zugehöriger p-Wert</code></pre>
<pre><code>## [1] 0.1484462</code></pre>
<p>Da die Null-Hypothese nicht verworfen wird, bedeutet dies, dass wir weiterhin annehmen, dass die Mittelwertsdifferenz in der Population tatsächlich 0 ist. Die in der Stichprobe ist offensichtlich nicht 0, aber sie liegt so nah an der 0, dass diese Abweichung wahrscheinlich durch Zufall passiert ist und sich nicht auf die Population verallgemeinern lässt (siehe als Wiederholung <a href="https://hds.hebis.de/ubffm/Record/HEB366849158">Eid, et al., 2017</a>, Kapitel 11.1 für den <span class="math inline">\(t\)</span>-Test und Kapitel 8 für Inferenzstatistikgrundlagen und Hypothesentests, bzw. <a href="https://hds.hebis.de/ubffm/Record/HEB369761391">Agresti, &amp; Finlay, 2013,</a>, Kapitel 6).</p>
</div>
<div id="verteilung-unter-h_0" class="section level3">
<h3>Verteilung unter <span class="math inline">\(H_0\)</span></h3>
<p>Wenn wir dieses Experiment nun ganz häufig wiederholen, dann sollte die Teststatistik <span class="math inline">\(T=\frac{\bar{X}-\bar{Y}}{\sigma_p}\)</span> (wobei <span class="math inline">\(\bar{X}\)</span> und <span class="math inline">\(\bar{Y}\)</span> die Mittelwerte von <span class="math inline">\(X\)</span> und <span class="math inline">\(Y\)</span> sind und <span class="math inline">\(\sigma_p\)</span> die gepoolte Standardbweichung beschreibt) der <span class="math inline">\(t\)</span>-Verteilung folgen, welcher wir dann den <span class="math inline">\(p\)</span>-Wert ablesen können. Wenn Sie sich für den dahinterliegenden Code interessieren, so können Sie diesen im <a href="#AppendixA">Appendix A</a> nachlesen.</p>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-17-1.png" width="672" style="display: block; margin: auto;" /><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-17-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Die beiden Histogramme zeigen die empirische Verteilung der <span class="math inline">\(t\)</span>- und <span class="math inline">\(p\)</span>-Werte unter der <span class="math inline">\(H_0\)</span>-Hypothese nach 10000 (unabhängigen) Wiederholungen und die angenommene Verteilung (fette durchgezogene schwarze Linie). Von den <span class="math inline">\(p\)</span>-Werten wird erwartet, dass sie sich gleich (uniform) auf das Intervall zwischen 0 und 1 verteilen. Somit landen dann nur 5% der <span class="math inline">\(p\)</span>-Werte mit zugehörig großen Teststatistiken im Bereich <span class="math inline">\(p&lt;0.05\)</span>.</p>
</div>
<div id="verteilung-unter-h_1" class="section level3">
<h3>Verteilung unter <span class="math inline">\(H_1\)</span></h3>
<p>Angenommen die <span class="math inline">\(H_0\)</span>-Hypothese gilt nicht und es liegt tatsächlich eine Mittelwertsdifferenz von bspw. <span class="math inline">\(d=0.1\)</span> (<span class="math inline">\(H_1: \mu_1 - \mu_2 = 0.1\)</span>) vor, dann hat dies folgende Auswirkungen auf die Verteilung der Teststatistik und die zugehörigen <span class="math inline">\(p\)</span>-Werte:</p>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-18-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Wir sehen sehr deutlich, dass die Teststatstitk <span class="math inline">\(T\)</span> deutlich nach rechts verschoben ist und nicht mehr zur theoretischen Verteilung unter der <span class="math inline">\(H_0\)</span>-Hypothese passt. Auch die <span class="math inline">\(p\)</span>-Werte sind alles andere als gleichverteilt. Folglich sprechen extreme <span class="math inline">\(t\)</span>-Werte gegen die Null-Hypothese, weswegen wir diese verwerfen, wenn wir einen extremen Wert beobachten. Hier liegen 60.99% der <span class="math inline">\(p\)</span>-Werte unterhalb von <span class="math inline">\(0.05\)</span>. Dies wird auch als <strong>Power</strong> (siehe im Kapitel 8 in <a href="https://hds.hebis.de/ubffm/Record/HEB366849158">Eid, et al., 2017</a> Wiederholungen der Begriffe Power und <span class="math inline">\(\alpha\)</span>-Fehler) bezeichnet, somit hat der <span class="math inline">\(t\)</span>-Test für eine Mittelwertsdifferenz von <span class="math inline">\(d\)</span>=.1 und eine Stichprobengröße von insgesamt n = 2000 eine Power von 60.99%, was bedeutet, dass in diesem Fall die <span class="math inline">\(H_0\)</span> richtigerweise verworfen wird. Schauen wir uns die Power der <span class="math inline">\(t\)</span>-Tests einmal für verschiedene Stichprobengröße (<span class="math inline">\(n\)</span>) und Mittelwertsdifferenzen (<span class="math inline">\(d\)</span>) an:</p>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-19-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>Die horizontal gepunktete Linie zeigt eine Power von 5% (also das vorgegebene <span class="math inline">\(\alpha\)</span>-Niveau) an und die horizontal gestrichelte Linie zeigt eine Power von 80% an. Wir sehen sehr deutlich, dass für alle Stichprobengröße (farblich kodiert) von <span class="math inline">\(n=2\)</span> bis <span class="math inline">\(n=1000\)</span> (pro Gruppe) die Power bei einer Mittelwertsdifferenz von 0 gerade bei ca. 5% liegt. Die Mittelwertsdifferenz von 0 beschreibt gerade die Null-Hypothese, dass es keine Mittelwertsunterschied gibt. In diesem Fall beobachten wir gerade den <span class="math inline">\(\alpha\)</span>-Fehler dieses Tests, nämlich die Wahrscheinlichkeit zufällig die Null-Hypothese zu verwerfen, obwohl diese gilt. Die Power von 5% war somit zu erwarten, da dies gerade das <span class="math inline">\(\alpha\)</span>-Niveau dieses Tests ist (welches wir uns auch vorher so vorgegeben haben). In der Regel wird <span class="math inline">\(\alpha = .05\)</span> gewählt.</p>
<p>Was wir auch erkennen ist, dass für sehr große Stichproben die Power dieses Tests schon für sehr kleine Mittelwertsdifferenzen groß ist (idealerweise sprechen Methodiker von einem Test mit hinreichender Power, wenn diese größer als 80% ist). Dieses Beispiel zeigt sehr schön auf, dass damit die Power (also die Wahrscheinlichkeit einen Effekt zu finden, wenn dieser da ist) hoch ist, es einen Effekt geben muss (was sehr trivial klingt und es eigentlich auch ist) und zudem die Stichprobengröße hinreichend groß sein muss. Mit hinreichend groß hält sich der/die Statistiker/in die Hintertür offen zu sagen, dass: a) im Falle eines kleinen Effekts die Stichprobengröße eben sehr groß sein muss, um diesen zu erkennen und b) bei Vorliegen eines sehr großen Effekts schon eine kleine Stichprobengröße ausreicht, um den Effekt mit hinreichender Wahrscheinlichkeit auch als solchen zu identifizieren. Das ist auch der Grund, warum es <em>Poweranalysen</em> gibt, mit welchen bestimmt werden kann, wie groß die Stichprobengröße sein muss, um bei einem vorgegebenem erwarteten Effekt hinreichende Power zu haben, diese auch zu entdecken.</p>
</div>
<div id="verstöße-gegen-die-modellannahmen" class="section level3">
<h3>Verstöße gegen die Modellannahmen</h3>
<p>Liegen andere Verstöße gegen die Modellannahmen vor, dann kann es fälschlicherweise zu signifikanten Ergebnissen kommen, obwohl es in der Population gar keinen Effekt gibt. Dies ist oft bei kleinen Stichproben ein Problem. Nehmen wir beispielsweise an, dass die beiden Gruppen sehr gegenläufig schief verteilt sind.</p>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-20-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Hier gilt zwar die Null-Hypothese, da beide Verteilungen einen theoretischen Mittelwert von 0 haben, aber die Varianzen unterscheiden sich (was im Histogramm durch die extremeren Werte entlang der x-Achse zu erkennen ist) und die Variablen sind offensichtlich nicht normalverteilt. Schauen wir uns nun die Power des <span class="math inline">\(t\)</span>-Tests für eine sehr kleine Stichprobe von 5 pro Gruppe an:</p>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-21-1.png" width="672" style="display: block; margin: auto;" /><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-21-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Insgesamt sieht die Verteilung der <span class="math inline">\(T\)</span>-Werte einigermaßen in Ordnung, auch wenn etwas schief, aus, doch bei den <span class="math inline">\(p\)</span>-Werten fällt auf, dass die Null-Hypothese zu häufig verworfen wird, nämlich insgesamt in 11.11% der Fälle (durch Zufall, da die Null-Hypothese eigentlich gilt!); also doppelt so häufig wie von uns vorgegeben! Glücklicherweise ist der <span class="math inline">\(t\)</span>-Test relativ robust, was daran zu erkennen ist, dass wenn die Stichprobengröße für dieses Beispiel bei 50 oder gar höher liegt (pro Gruppe), das <span class="math inline">\(\alpha\)</span>-Niveau schon wieder einigermaßen eingehalten wird. Außerdem gibt es geeignetere Tests zum Untersuchen von Mittelwertsunterschieden zweier Stichproben als den <span class="math inline">\(t\)</span>-Test - nämlich den Welch-Test. Dies ist eine Erweiterung des <span class="math inline">\(t\)</span>-Tests für ungleiche Varianzen. Dieser ist auch der Default in <code>R</code>. Wir rechnen ihn, indem wir nicht länger <code>var.equal = T</code> in <code>t.test</code> spezifizieren. Der Output ändert sich bis auf die Namensänderung kaum - die Freiheitsgrade des Tests werden korrigiert, um auf die ungleichen Varianzen zu reagieren (dies bedeutet, immer wenn die Freiheits gerade nicht einfach <span class="math inline">\(n-2\)</span> sind, dann wurde der Welch-Test gerechnet; insbesondere Kommazahlen als <span class="math inline">\(df\)</span> sind möglich). Jedoch bringt diese Erweiterung ebenfalls nur für größere Stichproben etwas. Die analoge Simulationsstudie können Sie <a href="#AppendixA">Appendix A</a> entnehmen.</p>
<p>Diese Sitzung sollte als Einführung in <code>R</code>, Vorbereitung für die Regressionssitzung und kleine Wiederholung einiger wichtiger inferenzstatistischer Begriffe (wie etwas <span class="math inline">\(\alpha\)</span>-Fehler, Power, Hypothese etc.) fungieren. Wie wir Histogramme erstellen und Verteilungen vergleichen, erfahren wir in der nächsten Sitzung im Rahmen der Voraussetzungen der Regressionsanalyse und Ausreißerdiagnostik.</p>
<p>Eine Übersicht über Matrixalgebra in <code>R</code> erhalten Sie in <a href="#AppendixB">Appendix B</a>.</p>
<p>Den gesamten <code>R</code>-Code, der in dieser Sitzung genutzt wird, können Sie <a href="https://raw.githubusercontent.com/jpirmer/MSc1_FEI/master/R-Scripts/1_Intro_RCode.R"><svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 512 512"><path d="M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z"/></svg> hier herunterladen</a>.</p>
</div>
</div>
<div id="appendix" class="section level2">
<h2>Appendix</h2>
<div id="AppendixA" class="section level3">
<h3>Appendix A</h3>
<p>Hier ist der Code für einige Grafiken und Simulationen dargestellt. Dies geht natürlich über den Stoff des Seminars hinaus und ist nur für Interessierte bestimmt.</p>
<div id="verteilung-unter-h_0-1" class="section level4">
<h4>Verteilung unter <span class="math inline">\(H_0\)</span></h4>
<pre class="r"><code>ts &lt;- c(); ps &lt;- c() # wir brauchen zunächst Vektoren, in die wir die t-Werte und die p-Werte hineinschreiben können
for(i in 1:10000)
{
    X &lt;- rnorm(n = 1000, mean = 0, sd = 1)
    Y &lt;- rnorm(n = 1000, mean = 0, sd = 1)
    ttest &lt;- t.test(X, Y, var.equal = T)
    ts &lt;- c(ts, ttest$statistic) # nehme den Vektor ts und verlängere ihn um den neuen t-Wert
    ps &lt;- c(ps, ttest$p.value)   # nehme den Vektor ps und verlängere ihn um den neuen p-Wert
}

hist(ts, main = &quot;(empirische) t-Werte nach 10000 Replikationen unter H0&quot;, xlab = &quot;T&quot;, freq = F)
lines(x = seq(-4,4,0.01), dt(x = seq(-4,4,0.01), df = ttest$parameter), lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-22-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>hist(ps, main = &quot;p-Werte nach 10000 Replikationen unter H0&quot;, xlab = &quot;p&quot;, freq = F)
abline(a = 1, b = 0, lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-22-2.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="verteilung-unter-h_1-1" class="section level4">
<h4>Verteilung unter <span class="math inline">\(H_1\)</span></h4>
<pre class="r"><code>ts &lt;- c(); ps &lt;- c() # wir brauchen zunächst Vektoren, in die wir die t-Werte und die p-Werte hineinschreiben können
for(i in 1:10000)
{
    X &lt;- rnorm(n = 1000, mean = 0, sd = 1)
    Y &lt;- -0.1 + rnorm(n = 1000, mean = 0, sd = 1) # Mittelwertsdifferenz ist 0.1
    ttest &lt;- t.test(X, Y, var.equal = T)
    ts &lt;- c(ts, ttest$statistic) # nehme den Vektor ts und verlängere ihn um den neuen t-Wert
    ps &lt;- c(ps, ttest$p.value)   # nehme den Vektor ps und verlängere ihn um den neuen p-Wert
}

hist(ts, main = &quot;(empirische) t-Werte nach 10000 Replikationen unter H1&quot;, xlab = &quot;T&quot;, freq = F)
lines(x = seq(-4,4,0.01), dt(x = seq(-4,4,0.01), df = ttest$parameter), lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-23-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>hist(ps, main = &quot;p-Werte nach 10000 Replikationen unter H1&quot;, xlab = &quot;p&quot;, freq = F)
abline(a = 1, b = 0, lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-23-2.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="verteilung-unter-h_0-mit-modellverstößen" class="section level4">
<h4>Verteilung unter <span class="math inline">\(H_0\)</span> mit Modellverstößen</h4>
<pre class="r"><code>set.seed(1)
ts &lt;- c(); ps &lt;- c() # wir brauchen zunächst Vektoren, in die wir die t-Werte und die p-Werte hineinschreiben können
for(i in 1:10000)
{
       X &lt;- -rexp(n = 5, rate = 1) # simuliere Exponentialverteilung zur Rate 1 mit n = 5
        X &lt;- X + 1 # zentriere, sodass der Populationsmittelwert wieder 0 ist
        Y &lt;- rexp(n = 5, rate = 2) # simuliere Exponentialverteilung zur Rate 2 mit n = 5
        Y &lt;- Y - 1/2 # zentriere, sodass der Populationsmittelwert wieder 0 ist
        ttest &lt;- t.test(X, Y, var.equal = T)
        ts &lt;- c(ts, ttest$statistic) # nehme den Vektor ts und verlängere ihn um den neuen t-Wert
        ps &lt;- c(ps, ttest$p.value)   # nehme den Vektor ps und verlängere ihn um den neuen p-Wert
}

hist(ts, main = &quot;t-Werte nach 10000 Replikationen unter Modellverstöße\n für kleine Stichproben&quot;, xlab = &quot;t&quot;, freq = F)
lines(x = seq(-4,4,0.01), dt(x = seq(-4,4,0.01), df = ttest$parameter), lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-24-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>hist(ps, main = &quot;p-Werte nach 10000 Replikationen unter Modellverstößen\n für kleine Stichproben&quot;, xlab = &quot;p&quot;, freq = F)
abline(a = 1, b = 0, lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-24-2.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="verteilung-unter-h_0-mit-modellverstößen-welch-test" class="section level4">
<h4>Verteilung unter <span class="math inline">\(H_0\)</span> mit Modellverstößen: Welch-Test</h4>
<pre class="r"><code>set.seed(1)
ts &lt;- c(); ps &lt;- c() # wir brauchen zunächst Vektoren, in die wir die t-Werte und die p-Werte hineinschreiben können
for(i in 1:10000)
{
        X &lt;- -rexp(n = 5, rate = 1) # simuliere Exponentialverteilung zur Rate 1 mit n = 5
        X &lt;- X + 1 # zentriere, sodass der Populationsmittelwert wieder 0 ist
        Y &lt;- rexp(n = 5, rate = 2) # simuliere Exponentialverteilung zur Rate 2 mit n = 5
        Y &lt;- Y - 1/2 # zentriere, sodass der Populationsmittelwert wieder 0 ist
        ttest &lt;- t.test(X, Y) # Welch Test
        ts &lt;- c(ts, ttest$statistic) # nehme den Vektor ts und verlängere ihn um den neuen t-Wert
        ps &lt;- c(ps, ttest$p.value)   # nehme den Vektor ps und verlängere ihn um den neuen p-Wert
}

hist(ts, main = &quot;t-Werte (des Welch t-Tests) nach 10000 Replikationen\n unter Modellverstöße für kleine Stichproben&quot;, xlab = &quot;t&quot;, freq = F)
lines(x = seq(-4,4,0.01), dt(x = seq(-4,4,0.01), df = ttest$parameter), lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-25-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>hist(ps, main = &quot;p-Werte (des Welch t-Tests) nach 10000 Replikationen\n unter Modellverstößen für kleine Stichproben&quot;, xlab = &quot;p&quot;, freq = F)
abline(a = 1, b = 0, lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-25-2.png" width="672" style="display: block; margin: auto;" />
Insgesamt sieht die Verteilung der Teststatistik (also quasi der empirischen <span class="math inline">\(t\)</span>-Werte) einigermaßen in Ordnung, auch wenn etwas schief, aus, doch bei den <span class="math inline">\(p\)</span>-Werten fällt auf, dass die Null-Hypothese zu häufig verworfen wird, nämlich insgesamt in 10% der Fälle (durch Zufall, da die Null-Hypothese eigentlich gilt!); also doppelt so häufig wie von uns vorgegeben! Hier gibt es kaum Unterschiede zum ursprünglichen <span class="math inline">\(t\)</span>-Test mit gleichen Varianzen. Allerdings ist die Stichprobengröße hier mit 5 pro Gruppe recht klein!</p>
</div>
<div id="verteilung-unter-h_0-mit-modellverstößen-mit-größerer-stichprobe-welch-test" class="section level4">
<h4>Verteilung unter <span class="math inline">\(H_0\)</span> mit Modellverstößen mit größerer Stichprobe: Welch-Test</h4>
<pre class="r"><code>set.seed(1234)
ts &lt;- c(); ps &lt;- c() # wir brauchen zunächst Vektoren, in die wir die t-Werte und die p-Werte hineinschreiben können
for(i in 1:10000)
{
        X &lt;- -rexp(n = 100, rate = 1) # simuliere Exponentialverteilung zur Rate 1 mit n = 100
        X &lt;- X + 1 # zentriere, sodass der Populationsmittelwert wieder 0 ist
        Y &lt;- rexp(n = 100, rate = 2) # simuliere Exponentialverteilung zur Rate 2 mit n = 100
        Y &lt;- Y - 1/2 # zentriere, sodass der Populationsmittelwert wieder 0 ist
        ttest &lt;- t.test(X, Y) # Welch Test
        ts &lt;- c(ts, ttest$statistic) # nehme den Vektor ts und verlängere ihn um den neuen t-Wert
        ps &lt;- c(ps, ttest$p.value)   # nehme den Vektor ps und verlängere ihn um den neuen p-Wert
}

hist(ts, main = &quot;t-Werte (des Welch t-Tests) nach 10000 Replikationen\n unter Modellverstöße für kleine Stichproben&quot;, xlab = &quot;t&quot;, freq = F)
lines(x = seq(-4,4,0.01), dt(x = seq(-4,4,0.01), df = ttest$parameter), lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-26-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>hist(ps, main = &quot;p-Werte (des Welch t-Tests) nach 10000 Replikationen\n unter Modellverstößen für kleine Stichproben&quot;, xlab = &quot;p&quot;, freq = F)
abline(a = 1, b = 0, lwd = 3)</code></pre>
<p><img src="/post/2020-10-06-einleitung-und-wiederholung_files/figure-html/unnamed-chunk-26-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Für jeweils 100 Erhebungen pro Gruppe ist der Verstoß gegen die Normalverteilungsannahme bei ungleichen Varianzen für den Welch-Test fast zu vernachlässigen.</p>
</div>
</div>
<div id="AppendixB" class="section level3">
<h3>Appendix B</h3>
<div id="matrixalgebra" class="section level4">
<h4>Matrixalgebra</h4>
<p>Matrixalgebra wird bspw. auch in Eid, et al. (2017) im <em>Anhang B: Matrixalgebra</em> ab Seite 1051 behandelt.</p>
<p><code>R</code> ist eine vektorbasierte Programmiersprache, was bedeutet, dass möglichst viel mit Vektor- oder Matrixoperationen durchgeführt werden soll. Um von dem Gebrauch zu machen, müssen wir uns mit diesen Operationen vertraut machen:</p>
<div id="vektoren" class="section level5">
<h5>Vektoren</h5>
<p>Dazu seien <code>X</code> und <code>Y</code> zwei Vektoren, die wir mit dem Zuordnungspfeil <code>&lt;-</code> erstellen und mit der Vektorfunktion <code>c()</code> erstellen:</p>
<pre class="r"><code>X &lt;- c(1, 2, 3)
Y &lt;- c(10, 8, 6)</code></pre>
<p>Wir können auf Elemente eines Vektor mit eckigen Klammern zugreifen. Bspw. erhalten wir das 2. Element von Y (also quasi <span class="math inline">\(y_2\)</span>) mit</p>
<pre class="r"><code>Y[2]</code></pre>
<pre><code>## [1] 8</code></pre>
<p>Elementenweise Additionen funktioniert super simpel, indem wir einfach mit <code>+</code> verknüpfen. Auch Subtraktion oder skalare Multiplikation funktioniert so:</p>
<pre class="r"><code>X + Y  # Addition</code></pre>
<pre><code>## [1] 11 10  9</code></pre>
<pre class="r"><code>X - Y  # Subtraktion</code></pre>
<pre><code>## [1] -9 -6 -3</code></pre>
<pre class="r"><code>3*X    # Skalare Multiplikation</code></pre>
<pre><code>## [1] 3 6 9</code></pre>
<pre class="r"><code>1/2*X</code></pre>
<pre><code>## [1] 0.5 1.0 1.5</code></pre>
<p>Wenn <code>X</code> und <code>Y</code> nicht die selbe Länge haben, ist es in <code>R</code> oft so, dass die Vektoren künstlich verlängert werden, um verrechnet zu werden. Dies sollten wir immer im Hinterkopf behalten.</p>
<pre class="r"><code>Z &lt;- c(1:6) # Zahlen 1 bis 6
Z + Y</code></pre>
<pre><code>## [1] 11 10  9 14 13 12</code></pre>
<p><code>Z</code> ist hier doppelt so lang wie <code>Y</code>, sodass in der Addition <code>Y</code> einfach zweimal hintereinander geschrieben wird, damit die Addition möglich ist, denn eine Addition bei Vektoren (und auch Matrizen) funktioniert nur, wenn die beiden Elemente das gleiche Format haben!</p>
<p>Wenn wir zwei Vektoren miteinander multiplizieren, so entsteht kein Matrixprodukt, sondern elementenweise Multiplikation:</p>
<pre class="r"><code>X*Y # elementenweise Multiplikation</code></pre>
<pre><code>## [1] 10 16 18</code></pre>
</div>
</div>
<div id="matrizen" class="section level4">
<h4>Matrizen</h4>
<p>Die gerade behandelten Vektoren können wir ganz leicht zu einer Matrix machen, indem wir den Befehl <code>as.matrix</code> bspw. auf <code>X</code> anwenden. Dieser Befehl erzeugt eine 3x1 Matrix - also eigentlich einen Spaltenvektor.</p>
<pre class="r"><code>as.matrix(X)</code></pre>
<pre><code>##      [,1]
## [1,]    1
## [2,]    2
## [3,]    3</code></pre>
<p>Wir können die beiden Vektoren auch zu einer Matrix kombinieren, indem wir sie bspw. als zwei Zeilenvektoren zusammenfügen mit dem Befehl <code>cbind</code> (was für column binding steht) - genauso geht dies auch mit <code>rbind</code> (was für row binding steht):</p>
<pre class="r"><code>A &lt;- cbind(X, Y)
A</code></pre>
<pre><code>##      X  Y
## [1,] 1 10
## [2,] 2  8
## [3,] 3  6</code></pre>
<pre class="r"><code>B &lt;- rbind(X, Y)
B</code></pre>
<pre><code>##   [,1] [,2] [,3]
## X    1    2    3
## Y   10    8    6</code></pre>
<p>Wir können nun bspw. den Eintrag <span class="math inline">\(A_{12}\)</span> herauslesen via <code>[1, 2]</code>, wobei der erste Eintrag immer für die Zeile und der 2. für die Spalte steht:</p>
<pre class="r"><code>A[1, 2] # Eintrag 1. Zeile 2. Spalte in A</code></pre>
<pre><code>##  Y 
## 10</code></pre>
<p>Eine ganze Zeile oder Spalte erhalten wir, indem wir eines der Elemente in der Indizierung frei lassen:</p>
<pre class="r"><code>A[1, ] # 1. Zeile</code></pre>
<pre><code>##  X  Y 
##  1 10</code></pre>
<pre class="r"><code>A[, 2] # 2. Spalte</code></pre>
<pre><code>## [1] 10  8  6</code></pre>
<p>Wir können eine Matrix transponieren; also Zeilen und Spalten vertauschen; indem wir den Befehl <code>t()</code> auf die Matrix anwenden:</p>
<pre class="r"><code>A</code></pre>
<pre><code>##      X  Y
## [1,] 1 10
## [2,] 2  8
## [3,] 3  6</code></pre>
<pre class="r"><code>t(A)</code></pre>
<pre><code>##   [,1] [,2] [,3]
## X    1    2    3
## Y   10    8    6</code></pre>
<pre class="r"><code>B</code></pre>
<pre><code>##   [,1] [,2] [,3]
## X    1    2    3
## Y   10    8    6</code></pre>
<p>Wir erkennen, dass die Matrix <code>B</code> gerade die Transponierte von <code>A</code> ist! Die beiden Matrizen <code>A</code> und <code>B</code> lassen sich nicht addieren, da sie nicht das richtige Format haben, während skalare Multiplikation immer funktioniert:</p>
<pre class="r"><code>A + B</code></pre>
<pre><code>## Error in A + B : non-conformable arrays</code></pre>
<pre class="r"><code>A * 2</code></pre>
<pre><code>##      X  Y
## [1,] 2 20
## [2,] 4 16
## [3,] 6 12</code></pre>
<p>Da die beiden Matrizen gerade das Format 3x2 und 2x3 haben, lassen sie sich aber als Matrixprodukt verrechnen. Der Operator hierfür heißt <code>%*%</code> (verwenden wir stattdessen <code>*</code>, so wird elementenweise Multiplikation durchgeführt, was etwas komplett anderes ist!):</p>
<pre class="r"><code>A %*% B # Matrixprodukt A*B</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]  101   82   63
## [2,]   82   68   54
## [3,]   63   54   45</code></pre>
<pre class="r"><code>B %*% A # Matrixprodukt B*A</code></pre>
<pre><code>##    X   Y
## X 14  44
## Y 44 200</code></pre>
<p>An den Ergebnissen erkennen wir auch, dass Matrixprodukte nicht kommutativ sind, also die Reihenfolge wichtig ist in der (matrix-)multipliziert wird.</p>
</div>
<div id="spezielle-matrizen" class="section level4">
<h4>Spezielle Matrizen</h4>
<p>Eine quadratische Matrix hat genauso viele Zeilen wie Spalten. Eine wichtig quadratische Matrix ist die Einheitsmatrix <span class="math inline">\(I\)</span>, welche nur 1en auf der Diagonale und 0en sonst hat. Diese ist gerade das Elemente, mit welchem wir getrost multiplizieren können (falls die Dimensionen stimmen), weil dann nichts passiert (wie Multiplikation mit 1 bei Zahlen). Wir erhalten sie mit <code>diag</code>, was eigentlich eine (quadratische) Diagonalmatrix erzeugt mit beliebigen Elementen auf der Diagonale:</p>
<pre class="r"><code>diag(3) # Einheitsmatrix 3x3</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1</code></pre>
<pre class="r"><code>diag(1:3) # Diagonalmatrix mit Elementen 1,2,3 auf der Diagonale</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    2    0
## [3,]    0    0    3</code></pre>
<p>Wir können eine Matrix auf mit Hand füllen mit dem <code>matrix</code> Befehl. Diesem übergeben wir einen Vektor und die Dimensionen der Matrix (<code>data</code> werden die Daten, die wir in die Matrix schreiben wollen übergeben, <code>nrow</code> und <code>ncol</code> bestimmen die Anzahl der Zeilen und Spalten und mit <code>byrow = T</code> zeigen wir an, dass wir die Matrix zeilenweise gefüllt bekommen möchten):</p>
<pre class="r"><code>C &lt;- matrix(data = c(1:9), nrow = 3, ncol = 3, byrow = T)
C</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9</code></pre>
<p>Wir können mit <code>diag</code> auch wieder die Diagonalelemnte einer Matrix erfahren:</p>
<pre class="r"><code>diag(C)</code></pre>
<pre><code>## [1] 1 5 9</code></pre>
<div id="determinanten-und-invertierung" class="section level5">
<h5>Determinanten und Invertierung</h5>
<p>Die Inverse, also jenes Element, mit welchem wir (matrix-)multiplizieren müssen, um die Einheitsmatrix zu erhalten, lässt sich in <code>R</code> mit dem <code>solve</code> Befehl erhalten (dies geht nur bei quadratischen Matrizen):</p>
<pre class="r"><code>solve(C)</code></pre>
<pre><code>## Error in solve.default(C) : 
##   system is computationally singular: reciprocal condition number = 2.59052e-18</code></pre>
<p>Die Matrix <code>C</code> lässt sich nicht invertieren, da sie singulär ist und damit nicht invertierbar. Dies bedeutet, dass es lineare Abhängigkeiten der Zeilen bzw. Spalten gibt. Wir können dies explizit prüfen, indem wir die Determinate bestimmen mit <code>det</code>:</p>
<pre class="r"><code>det(C)</code></pre>
<pre><code>## [1] 6.661338e-16</code></pre>
<pre class="r"><code>round(det(C), 14)</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Mit <code>round</code> runden wir das Ergebnis auf die 14. Nachkommastelle. Eine Matrix ist genau dann invertierbar (also regular im Vergleich zu singulär), wenn die Determinate dieser (quadratischen) Matrix <strong>nicht</strong> Null ist. Lineare Abhängigkeit bedeutet, dass die Zeilen oder Spalten durch Addition, Subtraktion und skalare Multiplikationen auseinander hervorgehen. Wir erkennen die lineare Abhängigkeit zwischen den Spalten, indem wir von der 2. Spalte die 1. Spalte abziehen und anschließend dies auf die 2. Spalte addieren - also de facto _2*2.Spalte - 1. Spalte_ rechnen:</p>
<pre class="r"><code>2*C[, 2] - C[, 1]     # 2*2.Spalte - 1. Spalte rechnen ist gleich</code></pre>
<pre><code>## [1] 3 6 9</code></pre>
<pre class="r"><code>C[, 3]               # 3. Spalte</code></pre>
<pre><code>## [1] 3 6 9</code></pre>
<p>Hätten wir <code>C^-1</code> gererchnet, so hätten wir elementenweise Invertierung durchgeführt:</p>
<pre class="r"><code>C^-1</code></pre>
<pre><code>##           [,1]  [,2]      [,3]
## [1,] 1.0000000 0.500 0.3333333
## [2,] 0.2500000 0.200 0.1666667
## [3,] 0.1428571 0.125 0.1111111</code></pre>
<pre class="r"><code>C^-1 %*% C # ist nicht die Einheitsmatrix</code></pre>
<pre><code>##          [,1]     [,2]     [,3]
## [1,] 5.333333 7.166667 9.000000
## [2,] 2.216667 2.833333 3.450000
## [3,] 1.420635 1.799603 2.178571</code></pre>
<pre class="r"><code>C^-1 * C   # elementenweise ergibt überall 1 - ist immer noch nicht die Einheitsmatrix!</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    1
## [2,]    1    1    1
## [3,]    1    1    1</code></pre>
<p>Dies bedeutet, dass <code>C^-1</code> in <code>R</code> nicht die Invertierung betietelt sondern <code>solve</code>!</p>
<p>Betrachten wir nun eine invertierbare Matrix <code>D</code>:</p>
<pre class="r"><code>D &lt;- matrix(c(1, 0, 0,
              1, 1, 1,
              2, 4, 5), 3, 3, byrow = T)
det(D)</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Die Determinante von <code>D</code> ist 1. Somit können wir <code>D</code> invertieren. Das Produkt aus <code>D</code> mit seiner Inversen ergibt gerade die 3x3 Einheitsmatrix:</p>
<pre class="r"><code>solve(D)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]   -3    5   -1
## [3,]    2   -4    1</code></pre>
<pre class="r"><code>D %*% solve(D)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1</code></pre>
<pre class="r"><code>solve(D) %*% D</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1</code></pre>
<p>Das Produkt zwischen <span class="math inline">\(D\)</span> und <span class="math inline">\(D^{-1}\)</span> ist (ausnahmsweise) kommutativ: <span class="math inline">\(DD^{-1}=D^{-1}D=I\)</span>.</p>
</div>
</div>
</div>
</div>
<div id="literatur" class="section level2">
<h2>Literatur</h2>
<p><a href="https://hds.hebis.de/ubffm/Record/HEB369761391">Agresti, A, &amp; Finlay, B. (2013).</a> <em>Statistical methods for the social sciences.</em> (Pearson new international edition, 4th edition). Harlow, Essex : Pearson Education Limited.</p>
<p><a href="https://hds.hebis.de/ubffm/Record/HEB366849158">Eid, M., Gollwitzer, M., &amp; Schmitt, M. (2017).</a> <em>Statistik und Forschungsmethoden</em> (5. Auflage, 1. Auflage: 2010). Weinheim: Beltz.</p>
<ul>
<li><small> <em>Blau hinterlegte Autorenangaben führen Sie direkt zur universitätsinternen Ressource.</em></li>
</ul>
</div>
