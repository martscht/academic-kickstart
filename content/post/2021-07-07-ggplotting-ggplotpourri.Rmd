---
title: ggplotpourri
date: '2020-10-17'
slug: ggplotting-ggplotpourri
categories: [""]
tags: ["ggplotting"]
subtitle: ''
summary: ''
authors: [schultze, buchholz]
lastmod: '2021-07-07T18:00:00+01:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

```{r, echo = FALSE}
library(ggplot2)
load('./edu_exp.rda')
source('./ggplotting-theme-source.R')
```


## Tortendiagramme 

Bevor wir uns damit befassen, *wie* man in `ggplot2` ein Torten-Diagramm erstellen kann (und die Donut-förmige Abwandlung davon) wird in [vielen Ecken des Internets](https://www.data-to-viz.com/caveat/pie.html) die Frage nach dem *ob* man ein Torten-Diagramm erstellen sollte mit einem vehementen "nein" beantwortet (es gibt auch [wissenschaftliche Untersuchungen](https://hci.stanford.edu/publications/2010/crowd-perception/heer-chi2010.pdf), die zeigen, dass Daten undeutlicher vermittelt werden). Dennoch werden beide Arten von Plots gerne und häufig genutzt und haben in einigen Fällen ihre Anwendungsgebiete. Im normalen R können wir `pie()` nutzen, um ein Tortendiagramm anzulegen, in `ggplot2` ist das allerdings ein wenig umständlicher.

Generell werden Tortendiagramme nur dann empfohlen, wenn man Anteile von einem Gesamten darstellen möchte. Leider haben wir keine dafür direkt geeignete Variable in [unserem Datensatz](/post/ggplotting-daten), aber wir können uns etwas erstellen. Wir betrachten im Folgenden die Ausgaben für die drei unterschiedlichen Bildungsbreiche und wie diese in unterschiedlichen Ländern aussehen. Dafür erstellen wir zunächst Proportionen:

```{r}
edu_exp$Total <- subset(edu_exp, select = c('Primary', 'Secondary', 'Tertiary')) |>
  rowSums()
tmp <- edu_exp[, c('Primary', 'Secondary', 'Tertiary')] / edu_exp$Total
names(tmp) <- c('PrimaryProp', 'SecondaryProp', 'TertiaryProp')
edu_exp <- cbind(edu_exp, tmp)
```

Wie immer, nehmen wir 2013 und beschränken uns auf die Länder, die in diesem Jahr für alle drei Ausgaben Daten vorhanden haben. Wie wir schon [im ersten Beitrag gesehen haben](/post/ggplotting-intro), müssen wir die Daten mehrerer Variablen für die ordentliche Darstellung ins lange Format übertragen.

```{r}
prop_long <- subset(edu_exp, Year == 2013 & !is.na(Total), 
  select = c('Country', 'Year',  
    'PrimaryProp', 'SecondaryProp', 'TertiaryProp')) |>
  reshape(direction = 'long',
    varying = c('PrimaryProp', 'SecondaryProp', 'TertiaryProp'),
    v.names = 'Proportion',
    timevar = 'Type',
    times = c('Primary', 'Secondary', 'Tertiary'))
```

`geom_rect()` ist der Umweg über den wir uns in `ggplot2` an das Kreisdiagramm heranpirschen müssen. Dafür benötigen wir klare Enden unserer Rechtecke, also bei welchen y-Werten die Balken anfangen und aufhören sollen. Weil die Balken ja bündig einen Kreis ergeben sollen, brauchen wir erstmal auch einen bündigen Balken, das heißt jede Kategorie muss das aufhören, wo die nächste beginnt. Damit wir das nicht gleichzeitig und unübersichtlich für alle Länder gleicheztig machen, beschränken wir uns wieder auf Spanien:

```{r}
spain <- subset(prop_long, Country == 'Spain')
spain$Max <- cumsum(spain$Proportion)
spain$Min <- c(0, head(spain$Max, n = -1))

spain
```

Mit `geom_rect()` können wir jetzt einen Balken erstellen, der genau bündig von einem Bildungstyp in den nächsten übergeht:

```{r stacked-bar, fig = TRUE}
bar <- ggplot(spain, 
  aes(ymin = Min, ymax = Max, 
    xmin = 2, xmax = 3,
    fill = Type)) +
  geom_rect(color = 'white') +
  theme_void() + scale_fill_pandar()
bar
```

Wir nutzen statt des `theme_pandar()` hier `theme_void()`, um den Plot von Achsen und anderen Kennzeichnungen zu befreien. `color = 'white'` setze ich hier, um eine sauber aussehende Grenze zwischen den Abschnitten herzustellen.

Jetzt müssen wir aus diesem Türmchen nur noch einen Kreis formen. Dafür transformieren wir die Koordinaten ins polare System, sodass (0, 0) in der Mitte liegt und sich die Datenpunkte von dort entfernen:

```{r simple-pie, fig=TRUE}
pie <- bar + coord_polar("y")
pie
```

Jetzt können wir über `geom_text` noch die Prozente in die Abschnitte eintragen. Dabei müssen wir nur ordentliche Positionen für die Labels bestimmen. Ich setze diese einfach mal in die Mitte. Danach erzeugen wir noch die Prozentzahlen und `paste`n sie mit dem Prozentzeichen zusammen. Das sollte für unsere Label genügen.

```{r}
spain$Position <- (spain$Max + spain$Min) / 2
spain$Percent <- paste0(round(spain$Proportion * 100, 1), '%')
```

Weil wir Änderungen an den Daten vorgenommen haben, müssen wir den neuen Datensatz direkt über das `data`-Argument ansprechen (sonst wüsste `geom_text()` nichts von den neuen Variablen)

```{r fancy-pie, fig = TRUE}
pie <- pie +
  geom_text(data = spain, x = 2.5,
    aes(y = Position, label = Percent), 
      color = 'white', size = 5) +
  labs(fill = 'Education Type') + 
  ggtitle('Proportional Education Spending', 'Spain, 2013')
pie
```

Um aus diesem Kuchen jetzt einen Donut zu machen, müssen wir nur das mittlere Stück herausnehmen, indem wir die x-Achse in eine Region erweitern, in die unser `geom_rect()` nicht reicht.

```{r donut, fig = TRUE}
pie + xlim(c(1, 3))
```



## Karten

Bei psychologischen Daten eher selten, aber mit dem [Gapminder Datensatz](/post/ggplotting-daten) natürlich sehr naheliegend, ist die Datenvisualisierung auf Karten. Für komplexere Karten (z.B. mit Google Maps) gibt es das `ggmap` Paket. Für unsere Zwecke reichen allerdings die von `ggplot2` mitgelieferten Karten aus.

Karten benötigen eine sehr eigene Art der Datenaufbereitung, die häufig nicht gerade platzsparend ist. Daher sind die meisten Karten in R nicht als Datensätze vorhanden, sondern müssen erst einmal in solche überführt werden. Dafür gibt es die `map_data` Funktion. Um die Weltkarte in einen Datensatz zu übertragen, z.B.:

```{r}
welt <- map_data('world')
head(welt)
```

Was man in den Daten sieht sind Länge- und Breitengrade von Landesgrenzen. Außerdem bestimmt die Variable `group` das Land (anhand dessen die Landesgrenzen gruppiert werden sollten). Damit Linie der Grenzen nicht hin und her springt gibt es außerdem die Variable `order` die angibt, welcher Punkt in der Grenze als nächstes kommt. Anhand dieser Punkte werden in `ggplot2` mit der allgemeinen `geom_polygon` Funktion Karten gezeichnet. Um eine leere Weltkarte zu erzeugen reicht Folgendes aus:

```{r}
ggplot(welt, aes(x = long, y = lat, group = group)) +
  geom_polygon()
```

Wie man sieht, hat dieser Plot die gleichen Eigenschaften wie normale `ggplot`s - weil es ein ganz normaler Plot ist. Um einzelne Länder erkennen zu können, sollten wir z.B. die Länder weiß und nicht schwarz füllen. Außerdem brauchen wir nicht unbedingt x- und y-Achse, sodass wir das komplett leere Theme `theme_void` nutzen können:

```{r}
ggplot(welt, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = 'white', color = 'black', lwd = .25) +
  theme_void()
```

Um die Karten-Daten mit den Daten in Verbindung zu bringen steht uns leider - wie so häufig - im Weg, dass die Daten nicht einheitlich kodiert wurden. In diesem Fall sind es die Benennungen der Länder, die uneinheitlich sind. Um herauszufinden, wo Unterschiede bestehen, können wir die normalen Operatoren der Mengenvergleiche in R nutzen:

```{r}
setdiff(unique(welt$region), unique(edu_exp$Country))
setdiff(unique(edu_exp$Country), unique(welt$region))
```

Im Folgenden werden die Namen der Länder mit dem `recode` Befehl des `car`-Pakets umkodiert. Leider gibt es schon vorab ein Land, nach dem man in Datenaufbereitungen immer vorab schauen sollte: wie auch hier ist es häufiger der Fall, dass die Elfenbeiküste als `Cote d'Ivoire` kodiert ist. Leider bewirkt das `'` in diesem Namen bei Umkodierungen immer einiges an Problemen, sodass wir es vorab direkt umstellen:

```{r}
edu_exp[grepl('Cote', edu_exp$Country), 'Country'] <- 'Ivory Coast'
```

die verbleindenden Ländern können dann umkodiert werden:

```{r}
# Recodes
edu_exp$Country <- car::recode(edu_exp$Country,
  "'Antigua and Barbuda' = 'Antigua';
  'Congo, Rep.' = 'Republic of Congo';
  'Congo, Dem. Rep.' = 'Democratic Republic of the Congo';
  'Micronesia, Fed. Sts.' = 'Micronesia';
  'United Kingdom' = 'UK';
  'Holy See' = 'Vatican';
  'Kyrgyz Republic' = 'Kyrgyzstan'; 
  'St. Kitts and Nevis' = 'Saint Kitts';
  'Lao' = 'Laos';
  'St. Lucia' = 'Saint Lucia';
  'North Macedonia' = 'Macedonia';
  'Slovak Republic' = 'Slovakia';
  'Eswatini' = 'Swaziland';
  'Trinidad and Tobago' = 'Trinidad';
  'United States' = 'USA';
  'Saint Vincent and the Grenadines' = 'Saint Vincent'")
```

Diese Umkodierung ist nicht auf andere Datensätze übertragbar - wir müssen immer in den Daten die vorliegen nachgucken, welche Schritte zum Angleichen verschiedener Datensätze notwendig sind.

Wir können den Datensatz auf das letzte Jahr beschränken, das wir vorliegen haben (2017):

```{r}
edu_2017 <- subset(edu_exp, Year == 2017)
```

Anschließend können wir den Datensatz mit der Weltkarte zusammenführen. Dafür verwenden wir wieder den `merge` Befehl. Damit nach dem `merge` die Grenzen richtig gezeichnet werden, müssen wieder die Reihenfolge der Daten wiederherstellen. Dazu wird mit `order` nach Land (`group`) und dann nach Reihenfolge der Grenzpunkte (`order`) sortiert.

```{r}
edu_map <- merge(welt, edu_2017, 
  by.x = 'region', by.y = 'Country', 
  all.x = TRUE, all.y = FALSE)
edu_map <- edu_map[order(edu_map$group, edu_map$order), ]
```

Mit den neuen Daten können wir unsere vorherige Karte jetzt so ergänzen, dass wir die Länder nach der Anzahl der Fälle einfärben:

```{r, fig = TRUE, fig.height=3.5}
ggplot(edu_map, aes(x = long, y = lat, group = group)) +
  geom_polygon(color = 'black', lwd = .25, 
    aes(fill = Index)) +
  theme_void() + 
  scale_fill_pandar(discrete = FALSE, na.value = 'grey95')
```
