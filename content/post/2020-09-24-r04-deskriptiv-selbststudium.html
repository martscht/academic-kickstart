---
title: R Deskriptivstatistik
date: '2020-09-24'
slug: r-deskriptiv
categories:
  - BSc2
tags:
  - R Deskriprivstatistik
subtitle: ''
summary: ''
authors: [buchholz]
lastmod: '2020-09-24T20:54:18+02:00'
featured: no
header:
  image: "/header/descriptive_post.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/1227907)"
projects: []
---



<details>
<p><summary>Kernfragen dieser Lehreinheit</summary></p>
<ul>
<li>Wie werden <strong>Häufigkeitstabellen</strong> erstellt?<br />
</li>
<li>Wie können aus absoluten Häufigkeitstabellen <strong>relative Häufigkeitstabellen</strong> gemacht werden?<br />
</li>
<li>Wie können <strong>Modus und Median</strong> bestimmt werden?<br />
</li>
<li>Auf welche Weise lässt sich der <strong>relative Informationsgehalt</strong> bestimmen, obwohl es dafür in R keine Funktion gibt?<br />
</li>
<li>Welche Befehle können genutzt werden, um <strong>Balken- und Kuchendiagramme</strong> zu erzeugen?<br />
</li>
<li>Welche Möglichkeiten gibt es, um <strong>Grafiken anzupassen</strong>?<br />
</li>
<li>Wie können <strong>Grafiken gespeichert</strong> werden?</li>
<li>Wie können in R <strong>Histogramme</strong> erstellt werden? Wie lassen sich die Kategorienbreiten verändern?</li>
<li>Was ist der Befehl um den <strong>Mittelwert</strong> zu bestimmen?</li>
<li>Wie kann die <strong>empirische Varianz</strong> bestimmt werden? Wie unterscheidet sich diese von der mit <code>var()</code> bestimmten Varianz?</li>
<li>Wie können Variablen <strong>zentriert und standardisiert</strong> werden?</li>
<li>Welche Möglichkeiten gibt es, negativ formulierte Items zu <strong>rekodieren</strong>?</li>
<li>Mit welchen Befehlen können in R <strong>Skalenwerte</strong> für Fragebögenitems erstellt werden?</li>
</ul>
</details>
<hr />
<div id="wiederholung-aus-der-vorlesung-skalenniveaus" class="section level2">
<h2>Wiederholung aus der Vorlesung: Skalenniveaus</h2>
<table>
<colgroup>
<col width="6%" />
<col width="24%" />
<col width="16%" />
<col width="20%" />
<col width="34%" />
</colgroup>
<thead>
<tr class="header">
<th>Skala</th>
<th>Aussage</th>
<th>Transformation</th>
<th>Zentrale Lage</th>
<th>Dispersion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nominal</td>
<td>Äquivalenz</td>
<td>eineindeutig</td>
<td>Modus</td>
<td>Relativer Informationsgehalt</td>
</tr>
<tr class="even">
<td>Ordinal</td>
<td>Ordnung</td>
<td>monoton</td>
<td>Median</td>
<td>Interquartilsbereich</td>
</tr>
<tr class="odd">
<td>Intervall</td>
<td>Verhältnis von Differenzen</td>
<td>positiv linear</td>
<td>Mittelwert</td>
<td>Standardabweichung, Varianz</td>
</tr>
<tr class="even">
<td>Verhältnis</td>
<td>Verhältnisse</td>
<td>Ähnlichkeit</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="odd">
<td>Absolut</td>
<td>absoluter Wert</td>
<td>Identität</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<hr />
</div>
<div id="vorbereitende-schritte" class="section level2">
<h2>Vorbereitende Schritte</h2>
<pre class="r"><code>load(&#39;fb19.rda&#39;)   # Daten laden
names(fb19)        # Namen der Variablen</code></pre>
<pre><code>##  [1] &quot;mdbf1&quot;      &quot;mdbf2&quot;      &quot;mdbf3&quot;      &quot;mdbf4&quot;      &quot;mdbf5&quot;     
##  [6] &quot;mdbf6&quot;      &quot;mdbf7&quot;      &quot;mdbf8&quot;      &quot;mdbf9&quot;      &quot;mdbf10&quot;    
## [11] &quot;mdbf11&quot;     &quot;mdbf12&quot;     &quot;lz&quot;         &quot;extra&quot;      &quot;vertr&quot;     
## [16] &quot;gewis&quot;      &quot;neuro&quot;      &quot;intel&quot;      &quot;pro&quot;        &quot;grund&quot;     
## [21] &quot;fach&quot;       &quot;ziel&quot;       &quot;ziel_sonst&quot; &quot;lerntyp&quot;    &quot;geschl&quot;    
## [26] &quot;job&quot;        &quot;ort&quot;        &quot;ort12&quot;      &quot;wohnen&quot;     &quot;uni1&quot;      
## [31] &quot;uni2&quot;       &quot;uni3&quot;       &quot;uni4&quot;</code></pre>
<pre class="r"><code>dim(fb19)          # Anzahl Zeile und Spalten</code></pre>
<pre><code>## [1] 118  33</code></pre>
<p>Der Datensatz hat also 118 Beobachtungen auf 33 Variablen.</p>
<hr />
</div>
<div id="nominalskalierte-variablen" class="section level2">
<h2>Nominalskalierte Variablen</h2>
<p>Typische Beispiele für nominalskalierte Variablen in der Psychologie sind das Geschlecht (z.B. Variable “geschl” in <code>erstis</code>), die Experimentalbedingung (z.B. “UV” und “AV”), die Gruppenzugehörigkeit, … Nominalskalierte Variablen sollten in <code>R</code> als <strong>Faktoren</strong> hinterlegt werden. Faktoren in <code>R</code> sind Vektoren mit einer vorab definierten Menge an vorgegebenen möglichen Ausprägungen. Sowohl numerische als auch character-Variablen können als Faktor kodiert werden, was mit jeweiligen Vorteilen einhergeht:</p>
<ul>
<li>für numerische Variablen: es können (aussagekräftige) Labels zugewiesen (“hinterlegt”) werden. Diese werden dann für Tabellen und Grafiken übernommen<br />
</li>
<li>Für character-Variablen: Faktoren können für Analysen verwendet werden (z.B. als Prädiktoren in einer Regression), was für character-Variablen nicht möglich gewesen wäre</li>
</ul>
<p>Jeder numerischen Faktorstufe (level) kann ein Label zugewiesen werden. Faktorstufe und –label bestehen auch dann, wenn die entsprechende Ausprägung empirisch nicht auftritt.</p>
<p><strong>Beispiel 1: Die (numerische) Variable <code>geschl</code> als Faktor aufbereiten</strong></p>
<pre class="r"><code>str(fb19$geschl)</code></pre>
<pre><code>##  int [1:118] 1 1 1 2 NA 1 1 1 1 1 ...</code></pre>
<pre class="r"><code>fb19$geschl</code></pre>
<pre><code>##   [1]  1  1  1  2 NA  1  1  1  1  1  1  1  1  2  1  1  2  1  1  2  1  1  2  1  2
##  [26]  1  2  1  1  1  1  1  1  1  1  2  1  2  2  1  1  1  2  2  1  1  2  2  1  1
##  [51]  1  1  2  1  1  1  2  2  1  1  1  1  1  1 NA  2  2  1  1  1  1  2  2  2  1
##  [76]  1  1  1  2  1  1  1  1  2  1  1  1  1  1  1  1  1  1  1  2  1  1  1  1  2
## [101]  1  2 NA  1  1  1  1  1  1  1  2  1  1  1  2  2  1  1</code></pre>
<p>Die Variable <code>geschl</code> liegt numerisch vor, es treten die Werte 1 und 2 empirisch auf. Anhand des Kodierschemas (Datei <strong>Variablenübersicht.docx</strong>) kann den Zahlen eine inhaltliche Bedeutung zugewiesen werden. Beispielsweise bedeutet der Wert 1 “weiblich”. Diese <em>Label</em> werden nun im Faktor hinterlegt.</p>
<p>Vorgehensweise:</p>
<ul>
<li>Erstellung einer neuen Variable im Datensatz per Objektzuweisung: <code>datensatz$neueVariable &lt;- factor(...)</code><br />
</li>
<li>Faktor erstellen mit der Funktion <code>factor( Ausgangsvariable , levels = Stufen , labels = Label )</code><br />
</li>
<li>Spezifikation der Faktorstufen im Argument <code>levels</code>, also der numerischen Ausprägungen auf der Ursprungsvariable (hier: 1, 2, und 3)<br />
</li>
<li>Spezifikation des Arguments <code>labels</code>, also die Label für die in <code>levels</code> hinterlegten numerischen Stufen (hier: “weiblich”, “männlich”, “anderes”; unbedingt auf gleiche Reihenfolge achten!)</li>
</ul>
<pre class="r"><code>fb19$geschl_faktor &lt;- factor(fb19$geschl,                                   # Ausgangsvariable
                             levels = 1:3,                                  # Faktorstufen
                             labels = c(&quot;weiblich&quot;, &quot;männlich&quot;, &quot;anderes&quot;)) # Label für Faktorstufen
str(fb19$geschl_faktor)</code></pre>
<pre><code>##  Factor w/ 3 levels &quot;weiblich&quot;,&quot;männlich&quot;,..: 1 1 1 2 NA 1 1 1 1 1 ...</code></pre>
<pre class="r"><code>head(fb19$geschl_faktor)</code></pre>
<pre><code>## [1] weiblich weiblich weiblich männlich &lt;NA&gt;     weiblich
## Levels: weiblich männlich anderes</code></pre>
<p><strong>Beispiel 2: Lieblingsfach (numerisch) als Faktor aufbereiten</strong></p>
<p>Analog dazu wird nachfolgend die ebenfalls numerische Variable <code>fach</code> in einen Faktor umgewandelt. Sie wurde wie folgt erhoben:</p>
<p><img src="/post/SoSci-Screenshot-Fach.jpg" /></p>
<pre class="r"><code>fb19$fach</code></pre>
<pre><code>##   [1]  1  4  3  4  4  4  2  5  3  1  4  2  3  4  4  1  1  2  2  2  1  1  4  3  1
##  [26]  2  1  1  3  1  3 NA  4  2  2  4  3  4  1  2  5  2  4  3  1  2  1  2  4  4
##  [51]  4  2  1  4  4  1  4  5  4  2  1  4  4  3 NA  1  4  1  3  4  3  3  3  1  4
##  [76]  3  2  4  2  1  2  3  5  4  1  4  1  4  2  1  4  3  3  5  4  3  4  4  3  3
## [101]  4  1 NA  1  1  4  4  1  2  4  4  1  1  4  2  1  2  4</code></pre>
<p>Es treten die Ausprägungen 1 bis 5 empirisch auf. Auch hier werden die Label aus dem Kodierschema zugewiesen.</p>
<pre class="r"><code>fb19$fach &lt;- factor(fb19$fach, 
                    levels = 1:5,
                    labels = c(&#39;Allgemeine&#39;, &#39;Biologische&#39;, &#39;Entwicklung&#39;, &#39;Klinische&#39;, &#39;Diag./Meth.&#39;))
str(fb19$fach)</code></pre>
<pre><code>##  Factor w/ 5 levels &quot;Allgemeine&quot;,&quot;Biologische&quot;,..: 1 4 3 4 4 4 2 5 3 1 ...</code></pre>
<p>Hinweis: In Beispiel 2 wurde die Ursprungsvariable mit dem Faktor überschrieben. Sie ist nun verschwunden, der Datensatz enthält nur noch den Faktor, nicht mehr die numerische Variable.</p>
<p><strong>Beispiel 3: Einen character-Vektor als Faktor aufbereiten</strong></p>
<p>Um einen character-Vektor in einen Faktor umzukodieren, kann die Funktion <code>as.factor()</code> verwendet werden (siehe Skript zur Lehreinheit 1). Die Ausprägungen werden dann automatisch als Labels übernommen. Die Stufen (<code>levels</code>) werden in alphabetischer Reihenfolge vergeben.</p>
<p>Nachfolgend wird zur Illustration die offenene Freitextantwort zum Grund für das Psychologiestudium (Variable <code>grund</code>) in einen Faktor umgewandelt. Dies ist nicht sinnvoll, da jede einzelne Freitextantwort vermutlich nur genau einmal vorkommt und später sowieso nicht (ohne zusätzliche Kodierung) in statistischen Analysen weiterverwendet werden kann.</p>
<pre class="r"><code>str(fb19$grund)                            # Ursprungsvariable: Character</code></pre>
<pre><code>##  chr [1:118] &quot;Ich hatte keine Ahnung, was ich machen soll und es klang ziemlich interessant. Dachte mir dann, warum nicht?&quot; ...</code></pre>
<pre class="r"><code>fb19$grund_faktor &lt;- as.factor(fb19$grund) # Umwandlung in Faktor
str(fb19$grund_faktor)                     # neue Variable: Faktor</code></pre>
<pre><code>##  Factor w/ 93 levels &quot;&quot;,&quot;- Arbeitsfelder, die sich mit dem Menschen befassen, sind interessant für mich\n- ich bin ein empathischer Mens&quot;| __truncated__,..: 35 93 92 53 87 84 16 1 86 54 ...</code></pre>
<p><strong>Hinweise zu den Levels und Labels</strong></p>
<p>Die Reihenfolge von Levels und Labels ergibt sich während der Faktorerstellung:</p>
<ul>
<li>bei numerischen Variablen: entspricht den Ausprägungen der numerischen Ursprungsvariable<br />
</li>
<li>bei character-Variablen: entspricht der alphabetischen Reihenfolge der Ausprägungen auf der Ursprungsvariable</li>
</ul>
<p>Die Labels eines Faktors können mit der Funktion <code>levels()</code> abgerufen werden. Die Reihenfolge kann mithilfe der <code>relevel()</code>-Funktion geändert werden. Dafür muss dasjenige Label angesprochen werden, das die erste Position einnehmen soll (hier: ‘Diag./Meth.’).</p>
<pre class="r"><code>levels(fb19$fach)         # Abruf</code></pre>
<pre><code>## [1] &quot;Allgemeine&quot;  &quot;Biologische&quot; &quot;Entwicklung&quot; &quot;Klinische&quot;   &quot;Diag./Meth.&quot;</code></pre>
<pre class="r"><code>fb19$fach &lt;- relevel(
  fb19$fach,              # Bezugskategorie wechseln
  &#39;Diag./Meth.&#39;)          # Neue Bezugskategorie</code></pre>
<hr />
</div>
<div id="häufigkeitstabellen" class="section level2">
<h2>Häufigkeitstabellen</h2>
<p>Eine deskriptivstatistische Möglichkeit zur Darstellung diskreter (zählbarer) nominalskalierter Variablen sind Häufigkeitstabellen. Diese können in <code>R</code> mit der Funktion <code>table()</code> angefordert werden.</p>
<p><strong>Absolute Häufigkeiten</strong></p>
<pre class="r"><code>table(fb19$fach)</code></pre>
<pre><code>## 
## Diag./Meth.  Allgemeine Biologische Entwicklung   Klinische 
##           5          30          21          20          39</code></pre>
<p>Häufig sind relative Häufigkeiten informativer. Nachfolgend werden zwei Möglichkeiten zur Erstellung von relativen Häufigkeitstabellen in <code>R</code> gezeigt.</p>
<p><strong>Relative Häufigkeiten (manuell)</strong></p>
<p>Relative Häufigkeiten können aus absoluten Häufigkeiten abgeleitet werden: <span class="math inline">\(h_j = \frac{n_j}{n}\)</span>.</p>
<p>Diese einfache Rechenvorschrift (Kategorienhäufigkeit geteilt durch Gesamthäufigkeit) kann auf das gesamte Tabellenobjekt angewendet werden. So wird jede einzelne absolute Kategorienhäufigkeit am Gesamtwert relativiert, es resultiert eine Tabelle der relativen Häufigkeiten.</p>
<pre class="r"><code>tab &lt;- table(fb19$fach) # Absolute Haeufigkeiten
sum(tab)                # Gesamtzahl</code></pre>
<pre><code>## [1] 115</code></pre>
<pre class="r"><code>tab / sum(tab)          # Relative Haeufigkeiten</code></pre>
<pre><code>## 
## Diag./Meth.  Allgemeine Biologische Entwicklung   Klinische 
##  0.04347826  0.26086957  0.18260870  0.17391304  0.33913043</code></pre>
<p><strong>Relative Häufigkeiten (per Funktion)</strong></p>
<p>Alternativ kann die Funktion <code>prop.table()</code> auf das Tabellenobjekt mit den absoluten Häufigkeiten angewendet werden.</p>
<pre class="r"><code>tab &lt;- table(fb19$fach) # Absolute
prop.table(tab)         # Relative</code></pre>
<pre><code>## 
## Diag./Meth.  Allgemeine Biologische Entwicklung   Klinische 
##  0.04347826  0.26086957  0.18260870  0.17391304  0.33913043</code></pre>
<p>Nicht einmal 5% Ihres Jahrgangs geben als Lieblingsfach “Diagnostik/Methoden” an! Vielleicht können wir Sie mit dem nächsten Thema begeistern. :-)</p>
<hr />
</div>
<div id="grafiken-in-r" class="section level2">
<h2>Grafiken in <code>R</code></h2>
<p>Die Darstellung als Tabelle wirkt häufig langweilig. Zu viele Tabellen in einem Bericht / einer Arbeit schrecken Leser meist ab. Nachfolgend werden grafische Darstellungsformen für diskrete nominalskalierte Variablen gezeigt.</p>
<p><strong>Säulen- oder Balkendiagramm</strong></p>
<pre class="r"><code>barplot(tab)</code></pre>
<p>Die Grafik erscheint in der RStudio-Standardansicht “unten rechts” im Reiter “Plots”:</p>
<p><img src="/post/Screenshot-Barplot.PNG" /></p>
<p><strong>Kuchendiagramm</strong></p>
<pre class="r"><code>pie(tab)</code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-12-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p><strong>Zusatzargumente für Plots</strong></p>
<p>Die Funktionen zur Erstellung sehr einfacher Grafiken sind also denkbar einfach - die Grafiken selbst aber zunächst nicht unbedingt hübsch. <code>R</code> bietet diverse Zusatzargumente zur Anpassung der Optik von Grafiken.</p>
<table>
<thead>
<tr class="header">
<th align="right">Argument</th>
<th align="left">Bedeutung</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">main</td>
<td align="left">Überschrift</td>
</tr>
<tr class="even">
<td align="right">las</td>
<td align="left">Schriftausrichtung (0, 1, 2, 3)</td>
</tr>
<tr class="odd">
<td align="right">col</td>
<td align="left">Farbenvektor</td>
</tr>
<tr class="even">
<td align="right">horiz</td>
<td align="left">Horizontale Balkenausrichtung (TRUE/FALSE)</td>
</tr>
<tr class="odd">
<td align="right">legend.text</td>
<td align="left">Beschriftung in der Legende</td>
</tr>
<tr class="even">
<td align="right">xlim, ylim</td>
<td align="left">Beschränkung der Achsen</td>
</tr>
<tr class="odd">
<td align="right">xlab, ylab</td>
<td align="left">Beschriftung der Achsen</td>
</tr>
</tbody>
</table>
<p><strong>Farben in <code>R</code></strong></p>
<p><code>R</code> kennt eine ganze Reihe vordefinierter Farben (<span class="math inline">\(N = 657\)</span>) mit teilweise sehr poetischen Namen. Diese können mit der Funktion <code>colors()</code> (ohne Argument) abgerufen werden. Hier sind die ersten 20 Treffer:</p>
<pre class="r"><code>colors()[1:20]</code></pre>
<pre><code>##  [1] &quot;white&quot;         &quot;aliceblue&quot;     &quot;antiquewhite&quot;  &quot;antiquewhite1&quot;
##  [5] &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; &quot;antiquewhite4&quot; &quot;aquamarine&quot;   
##  [9] &quot;aquamarine1&quot;   &quot;aquamarine2&quot;   &quot;aquamarine3&quot;   &quot;aquamarine4&quot;  
## [13] &quot;azure&quot;         &quot;azure1&quot;        &quot;azure2&quot;        &quot;azure3&quot;       
## [17] &quot;azure4&quot;        &quot;beige&quot;         &quot;bisque&quot;        &quot;bisque1&quot;</code></pre>
<p>Die Farben aus der Liste können als Zahl (Index) oder per Name angesprochen werden. Eine vollständige Liste der Farben findet sich zum Beispiel unter <a href="http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf">http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf</a>. Farben können aber auch per RGB-Vektor (Funktion <code>rgb()</code>) oder HEX-Wert angesprochen werden.</p>
<p>Zusätzlich können Farbpaletten verwendet werden. Sie bestehen aus einem Farbverlauf, aus dem einzelne Farben “herausgezogen” werden, wodurch ein zusammengehöriges Farbthema in einer Abbildung entsteht. <code>R</code> liefert einige dieser Paletten: <code>rainbow(...)</code>, <code>heat.colors(...)</code>, <code>topo.colors(...)</code>, … Die Farbpalette wird ebenfalls per <code>col</code>-Argugment spezifiziert. Technisch handelt es sich um eine Funktion, für die als Argument die Anzahl der Farben spezifiziert werden muss, die aus der Palette “gezogen” werden sollen. Beispielsweise werden mit <code>col = rainbow(5)</code> fünf Farben aus der rainbow-Palette gezogen.</p>
<p><strong>Beispiel für angepasste Abbildung</strong></p>
<pre class="r"><code>barplot(tab,
 col = rainbow(20),
 xlab = &#39;Studierende (Anzahl)&#39;,
 main = &#39;Lieblingsfach im 1. Semester&#39;, 
 las=1)</code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p><strong>Grafiken speichern</strong></p>
<p>Es gibt zwei Möglichkeiten, um in <code>R</code> erzeugte Grafiken als Bilddatei zu speichern: manuell und per Funktion.</p>
<p><em>Möglichkeit 1: Manuelles Speichern</em></p>
<p>Klicken Sie auf die Schaltfläche “Export” und dann auf “Save as Image”…</p>
<p><img src="/post/Screenshot-Export.PNG" /></p>
<p>…und spezifizieren Sie dann Dateiname (ggf. Pfad) und Größe/Größenverhältnis.</p>
<p><img src="/post/Screenshot-Export2.PNG" /></p>
<p>Wenn kein Pfad spezifiziert wird, erscheint die Datei in Ihrem aktuellen Arbeitsverzeichnis.</p>
<p><img src="/post/Screenshot-jpeg.PNG" /></p>
<p><em>Möglichkeit 2: Speichern mit der Funktion <code>jpeg(&quot;Dateiname.jpg&quot;)</code></em></p>
<p>Die Grafikerstellung folgt auf die <code>jpeg()</code>-Funktion und wird mit der Funktion <code>dev.off()</code> abgeschlossen.</p>
<pre class="r"><code>jpeg(&quot;Mein-Boxplot.jpg&quot;, width=15, height=10, units=&quot;cm&quot;, res=150)
barplot(tab,
 col = rainbow(20),
 xlab = &#39;Studierende (Anzahl)&#39;,
 main = &#39;Lieblingsfach im 1. Semester&#39;, 
 las=1)
dev.off()</code></pre>
<p>Auch hier gilt: Wenn kein Pfad spezifiziert wurde, liegt die Datei in Ihrem Arbeitsverzeichnis. In der Funktion <code>jpeg()</code> kann mit den Argumenten <code>width</code>, <code>height</code>, <code>units</code> und <code>res</code> Größe, Größenverhältnis und Auflösung gesteuert werden.</p>
<hr />
</div>
<div id="deskriptivstatistische-kennwerte-auf-nominalskalenniveau" class="section level2">
<h2>Deskriptivstatistische Kennwerte auf Nominalskalenniveau</h2>
<p><strong>Modus</strong></p>
<p>Der Modus (<em>Mo</em>) ist ein Maß der zentralen Tendenz, das die häufigste Ausprägung einer Variablen anzeigt. Die Häufigkeiten sind ja schon in der Häufigkeitstabelle enthalten. Man könnte den Modus also einfach ablesen. Das gleiche lässt sich allerdings auch anhand von Funktionen tun:</p>
<pre class="r"><code>tab            # Tabelle ausgeben</code></pre>
<pre><code>## 
## Diag./Meth.  Allgemeine Biologische Entwicklung   Klinische 
##           5          30          21          20          39</code></pre>
<pre class="r"><code>max(tab)       # Größte Häufigkeit</code></pre>
<pre><code>## [1] 39</code></pre>
<pre class="r"><code>which.max(tab) # Modus</code></pre>
<pre><code>## Klinische 
##         5</code></pre>
<p>Der Modus der Variable <code>fach</code> lautet also Klinische, die Ausprägung trat 39 mal auf.</p>
<p><strong>Relativer Informationsgehalt</strong></p>
<p>Der relative Informationsgehalt ist ein Dispersionsmaß, das schon auf Nominalskalenniveau funktioniert. Dafür gibt es in <code>R</code> allerdings keine Funktion! Aus Lehreinheit 1 wissen Sie jedoch, dass <code>R</code> als Taschenrechner genutzt werden kann, folglich können beliebig komplexe Gleichungen in <code>R</code> umgesetzt werden. Die Formel zur Berechnung des relativen Informationsgehalts <span class="math inline">\(H\)</span> lautet:</p>
<p><span class="math display">\[H = -\frac{1}{\ln(k)} \sum_{j=1}^k{h_j * \ln h_j} \]</span></p>
<p><span class="math inline">\(n_j\)</span> bezeichnet alle gültigen Antworten und kann als Summe der Häufigkeiten in <code>tab</code> abgelesen werden.</p>
<pre class="r"><code>hj &lt;- prop.table(tab)       # hj erstellen
ln_hj &lt;- log(hj)            # Logarithmus bestimmen
ln_hj                       # Ergebnisse für jede Kategorie</code></pre>
<pre><code>## 
## Diag./Meth.  Allgemeine Biologische Entwicklung   Klinische 
##   -3.135494   -1.343735   -1.700410   -1.749200   -1.081370</code></pre>
<pre class="r"><code>summand &lt;- ln_hj * hj       # Berechnung für jede Kategorie
summe &lt;- sum(summand)       # Gesamtsumme
relinf &lt;- -1/log(5) * summe # Relativer Informationsgehalt
relinf</code></pre>
<pre><code>## [1] 0.9123118</code></pre>
<p>Eine alternative Schreibweise, die ohne Zwischenschritte auskommt, dafür aber stark verschachtelt ist, lautet:</p>
<pre class="r"><code>- 1/log(5) * sum(prop.table(table(fb19$fach)) * log(prop.table(table(fb19$fach))))</code></pre>
<pre><code>## [1] 0.9123118</code></pre>
<p>Der relative Informationsgehalt der Variable <code>fach</code> beträgt demnach 0.912.</p>
<hr />
</div>
<div id="ordinalskalierte-variablen" class="section level2">
<h2>Ordinalskalierte Variablen</h2>
<p>In diesem Abschnitt lernen Sie deskriptivstatistische Kennwerte für ordinalskalierte Variablen kennen. Aus der Vorlesung wissen Sie schon, dass Median und Interquartilsabstand (IQB) nur für die Klasse der geordneten Kategorien (auch “Rangklassen”) sinnvoll sind, nicht für singuläre Daten (“Rangwerte”).</p>
<p>Zunächst aber eine Wiederholung: Wie Sie aus der Vorlesung wissen, könnnen die in der Tabelle am Anfang dieses Dokuments aufgeführten statistischen Kennwerte (Zentrale Lage, Dispersion) auch für Skalenniveaus genutzt werden, die “weiter unten” in der Tabelle stehen. Für ordinalskalierte Variablen (Rangklassen) kann also auch der Modus berechnet werden.</p>
<p>Nachfolgend soll mit Item 4 des mdbf gearbeitet werden. Es wurde wie folgt erhoben:</p>
<p><img src="/post/SoSci-Screenshot-mdbf.jpg" /></p>
<p>Es treten die Werte 1 bis 4 empirisch auf, außerdem gibt es einen fehlenden Wert (dargestellt als <code>NA</code>):</p>
<pre class="r"><code>fb19$mdbf4</code></pre>
<pre><code>##   [1]  1  3  1  2  4  2  3  1  1  1  3  1  2  2  2  3  1  3  2  3  1  2  2  2  1
##  [26]  1  1  1  1  4  1  3  2  1  2  1  1  1  2  2  1  2  2  1  1  2  1  2  1  1
##  [51]  2  1  3  1  4  2  4  2  1  2  2  1  1  1  2  3  3  2  1  1  3  2  2  1  2
##  [76]  1  1 NA  1  1  2  4  2  3  1  2  1  3  1  1  3  1  3  2  1  1  1  1  1  2
## [101]  1  4  1  1  3  3  2  4  3  3  3  1  1  1  1  1  2  1</code></pre>
<p>Wiederholung:</p>
<pre class="r"><code>table(fb19$mdbf4)               # Absolute Haeufigkeiten</code></pre>
<pre><code>## 
##  1  2  3  4 
## 56 34 20  7</code></pre>
<pre class="r"><code>prop.table(table(fb19$mdbf4))   # Relative Haeufigkeiten</code></pre>
<pre><code>## 
##          1          2          3          4 
## 0.47863248 0.29059829 0.17094017 0.05982906</code></pre>
<pre class="r"><code>which.max(table(fb19$mdbf4))    # Modus</code></pre>
<pre><code>## 1 
## 1</code></pre>
<p><strong>Fehlende Werte</strong></p>
<p>Fehlende Werte in empirischen Untersuchungen können aus vielen Gründen auftreten:</p>
<ul>
<li>Fragen überlesen / nicht gesehen<br />
</li>
<li>Antwort verweigert<br />
</li>
<li>Unzulässige Angaben gemacht (im Papierformat)<br />
</li>
<li>Unleserliche Schrift (im Papierformat)</li>
<li>…</li>
</ul>
<p>Für statistische Analysen sind fehlende Werte ein Problem, weil sie außerhalb der zulässigen Antworten liegen.</p>
<p><strong>Fehlende Werte in <code>R</code></strong></p>
<p>Fehlende Werte werden im Datensatz als <code>NA</code> dargestellt. In <code>R</code> kann man solche Fälle auf zwei unterschiedlichen Ebenen berücksichtigen:</p>
<ul>
<li>Global: <code>na.omit(datensatz)</code>
<ul>
<li>Entfernt <em>alle</em> Beobachtungen, die auf <em>irgendeiner</em> Variable einen fehlenden Wert haben<br />
</li>
<li>Häufig auch “listenweiser Fallausschluss” gennant<br />
</li>
</ul></li>
<li>Lokal: <code>na.rm = TRUE</code>
<ul>
<li>Das Argument <code>na.rm</code> ist in vielen Funktionen für univariate Statistiken enthalten<br />
</li>
<li>Per Voreinstellung wird <code>NA</code> als Ergebnis produziert, wenn fehlende Werte vorliegen<br />
</li>
<li>Fehlende Werte werden nur für diese eine Analyse ausgeschlossen, Datensatz bleibt erhalten</li>
</ul></li>
</ul>
<hr />
</div>
<div id="deskriptivstatistische-kennwerte-ab-ordinalskalenniveau" class="section level2">
<h2>Deskriptivstatistische Kennwerte ab Ordinalskalenniveau</h2>
<p><strong>Median für ordinalskalierte Variablen</strong></p>
<pre class="r"><code>median(fb19$mdbf4)                 # Ohne Argument für NA: funktioniert nicht</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>median(fb19$mdbf4, na.rm = TRUE)   # Expliziter Ausschluss: funktioniert</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Der Median für die Variable <code>mdbf4</code> beträgt also 2.</p>
<p><strong>Quantile und IQB</strong></p>
<p>Für eine Beschreibung der Dispersion wird häufig der Interquartilsbereich (IQB) genutzt. IQB ist der Bereich zwischen dem 1. und dem 3. Quartil. Auch dafür gibt es keine Funktion in <code>R</code>, das Dispersionsmaß kann aber einfach “per Hand” selbst berechnet werden:</p>
<p><span class="math display">\[IQB = Q_3 - Q_1\]</span></p>
<p>Um die Quartile oder jedes beliebige andere Quantil einer Verteilung zu erhalten, kann die Funktion <code>quantile()</code> verwendet werden:</p>
<pre class="r"><code>quantile(fb19$mdbf4,
         c(.25, .5, .75),                   # Quartile anfordern
         na.rm = T)</code></pre>
<pre><code>## 25% 50% 75% 
##   1   2   2</code></pre>
<p>Zur Berechnung des IQB wird nun die Differenz aus drittem und ersten Quartil gebildet:</p>
<pre class="r"><code>quantile(fb19$mdbf4, .75, na.rm=T) - quantile(fb19$mdbf4, .25, na.rm=T) </code></pre>
<pre><code>## 75% 
##   1</code></pre>
<p>Der IQB der Variable <code>mdbf4</code> beträgt 1.</p>
<hr />
</div>
<div id="boxplots" class="section level2">
<h2>Boxplots</h2>
<p>Eine geeignete grafische Darstellungsform für (mindestens) ordinalskalierte Daten ist der Boxplot. Er kann über die Funktion <code>boxplot()</code> angefordert werden:</p>
<pre class="r"><code>boxplot(fb19$mdbf4)</code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>Zur Erinnerung:</p>
<ul>
<li>Box: Quartile<br />
</li>
<li>Whisker: der jeweils extremste empirische Wert im Bereich <code>Q3 + 1.5*IQB</code> für das Maximum bzw. <code>Q1 - 1.5*IQB</code> für das Minimum<br />
</li>
<li>Noch extremere Werte werden als Punkte dargestellt</li>
</ul>
<p>In diesem Beispiel betragen Median und Q3 jeweils 2, sodass sich die entsprechenden Linien überlagern. Ein Beispiel für einen “schöneren” Boxplot (ohne Überlagerung) ist dieses:</p>
<pre class="r"><code>boxplot(fb19$mdbf2)</code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<p>Auch ein Boxplot kann grafisch angepasst werden. Nachfolgend sehen Sie ein Beispiel, in dem möglichst viel verändert wurde, um die verschiedenen Möglichkeiten aufzuzeigen. Nicht alle Veränderungen sind unbedingt sinnvoll.</p>
<pre class="r"><code>boxplot(fb19$mdbf2,
        horizontal = TRUE,
        main = &quot;WS 2019/2020: Item mdbf1&quot;,
        xlab = &quot;Ausprägung&quot;,
        las = 1,
        width = 2, 
        notch = TRUE,
        border = &quot;red&quot;,
        col = &quot;pink1&quot;)</code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<hr />
<div id="kurzer-exkurs--" class="section level3">
<h3>Kurzer Exkurs :-)</h3>
<pre class="r"><code>install.packages(&quot;RXKCD&quot;)
library(&quot;RXKCD&quot;)
searchXKCD(&quot;significant&quot;)
getXKCD(539)</code></pre>
<p><img src="/post/XKCD-boxplot.PNG" /></p>
<hr />
</div>
</div>
<div id="kardinalskalierte-variablen" class="section level2">
<h2>Kardinalskalierte Variablen</h2>
<div id="klassische-kardinalskalierte-variablen" class="section level3">
<h3>Klassische kardinalskalierte Variablen</h3>
<ul>
<li>Behaviorale Maße: Reaktionszeiten, Bearbeitungsdauer, Anzahl von Fehlern, …</li>
<li>Biologische Maße: Hautleitfähigkeit, Stimmhöhe, Anzahl der Sakkaden, …</li>
<li>Neurophysiologische Maße: EEG-Daten, Durchblutung von Hirnregionen, …</li>
</ul>
</div>
<div id="konstruierte-kardinalskalierte-variablen" class="section level3">
<h3>Konstruierte kardinalskalierte Variablen</h3>
<ul>
<li>Fragebogendaten werden meist ordinalskaliert erhoben (einzelne Items)</li>
<li>Um Intervallskalenniveau zu erreichen werden Items zu Skalenwerten verrechnet (Summe oder Mittelwert)</li>
<li>Erzeugt viele mögliche Ausprägungen und wird als intervallskaliert behandelt</li>
</ul>
<div id="beispiel-lebenszufriedenheit" class="section level4">
<h4>Beispiel: Lebenszufriedenheit</h4>
<p><img src="/post/lz.bmp" /></p>
<p>Der Mittelwert pro Person über alle 5 Items ist in der Spalte <code>lz</code> zu finden:</p>
<pre class="r"><code>fb19$lz</code></pre>
<pre><code>##   [1] 5.60 4.40 3.40 5.40 3.60 4.40 6.00 4.80 4.80 5.20 3.20 6.40 5.20 5.00 4.40
##  [16] 5.40 4.00 4.00 4.60 2.40 6.40 3.40 4.80 4.60 7.00 4.20 6.20 5.20 6.20 3.80
##  [31] 6.60 5.80 5.80 3.00 2.00 5.60 5.40 3.80 4.20 6.20 4.80 4.00 4.60 7.00 5.40
##  [46] 5.20 5.20 4.80 6.40 6.40 4.20 5.80 3.40 6.40 6.00 4.60 4.40 5.60 7.00 5.60
##  [61] 3.60 4.60 4.80 6.00  NaN 6.00 6.60 5.20 6.20 4.80 5.00 4.80 5.00 5.60 5.40
##  [76] 6.00 6.40 5.40 5.20 4.80 6.00 5.00 5.20 4.20 4.00 6.40 6.80 5.40 5.60 4.80
##  [91] 3.40 5.20 3.00 6.40 6.60 5.60 4.60 3.60 4.40 3.20 4.20 1.80 5.80 4.40 4.80
## [106] 2.20 5.40 3.60 3.20 2.80 4.60 3.40 6.20 6.40 4.25 4.80 6.00 4.40</code></pre>
</div>
</div>
</div>
<div id="deskriptivstatistik-für-kardinalskalierte-variablen" class="section level2">
<h2>Deskriptivstatistik für kardinalskalierte Variablen</h2>
<ul>
<li>Verfahren sind “rückwärtskompatibel”, d.h. alle Berechnungen, die auf nominalskalierte und ordinalskalierte Variablen anwendbar sind, lassen sich auch auf kardinalskalierte Variablen anwenden.</li>
<li>Quantile, IQA und Median können weiterhin bestimmt werden</li>
</ul>
<pre class="r"><code># Minimum &amp; Maximum
range(fb19$lz, na.rm=T) </code></pre>
<pre><code>## [1] 1.8 7.0</code></pre>
<pre class="r"><code># Quartile
quantile(fb19$lz, c(.25, .5, .75), na.rm=T) </code></pre>
<pre><code>## 25% 50% 75% 
## 4.2 5.0 5.8</code></pre>
<pre class="r"><code>#Box-Whisker Plot
boxplot(fb19$lz) </code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
</div>
<div id="histogramme" class="section level2">
<h2>Histogramme</h2>
<ul>
<li>Zusammenfassung von Werten in Klassen (Kategorien, Intervalle)<br />
</li>
<li>Häufigkeitsverteilung für die kategorisierten Daten erstellen (sekundäre Häufigkeitsverteilung)<br />
</li>
<li>Achtung! Die Anzahl der Kategorien kann den Eindruck der Daten beeinflussen:</li>
</ul>
<pre class="r"><code># Histogramm
hist(fb19$lz) </code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<pre class="r"><code># Histogramm (20 Kategorien)
hist(fb19$lz, 
     breaks = 20) </code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-30-2.png" width="672" /></p>
<pre class="r"><code># Histogramm (ungleiche Kategorien)
hist(fb19$lz, 
     breaks = c(1, 3, 3.3, 3.6, 3.9, 4.5, 5, 7)) </code></pre>
<p><img src="/post/2020-09-24-r04-deskriptiv-selbststudium_files/figure-html/unnamed-chunk-30-3.png" width="672" /></p>
</div>
<div id="mittelwert" class="section level2">
<h2>Mittelwert</h2>
<p><strong>Formel:</strong> <span class="math inline">\({x} = \frac{\sum_{m = 1}^n x_m}{n} = \frac{1}{n} \sum_{m = 1}^n x_m\)</span></p>
<pre class="r"><code># Arithmetisches Mittel
mean(fb19$lz, na.rm = TRUE)</code></pre>
<pre><code>## [1] 4.942308</code></pre>
</div>
<div id="varianz" class="section level2">
<h2>Varianz</h2>
<p><strong>Formel:</strong> <span class="math inline">\(s^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n}\)</span></p>
<pre class="r"><code># Händische Varianzberechnung
sum((fb19$lz - mean(fb19$lz, na.rm = TRUE))^2, na.rm = TRUE) / (nrow(fb19)-1)</code></pre>
<pre><code>## [1] 1.306778</code></pre>
<p>Achtung! Wir benötigen für die Varianzberechnung <code>n</code> (s. Formel)! Wir nutzen hier <code>nrow(fb19)-1</code>, weil <code>nrow(fb19)</code> nicht das richtige n anzeigt (eine Person hat einen fehlenden Wert, daher die Anzahl an Zeilen minus der eine fehlende Wert = n)</p>
<p><strong>Kleiner Diskurs zu fehlenden Werten:</strong></p>
<p>Um zu prüfen, ob und wie viele fehlende Werte eine Variable hat, lässt sich z. B. folgende Syntax verwenden:</p>
<pre class="r"><code>sum(is.na(fb19$lz))</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Um die Länge einer Variablen ohne fehlende Werte (also die Anzahl an Beobachtungen auf einer Variablen) zu bestimmen, lässt sich z. B. folgende Syntax verwenden:</p>
<pre class="r"><code>length(na.omit(fb19$lz))</code></pre>
<pre><code>## [1] 117</code></pre>
<p>Zur händischen Varianzberechnung können wir daher auch folgende Syntax verwenden:</p>
<pre class="r"><code># Händische Varianzberechnung
sum((fb19$lz - mean(fb19$lz, na.rm = TRUE))^2, na.rm = TRUE) / (length(na.omit(fb19$lz)))</code></pre>
<pre><code>## [1] 1.306778</code></pre>
<div id="verschiedene-varianzschätzer" class="section level3">
<h3>Verschiedene Varianzschätzer</h3>
<p>Folgendes Ergebnis liefert R, wenn wir die R-Funktion <code>var()</code> zur Berechnung der Varianz verwenden:</p>
<pre class="r"><code># R-interne Varianzberechnung
var(fb19$lz, na.rm = TRUE)</code></pre>
<pre><code>## [1] 1.318044</code></pre>
<p>Warum erhalten wir hier einen abweichenden Wert im Vergleich zu unserer händischen Varianzberechnung?</p>
<p>Die meisten Programme berechnen nicht die empirische Varianz, sondern einen Schätzer der Populationsvarianz:</p>
<p><strong>Empirische Varianz</strong></p>
<p><span class="math inline">\(s^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n}\)</span></p>
<p><strong>Schätzer der Populationsvarianz</strong></p>
<p><span class="math inline">\(\hat{\sigma}^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n - 1}\)</span></p>
<p>Um in R die empirische Varianz mithilfe der <code>var()</code>-Funktion zu berechnen, kann man die Populationsvarianz nutzen. Multipliziert man sie mit <span class="math inline">\(\frac{n - 1}{n}\)</span> erhält man die empirische Varianz.</p>
<pre class="r"><code># Umrechnung der Varianzen
var(fb19$lz, na.rm = TRUE) * (nrow(fb19) - 1) / nrow(fb19)</code></pre>
<pre><code>## [1] 1.306874</code></pre>
<p>Achtung! Dies funktioniert in unserem Fall wieder nicht, da die Verwendung von <code>nrow(fb19)</code> - wie oben bereits angemerkt - nicht sinnvoll ist: <code>nrow(fb19)</code> ist nicht gleich n (eine Person hat einen fehlenden Wert), daher besser:</p>
<pre class="r"><code># Umrechnung der Varianzen
var(fb19$lz, na.rm = TRUE) * (length(na.omit(fb19$lz)) - 1) / (length(na.omit(fb19$lz)))</code></pre>
<pre><code>## [1] 1.306778</code></pre>
<p>Alternativ:</p>
<pre class="r"><code># Umrechnung der Varianzen
var(fb19$lz, na.rm = TRUE) * (117 - 1) / 117 </code></pre>
<pre><code>## [1] 1.306778</code></pre>
</div>
</div>
<div id="standardabweichung" class="section level2">
<h2>Standardabweichung</h2>
<p>Auch bei der Standardabweichung bestimmt R den Populationsschätzer <span class="math inline">\(\hat{\sigma}_{X}\)</span></p>
<pre class="r"><code># Standardabweichung in R
sd(fb19$lz, na.rm = TRUE) # Populationsschaetzer</code></pre>
<pre><code>## [1] 1.148061</code></pre>
<pre class="r"><code># Händische Berechnung der empirischen Standardabweichung
sqrt(sum((fb19$lz - mean(fb19$lz, na.rm = TRUE))^2, 
         na.rm = TRUE) / (length(na.omit(fb19$lz))))</code></pre>
<pre><code>## [1] 1.143144</code></pre>
</div>
<div id="zentrierung-und-standardisierung" class="section level2">
<h2>Zentrierung und Standardisierung</h2>
<p>Die Variablenzentrierung und -standardisierung lässt sich in R per Hand berechnen…</p>
<pre class="r"><code># Zentrierung
lz_c &lt;- fb19$lz - mean(fb19$lz, na.rm = TRUE)
head(lz_c)</code></pre>
<pre><code>## [1]  0.6576923 -0.5423077 -1.5423077  0.4576923 -1.3423077 -0.5423077</code></pre>
<pre class="r"><code># Standardisierung
lz_z &lt;- lz_c / sd(fb19$lz, na.rm = TRUE)
head(lz_z)</code></pre>
<pre><code>## [1]  0.5728723 -0.4723684 -1.3434024  0.3986655 -1.1691956 -0.4723684</code></pre>
<p>…oder mit Hilfe bereits existierender Funktionen:</p>
<pre class="r"><code>## Befehl zum Standardisieren
lz_z &lt;- scale(fb19$lz)
## Befehl zum Zentrieren (ohne Standardisierung)
lz_c &lt;- scale(fb19$lz,
              scale = FALSE) # unterbindet Standardisierung</code></pre>
</div>
<div id="skalenwerte" class="section level2">
<h2>Skalenwerte</h2>
<div id="wiederholung-konstruierte-kardinalskalierte-variablen" class="section level3">
<h3>Wiederholung: Konstruierte kardinalskalierte Variablen</h3>
<ul>
<li>Fragebogendaten werden meist ordinalskaliert erhoben (einzelne Items)</li>
<li>Um Intervallskalenniveau zu erreichen werden Items zu Skalenwerten verrechnet (Summe oder Mittelwert)</li>
<li>Erzeugt viele mögliche Ausprägungen und wird als intervallskaliert behandelt</li>
</ul>
</div>
<div id="positive-negative-items" class="section level3">
<h3>Positive &amp; Negative Items</h3>
<p>Viele Fragebögen enthalten sowohl positiv als auch negativ forumulierte Items</p>
<ul>
<li>…um die Befragung abwechslungsreich zu gestalten</li>
<li>…um das psychologische Konstrukt umfassender zu erheben</li>
<li>…um Antworttendenzen leichter identifizieren zu können</li>
</ul>
<p>Vor der Skalenbildung müssen alle Items in eine Richtung gebracht werden:
<strong>Rekodierung</strong></p>
<div id="beispiel-mdbf" class="section level4">
<h4>Beispiel: MDBF</h4>
<p><img src="/post/MDBF.bmp" /></p>
<p>Erhebungsinstrument: <strong>M</strong>ehr<strong>d</strong>imensionaler <strong>B</strong>efindlichkeits<strong>f</strong>ragebogen (MDBF)</p>
<ul>
<li>3 Stimmungsdimensionen: gut vs. schlecht, wach vs. müde und ruhig vs. unruhig</li>
<li>Jeweils zwei positive, zwei negative Adjektive</li>
</ul>
<p><strong>Skala gut vs. schlecht:</strong></p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Adjektiv</th>
<th>Richtung</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mdbf1</td>
<td>zufrieden</td>
<td>positiv</td>
</tr>
<tr class="even">
<td>mdbf4</td>
<td>schlecht</td>
<td>negativ</td>
</tr>
<tr class="odd">
<td>mdbf8</td>
<td>gut</td>
<td>positiv</td>
</tr>
<tr class="even">
<td>mdbf11</td>
<td>unwohl</td>
<td>negativ</td>
</tr>
</tbody>
</table>
<ul>
<li>Skala soll bei hohen Werten gute Stimmung darstellen<br />
</li>
<li>Negativ formulierte Items müssen invertiert werden<br />
</li>
<li>Mögliche Werte von 1 bis 5<br />
</li>
<li>Hierzu kennen Sie bereits zwei Möglichkeiten (mit den Befehlen und R-Kenntnissen aus den bisherigen Sitzungen…)</li>
</ul>
</div>
</div>
</div>
<div id="rekodierung" class="section level2">
<h2>Rekodierung</h2>
<div id="variante-1-lineare-transformation" class="section level3">
<h3>Variante 1: Lineare Transformation</h3>
<pre class="r"><code>fb19$mdbf4_r &lt;- -1 * (fb19$mdbf4 - 6)
head(fb19$mdbf4)</code></pre>
<pre><code>## [1] 1 3 1 2 4 2</code></pre>
<pre class="r"><code>head(fb19$mdbf4_r)</code></pre>
<pre><code>## [1] 5 3 5 4 2 4</code></pre>
<ul>
<li>Allgemeine Form: <span class="math inline">\(-1 \cdot (x_m - x_{\max} - 1)\)</span><br />
</li>
<li>Vorteil: schnell und einfach umsetzbar<br />
</li>
<li>Nachteil: nur für Invertierung sinnvoll, nicht allgemeiner anwendbar</li>
</ul>
<p><em>Quizfrage</em>: Ist dies eine zulässige Transformation für ordinalskalierte Variablen (wie Items)?<br />
<em>Antwort</em>: Ja, denn die Ordnungsrelation bleibt hierbei erhalten!</p>
</div>
<div id="variante-2-logische-filter" class="section level3">
<h3>Variante 2: Logische Filter</h3>
<pre class="r"><code>fb19$mdbf11_r[fb19$mdbf11 == 1] &lt;- 5
fb19$mdbf11_r[fb19$mdbf11 == 2] &lt;- 4
fb19$mdbf11_r[fb19$mdbf11 == 3] &lt;- 3
fb19$mdbf11_r[fb19$mdbf11 == 4] &lt;- 2
fb19$mdbf11_r[fb19$mdbf11 == 5] &lt;- 1

head(fb19$mdbf11)</code></pre>
<pre><code>## [1] 1 3 1 4 4 1</code></pre>
<pre class="r"><code>head(fb19$mdbf11_r)</code></pre>
<pre><code>## [1] 5 3 5 2 2 5</code></pre>
<ul>
<li>Durch logische Filter Personen auswählen, die auf Originalvariable den relevanten Wert haben<br />
</li>
<li>Auf rekodierter Variable neuen Wert zuweisen<br />
</li>
<li>Vorteil: extrem fexibel, jede Transformation möglich<br />
</li>
<li>Nachteil: umständlich zu schreiben</li>
</ul>
</div>
</div>
<div id="skalenwerte-erstellen" class="section level2">
<h2>Skalenwerte erstellen</h2>
<p>Skalenwerte werden zumeist als Summen oder Mittelwerte der Items erstellt</p>
<div id="skalenwert-gut-vs.schlecht" class="section level3">
<h3>Skalenwert gut vs. schlecht</h3>
<pre class="r"><code># Datensatz der relevanten Variablen
gut_schlecht &lt;- fb19[, c(&#39;mdbf1&#39;, &#39;mdbf4_r&#39;, &#39;mdbf8&#39;, &#39;mdbf11_r&#39;)]
# Skalenwert in Originaldatensatz erstellen
fb19$gs &lt;- rowMeans(gut_schlecht)
head(fb19$gs)</code></pre>
<pre><code>## [1] 4.50 3.00 4.25 3.00 2.25 4.25</code></pre>
</div>
<div id="nützliche-funktionen-in-diesem-zusammenhang" class="section level3">
<h3>Nützliche Funktionen in diesem Zusammenhang:</h3>
<ul>
<li><code>rowMeans()</code> Mittelwert für jede Zeile (über Variablen)<br />
</li>
<li><code>colMeans()</code> Mittelwert für jede Spalte (über Personen)<br />
</li>
<li><code>rowSums()</code> Summe für jede Zeile (über Variablen)<br />
</li>
<li><code>colSums()</code> Summe für jede Spalte (über Personen)</li>
</ul>
</div>
</div>
