---
title: Lösungen
date: '2019-12-14T20:00:00'
slug: loesungen2
categories:
  - Projekt 2
tags: []
subtitle: ''
summary: ''
authors: [mehler, rouchi]
lastmod: '2022-04-27'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
header:
  image: "/header/casino_post.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/1071839)"
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<div id="vorwarnung" class="section level2">
<h2>Vorwarnung</h2>
<p>Achtung! Im Folgenden werden die Lösungen für das zweite Projekt präsentiert. Falls du das Projekt noch nicht vollständig bearbeitet hast, nutze zunächst die <a href="/post/tipps2">Tipps</a>. Sofern dir die Tipps für einen Teil nicht geholfen haben, kannst du die Lösungen dafür benutzen, einen Schritt weiterzukommen und beim nächsten Abschnitt weiterzumachen.</p>
</div>
<div id="lösung-zu-aufgabe-1-grundprinzip-roulette" class="section level2">
<h2>Lösung zu Aufgabe 1: Grundprinzip Roulette</h2>
<details>
<summary>
Lösung anzeigen
</summary>
<p>
<p>Das europäische Roulette verwendet eine Scheibe mit den Zahlen von 0 bis 36, also hat sie 37 verschiedene Fächer. Demnach entspricht das einer einfachen Zufallsziehung aus den Zahlen 0 bis 36, bei der jede Zahl mit gleicher Wahrscheinlichkeit auftritt, da die Fächer alle die gleiche Fläche einnehmen.</p>
<p>Mit <code>sample</code> kannst du - ohne Zurücklegen - alle Nummern ziehen. Es wird als eine zufällige Reihenfolge der Zahlen generiert:</p>
<pre class="r"><code>sample(0:36)</code></pre>
<pre><code>##  [1] 26  3  6 13  0 25  9 21  2 22 23 14  4 34  5 18 10 17 32 24 11  8 31 19 36
## [26] 33 15 30 35  7 29 16 28  1 12 27 20</code></pre>
<p>Was hier nun passiert, ist eine Urnenziehung ohne Zurücklegen bis alle Nummern gezogen wurden. Das entspricht jedoch nicht der Zufallsziehung beim Roulette. Dort wird jeweils “mit Zurücklegen” gespielt. Das kann man nun auf zwei Wegen erreichen:</p>
<p>Man könnte jeweils nur eine Ziehung durchführen. Dafür beschränkt man den Befehl auf eine Ziehung aus allen Zahlen. Möchte man nun mehrere Durchgänge simulieren, führt man diesen Befehl einfach mehrfach aus.</p>
<pre class="r"><code>sample(0:36, 1)</code></pre>
<pre><code>## [1] 23</code></pre>
<p>Man könnte auch mit dem Argument <code>replace = T</code> festlegen, dass die gezogenen Zahlen immer wieder ersetzt werden. Jetzt kann man mit dem zweiten Argument festlegen, wie oft man die Zufallsziehung durchführen möchte und man erhält eine mathematische Simulation der Zufallsziehung beim Roulette.</p>
<pre class="r"><code>sample(0:36, 5, replace = T)</code></pre>
<pre><code>## [1] 25  3 27  3  6</code></pre>
<p>Jetzt lassen wir die Roulettekugel 50 Mal rollen (Loop) und speichern die Ergebnisse in der Variable “Ziehungen”.</p>
<p>Das kann entweder, wie bereits beschrieben, über das <code>replace</code>-Argument im <code>sample</code>-Befehl gemacht werden (das Ergebnis ist ein numerischer Vektor, den wir hier dem Objekt <code>Ziehungen</code> zuweisen).</p>
<pre class="r"><code>Ziehungen &lt;- sample(0:36, 50, replace = T)
Ziehungen</code></pre>
<pre><code>##  [1] 33 12 24  1 12 22  1 29 11 12 30  1 26 16 28 18 19  8  3 30 19 22  0 36 33
## [26] 26 33  5 14 32 28 35 30 17 15 21  2 32 31 25 12 34  3  7 13 23 26 24 15 28</code></pre>
<p>Oder man geht einen etwas schwierigeren Weg über eine <code>for</code>-Schleife. Dafür erstellt man zuerst ein leeres Objekt, in dem man dann im Folgenden die einzelnen Ziehungen speichern kann, und führt dann die Schleife aus.</p>
<pre class="r"><code>Ziehungen &lt;- NULL
for (i in 1:50) {
  Ziehungen[i] &lt;- sample(0:36, 1)
}
Ziehungen</code></pre>
<pre><code>##  [1] 24 11 10 29 10  9  0 27  8 24 22 19 15 34 24  1  0 20  4  5  8  3 14  9 19
## [26]  4 25 26 13 11  8 31 35  9  9 24  5 27 31 35  5  5  3  9 17 16 28 31  5 35</code></pre>
<p>Die erste Variante ist zwar wesentlich einfacher zu schreiben (und für <code>R</code> auch wesentlich einfacher und schneller auszuführen), aber die Zweite erlaubt es uns, nach dem Rollen jeder einzelnen Kugel noch andere Dinge zu tun.</p>
<p>Nun können wir die Zufallsziehung im Roulette simulieren und auch mehrfach ablaufen lassen. Was jetzt noch fehlt, sind die Wetten und die Berechnung des Gewinns.</p>
<p>Dazu wenden wir uns erst einmal der Frage zu: Wie hoch wäre mein Gewinn, wenn ich in jeder Runde 5 Euro auf die 9 gesetzt hätte?</p>
<p>Bei der Wette auf die 9 handelt es sich um eine einfache Wette auf eine Zahl. Die Wahrscheinlichkeit liegt bei 1:37 mit einer Gewinnausschüttung mit dem Faktor 36 (Die Gewinnausschüttung berechnet sich immer ohne Einbezug der Null. - Aus diesem Grund geht das Casino auf Dauer als Sieger in diesem Spiel hervor.). Setzt man beispielsweise 5 Euro auf eine einzelne Zahl, erhält man - wenn man richtig liegt - das 36-fache wieder, also 180 Euro. Damit hat man, unter Abzug des Einsatzes, einen Gewinn von 175 Euro, wenn man gewinnt, und einen Verlust von 5 Euro, wenn man verliert.</p>
<p>Nun können wir eine Funktion auf das Objekt <code>Ziehungen</code> (Vektor) anwenden, die einen weiteren Vektor mit den Gewinnen zu den Ziehungen erstellt. Diesen weisen wir dem Objekt <code>Gewinne</code> zu.</p>
<pre class="r"><code>Gewinne &lt;- ifelse(Ziehungen == 9, 175, -5)</code></pre>
<p>Die <code>ifelse</code>-Funktion ist folgendermaßen aufgebaut:</p>
<ol style="list-style-type: decimal">
<li>Man gibt die Bedingung an.</li>
<li>Man gibt die Ausgabe für den Fall an, dass die Bedingung zutrifft.</li>
<li>Man gibt die Ausgabe für den Fall an, dass die Bedingung nicht zutrifft.</li>
</ol>
<p>Wenn also eine 9 herausgekommen ist, soll ein Gewinn von <code>175</code> eingesetzt werden; ansonsten der Gewinn von <code>-5</code> (= Verlust). Der dadurch bestimmte Vektor sieht dann folgendermaßen aus:</p>
<pre><code>##  [1]  -5  -5  -5  -5  -5 175  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5  -5
## [20]  -5  -5  -5  -5 175  -5  -5  -5  -5  -5  -5  -5  -5  -5 175 175  -5  -5  -5
## [39]  -5  -5  -5  -5  -5 175  -5  -5  -5  -5  -5  -5</code></pre>
<p>Jetzt kann man zu jeder Runde den Gewinn bzw. Verlust ablesen. Insgesamt ergibt das eine Ausbeute von:</p>
<pre class="r"><code>Gesamtgewinn &lt;- sum(Gewinne)
Gesamtgewinn</code></pre>
<pre><code>## [1] 650</code></pre>
<p>Wie man sehen kann, hatten wir in diesem Fall sehr viel Glück. Die 9 wurde in 5 Durchläufen gezogen. Dadurch ergab sich ein phänomenaler Gewinn von 650 Euro.</p>
</details>
</div>
<div id="lösung-zu-aufgabe-2-implementierung-verschiedener-wettmöglichkeiten" class="section level2">
<h2>Lösung zu Aufgabe 2: Implementierung verschiedener Wettmöglichkeiten</h2>
<details>
<summary>
Lösung anzeigen
</summary>
<p>Auf Vektoren kann man <code>ifelse</code>-Funktionen nur sehr schlecht anwenden. Aus diesem Grund muss man den Gewinn einen Schritt vorher ermitteln. Das Problem ist dann, dass die gedrehten Zahlen nicht mehr ausgegeben werden, sondern lediglich der Gewinn. Eine Möglichkeit dafür ist es, eine Schleife zu erstellen und die gedrehten Zahlen in einem eigenen Objekt abzuspeichern.</p>
<p>Beim Roulette kann man auf beinahe jede vorstellbare Kombination von Zahlen wetten. Um das Ganze zu vereinfachen, bauen wir hier aber nur 7 Möglichkeiten ein: rote Zahlen (<code>RED</code>), schwarze Zahlen (<code>BLACK</code>), gerade (<code>EVEN</code>) und ungerade (<code>ODD</code>) Zahlen, sowie die drei <em>Douzaines</em> - Dutzende - in die sich die Zahlen 1 bis 36 einteilen lassen. Wir müssen diese Möglichkeiten zunächst als Objekte mit den dazugehörigen Zahlen füllen. Außer <code>RED</code> und <code>BLACK</code> können wir dabei alle Vektoren abkürzen:</p>
<pre class="r"><code>RED &lt;- c(1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36)
BLACK &lt;- c(2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35)
EVEN &lt;- seq(2, 36, by = 2)
ODD &lt;- seq(1, 35, by = 2)
firstThird &lt;- 1:12
secondThird &lt;- 13:24
lastThird &lt;- 25:36</code></pre>
<p>Grundsätzlich gibt es beim Roulette drei Variablen: den Einsatz, die Wette und die Zufallsziehung. Alle drei gehen in die Berechnung des Gewinns mit ein. Der Einsatz ist die Basis zur Berechnung des Gewinns. Dazu kommt die Wette im Abgleich mit der Zufallsziehung: je nachdem, ob man richtig tippt oder nicht, ergibt sich eine andere Gewinnberechnung.</p>
<pre class="r"><code># x = Ergebnis Roulette
x &lt;- sample(0:36, 1)
# y = Einsatz (beispielhaft 10 Euro)
y &lt;- 10
# z = Zahl/Gruppe von Zahlen, auf die gesetzt wurde (beispielhaft ungerade Zahlen)
z &lt;- ODD</code></pre>
<p>Bei der Gewinnberechnung nutzt man wie bereits in der ersten Aufgabe eine <code>if</code>-Funktion. Dort hat man die Bedingung jedoch nach dem Prinzip “Wenn die Zufallsziehung x der Wette z gleicht, dann gewinnt man.” geschrieben. Das kann man zwar wieder übernehmen, aber für die neu hinzugefügten Wetten (wie zum Beispiel auf die ungeraden Zahlen) funktioniert das nicht. Hierfür kann man die Bedingung mit dem <code>is.element</code>-Argument formulieren. Wenn <code>x</code> (die Zufallsziehung) ein Element von <code>z</code> (der Wette) ist, hat man gewonnen.</p>
<p>Zusätzlich zu der neuen Bedingung baut man nun bei Zutreffen der Bedingung eine weitere <code>if</code>-Funktion ein, die die unterschiedlichen Berechnungen des Gewinns für die unterschiedlichen Wetten beinhaltet. Damit erhält man eine Funktion, die abhängig von Zufallsziehung, Einsatz und Wette den Gewinn bzw. Verlust ermittelt.</p>
<p>Das sieht dann folgendermaßen aus:</p>
<pre class="r"><code>if (is.element(x, z)) {
  if (z == RED) {
    y
  } else if (z == BLACK) {
    y
  } else if (z == ODD) {
    y
  } else if (z == EVEN) {
    y
  } else if (z == firstThird) {
    y * 2
  } else if (z == secondThird) {
    y * 2
  } else if (z == lastThird) {
    y * 2
  } else {
    y * 35
  }
} else {
  -y
}</code></pre>
<pre><code>## [1] -10</code></pre>
<p>Hier stößt man jetzt auf ein Problem. Wenn man auf eine der neuen Wettmöglichkeiten setzt und gewinnt, erscheint folgende Warnmeldung: <code>the condition has length &gt; 1 and only the first element will be used</code>. Im Folgenden sieht man ein Beispiel dafür. Dafür haben wir das Ergebnis der Zufallsziehung selbstständig bestimmt, um sicherzugehen, dass wir gewinnen.</p>
<pre class="r"><code>x &lt;- 13
if (is.element(x, z)) {
  if (z == RED) {
    y
  } else if (z == BLACK) {
    y
  } else if (z == ODD) {
    y
  } else if (z == EVEN) {
    y
  } else if (z == firstThird) {
    y * 2
  } else if (z == secondThird) {
    y * 2
  } else if (z == lastThird) {
    y * 2
  } else {
    y * 35
  }
} else {
  -y
}</code></pre>
<pre><code>## Warning in if (z == RED) {: Bedingung hat Länge &gt; 1 und nur das erste Element
## wird benutzt</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Dieser Fehler taucht auf, weil die logische Abfrage <code>==</code> nur einzelne Zahlen miteinander vergleichen kann und nicht ganze Vektoren. Aus diesem Grund gibt <code>R</code> eine Warnung aus, führt den Befehl jedoch trotzdem unter der Auflage aus, dass nur der erste Wert für die Abfrage benutzt wird. Das ist erst einmal nicht schlimm; kann jedoch unter bestimmten Umständen zu Fehlern führen.</p>
<p>Beispiel: Nehmen wir an, dass wir 10 Euro auf die 1 gesetzt haben. Zu unserem Glück hat die Zufallsziehung eine 1 ergeben und wir gewinnen 350 Euro + den Einsatz von 10 Euro. Für diesen Fall berechnet die Funktion folgendes:</p>
<pre class="r"><code>x&lt;-1
z&lt;-1
y&lt;-10
if (is.element(x, z)) {
  if (z == RED) {
    y
  } else if (z == BLACK) {
    y
  } else if (z == ODD) {
    y
  } else if (z == EVEN) {
    y
  } else if (z == firstThird) {
    y * 2
  } else if (z == secondThird) {
    y * 2
  } else if (z == lastThird) {
    y * 2
  } else {
    y * 35
  }
} else {
  -y
}</code></pre>
<pre><code>## Warning in if (z == RED) {: Bedingung hat Länge &gt; 1 und nur das erste Element
## wird benutzt</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Wie man sieht errechnet die Funktion uns einen Gewinn von 10 Euro. Dieser Fehler passiert bereits in der 2./3. Zeile des Befehls: <code>if (z == RED) {y}</code>. Was diese Zeile aussagen soll ist, dass man bei einer Wette auf <code>RED</code> einen Gewinn in der Höhe des Einsatzes zu verzeichnen hat. Die Abfrage, die wir dort jedoch eingebaut haben, kann nur einzelne Zahlen auf Gleichheit überprüfen. Aus diesem Grund benutzt <code>R</code> in diesem Fall nur die erste Zahl des Vektors <code>RED</code> für den Abgleich; und das ist die Zahl 1. Aus diesem Grund gilt in diesem Fall <code>z == RED</code> (das besagt, dass unsere Wette der Wette <code>RED</code> gleicht, obwohl wir eigentlich nur auf die 1 gesetzt haben), weshalb ein Gewinn von <code>y</code> ausgegeben wird.</p>
<p>Um diesen Fehler zu vermeiden, müssen wir die Abfrage verändern. Dafür eignet sich der <code>identical()</code>-Befehl. Dieser Befehl überprüft, ob zwei Elemente identisch sind, unabhängig von der Struktur bzw. Größe dieser beiden Elemente. Die korrigierte Funktion sieht dann folgendermaßen aus:</p>
<pre class="r"><code>if (is.element(x, z)) {
  if (identical(z, RED)) {
    y
  } else if (identical(z, BLACK)) {
    y
  } else if (identical(z, ODD)) {
    y
  } else if (identical(z, EVEN)) {
    y
  } else if (identical(z, firstThird)) {
    y * 2
  } else if (identical(z, secondThird)) {
    y * 2
  } else if (identical(z, lastThird)) {
    y * 2
  } else {
    y * 35
  }
} else {
  -y
}</code></pre>
<pre><code>## [1] 350</code></pre>
<p>Wie man sehen kann, berechnet diese Funktion nun den korrekten Gewinn für unser Beispiel.</p>
<p>Ein weiterer Kritikpunkt dieser Funktion ist die mehrfache Wiederholung fast identischer Befehle. Das kann man durch die Verwendung logischer Verknüpfungen; und zwar dem “oder” in <code>R</code>: <code>|</code>, verhindern. Im Folgenden kann man die optimierte Version des Befehls sehen:</p>
<pre class="r"><code>if (is.element(x, z)) {
  if (identical(z, RED) | identical(z, BLACK) | 
      identical(z, ODD) | identical(z, EVEN)) {
    y
  } else if (identical(z, firstThird) | 
      identical(z, secondThird) | 
      identical(z, lastThird)) {
    y * 2
  } else {
    y * 35
  }
} else {
  -y
}</code></pre>
<pre><code>## [1] 350</code></pre>
<p>Da die Funktion nun okönomisch und ohne Fehler läuft, können wir das Ganze nun in die Schleife einsetzen, die wir bereits in der ersten Aufgabe benutzt haben. Damit enthält diese Schleife die Verbesserung, dass in jedem Durchlauf auch der Gewinn ermittelt wird.</p>
<p>Um das jetzt auch einmal auszuprobieren, müssen wir die beiden Variablen <code>Ziehungen</code> und <code>Gewinne</code> von den Daten aus der ersten Aufgabe befreien und die Wette beispielhaft auf <code>ODD</code> festlegen:</p>
<pre class="r"><code>Gewinne &lt;- NULL
Ziehungen &lt;- NULL
z &lt;- ODD</code></pre>
<p>Die Schleife sieht nun folgendermaßen aus:</p>
<pre class="r"><code>for (i in 1:50) {
  x &lt;- sample(0:36, 1)
  Ziehungen[i] &lt;- x
  Gewinne[i] &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) | 
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) | 
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
}</code></pre>
<p>Die Ergebnisse können wir uns nun entweder einzeln anschauen, oder wir verbinden beide Objekte zu einem Datensatz.</p>
<pre class="r"><code>Ziehungen</code></pre>
<pre><code>##  [1]  3 13  1 29 24 12 32 17 34 18 18  0 19 12 15 34  6  9 16  8 25 34 22 12 17
## [26] 34 16  8  7 25 20 36 31  9 17 27 23 10 33  9 21 14 36 32 10 21 24 29  6 27</code></pre>
<pre class="r"><code>Gewinne</code></pre>
<pre><code>##  [1]  10  10  10  10 -10 -10 -10  10 -10 -10 -10 -10  10 -10  10 -10 -10  10 -10
## [20] -10  10 -10 -10 -10  10 -10 -10 -10  10  10 -10 -10  10  10  10  10  10 -10
## [39]  10  10  10 -10 -10 -10 -10  10 -10  10 -10  10</code></pre>
<pre class="r"><code>Spiel_Odd_50 &lt;- data.frame(Ziehungen, Gewinne)
head(Spiel_Odd_50)</code></pre>
<pre><code>##   Ziehungen Gewinne
## 1         3      10
## 2        13      10
## 3         1      10
## 4        29      10
## 5        24     -10
## 6        12     -10</code></pre>
<p>Den Gesamtgewinn kann man sich dann auch noch für jede Runde mithilfe der <code>cumsum</code>-Funktion anzeigen lassen, oder man benutzt die <code>sum</code>-Funktion, um nur das Endergebnis zu erhalten.</p>
<pre class="r"><code>cumsum(Gewinne)</code></pre>
<pre><code>##  [1]  10  20  30  40  30  20  10  20  10   0 -10 -20 -10 -20 -10 -20 -30 -20 -30
## [20] -40 -30 -40 -50 -60 -50 -60 -70 -80 -70 -60 -70 -80 -70 -60 -50 -40 -30 -40
## [39] -30 -20 -10 -20 -30 -40 -50 -40 -50 -40 -50 -40</code></pre>
<pre class="r"><code>sum(Gewinne)</code></pre>
<pre><code>## [1] -40</code></pre>
</details>
</div>
<div id="lösung-zu-aufgabe-3-spiele-bis-du-x-euro-gewonnen-hast" class="section level2">
<h2>Lösung zu Aufgabe 3: Spiele, bis du X Euro gewonnen hast</h2>
<details>
<summary>
Lösung anzeigen
</summary>
<p>Wir spielen nun beispielhaft mit einem Einsatz von 10 Euro auf <code>RED</code>. Dafür erstellen wir außerdem ein Objekt, das den Gewinn in der jeweiligen Runde kurzzeitig abspeichert, damit wir damit arbeiten können.</p>
<pre class="r"><code>y &lt;- 10
z &lt;- RED
Gewinn &lt;- NULL</code></pre>
<p>Nun fehlen noch genau zwei Dinge:</p>
<ol style="list-style-type: decimal">
<li>Wie ermitteln wir jeden Durchgang erneut den Gesamtgewinn, sodass dieser immer wieder mit der Bedingung abgeglichen werden kann?</li>
<li>Wie zählen wir die Durchgänge?</li>
</ol>
<p>Zu 1. - Für die Bedingung entscheiden wir uns für 50 Euro. Das heißt, dass wir so lange spielen wollen, bis wir 50 Euro gewonnen haben. Dafür brauchen wir ein weiteres Objekt für den Gesamtgewinn. Dieses Objekt soll in jedem Durchgang geupdatet werden. Starten soll es (logischerweise) bei Null. Also erstellen wir dafür das Objekt <code>Gesamtgewinn</code> mit dem Wert 0.</p>
<pre class="r"><code>Gesamtgewinn &lt;- 0</code></pre>
<p>Dieses Objekt soll dann in jedem Durchgang mit dem Gewinn addiert werden; also schreibt man in die Funktion: <code>Gesamtgewinn &lt;- Gesamtgewinn + Gewinn</code>. So wird der Gesamtgewinn in jedem Durchgang geupdatet und mit der Bedingung <code>Gesamtgewinn &lt; 50</code> verglichen. Damit wäre das erste Problem gelöst.</p>
<p>Zu 2. - Für das Zählen der Durchgänge wendet man eine identische Technik an. Dafür erstellt man wiederum ein Objekt (<code>Durchgaenge</code>) mit dem Wert 0.</p>
<pre class="r"><code>Durchgaenge &lt;- 0</code></pre>
<p>Dieses Objekt updatet man auch in jedem Durchgang, indem man jedes Mal 1 addiert: <code>Durchgaenge &lt;- Durchgaenge + 1</code>. Somit zählt man automatisch die Durchgänge mit.</p>
<p>Damit wären die beiden Probleme gelöst und wir kommen zu einem vorläufigen Ergebnis der Schleife.</p>
<p>Wenn man möchte, kann man sich auch in jedem Durchgang noch den Zwischenstand (<code>Gesamtgewinn</code>) oder den Gewinn der Runde (<code>Gewinn</code>) mithilfe der <code>print</code>-Funktion ausgeben lassen. Das Endergebnis sieht dann folgendermaßen aus:</p>
<pre class="r"><code>while (Gesamtgewinn &lt; 50) {
  x &lt;- sample(0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
  Gesamtgewinn &lt;- Gesamtgewinn + Gewinn
  print (Gesamtgewinn)
  Durchgaenge &lt;- Durchgaenge + 1
}</code></pre>
<p>Die Funktion wird nun so lange alle Schritte wiederholen, bis die Bedingung <code>Gesamtgewinn &lt; 50</code> nicht mehr zutrifft. Bis dahin werden auch die Durchgänge gezählt. Das heißt, dass man, sofern die Funktion irgendwann stoppt, an dem Objekt <code>Durchgaenge</code> ablesen kann, wie lange man für einen Gewinn von 50 Euro hätte spielen müssen.</p>
<p>Wie man vielleicht merkt, hat das Ganze einen Haken. Wenn man Pech hat, dann kommt diese Funktion nie zum Ende, weil man nie oft genug in Folge gewinnt, um auf einen Gesamtgewinn von 50 Euro zu kommen. Keep in mind: Das Casino gewinnt letztlich immer; und das ist ein Fakt! Die Gewinnausschüttung beim Roulette berechnet sich nämlich derart, dass ein/eine Spieler:in, je öfter er spielt, umso wahrscheinlicher mit leeren Händen nach Hause gehen wird.</p>
<p>Aus diesem Grund sollten wir eine weitere Bedingung einbauen, die die Schleife nach einer bestimmten Zeit unterbricht. Eine Möglichkeit ist es, eine maximale Anzahl an Durchgängen festzulegen, bei der die Schleife beendet wird. Dafür kann man den <code>break</code>-Befehl benutzen. Diesen kann man in eine Schleife integrieren und bei Eintreten der dazugehörigen Bedingung (<code>if</code>) wird die Schleife unterbrochen. Im folgenden Beispiel brechen wir die Schleife nach 500 Durchgängen ab.</p>
<pre class="r"><code>Gesamtgewinn &lt;- 0
Durchgaenge &lt;- 0
while (Gesamtgewinn &lt; 50) {
  x &lt;- sample(0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
  Gesamtgewinn &lt;- Gesamtgewinn + Gewinn
  Durchgaenge &lt;- Durchgaenge + 1
  if (Durchgaenge == 500) break
}
Gesamtgewinn</code></pre>
<pre><code>## [1] -560</code></pre>
<p>Das heißt, dass man nun so lange spielt, bis man entweder 50 Euro gewonnen oder 500 Runden gespielt hat.</p>
</details>
</div>
<div id="lösung-zu-aufgabe-4-funktionen" class="section level2">
<h2>Lösung zu Aufgabe 4: Funktionen</h2>
<details>
<summary>
Abschnitt 1 anzeigen
</summary>
<p>Für das Erstellen einer Funktion kann man den <code>function</code>-Befehl benutzen. Dieser Befehl ist folgendermaßen aufgebaut: <code>function (Variablen) {Funktion}</code>. Man gibt in den normalen Klammern an, welche Variablen in der Funktion verwendet werden und zur Durchführung benötigt werden. In den geschwungenen Klammern gibt man dann die Operationen der Funktion an, die unter Verwendung der Variablen durchgeführt werden. Dem Ganzen kann man mithilfe der Zuweisung mit dem Pfeil einen Namen geben.</p>
<p>Für das Roulette ergeben sich zwei Variablen: der Einsatz <code>y</code> und die Wette <code>z</code>. Die Funktion kann man aus den vorherigen Aufgaben kopieren. Das ist zum einen die Zufallsziehung und zum anderen die Funktion zur Ermittlung des Gewinns in Abhängigkeit von Einsatz <code>y</code> und Wette <code>z</code>.</p>
<p>Das Problem ist nun, dass die Funktion noch keine Ergebnisse ausgibt. Dafür können wir zunächst ganz einfach den <code>print</code>-Befehl nutzen. Wichtig: der <code>print</code>-Befehl kann nur ein Objekt ausgeben, deshalb muss man Zufallsziehung und Gewinn in einen Vektor packen. Das sieht dann folgendermaßen aus:</p>
<pre class="r"><code>Roulette &lt;- function (y, z) {
  x &lt;- sample (0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
  print(c(x, Gewinn))
}
Roulette(10,7)</code></pre>
<pre><code>## [1]  20 -10</code></pre>
<p>Nun kann man ganz einfach Roulette spielen, indem man Einsatz und Wette angibt und erhält Zufallsziehung und Gewinn. Wie man in diesem Beispiel sieht, wurden 10 Euro auf die Zahl 7 gesetzt. Ausgegeben wird, welche Zahl bei der Ziehung herauskam und der Gewinn.</p>
<p>Das Ganze ist aber noch nicht so schön. Deshalb versuchen wir, das Roulettespiel mit Pausen und Nachrichten etwas authentischer zu gestalten. Das Praktische dabei ist, dass man auch Variablen in diese Nachrichten schreiben kann, sodass man zum Beispiel eine Nachricht mit dem Ergebnis allgemein formulieren kann [<code>message("Es wurde eine ", x, " gedreht!")</code>]. Des Weiteren kann man, je nach Resultat (Sieg oder Niederlage) unterschiedliche Nachrichten mithilfe einer <code>if</code>-Funktion ausgeben lassen. Das könnte dann folgendermaßen aussehen:</p>
<pre class="r"><code>Roulette &lt;- function (y, z) {
  x &lt;- sample (0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
  message (&quot;Roulettekugel startet&quot;)
  Sys.sleep (2.0)
  message (&quot;Rien ne va plus!&quot;)
  Sys.sleep (2.0)
  message (&quot;Es ist eine &quot;, x, &quot;.&quot;)
  Sys.sleep (2.0)
  if (is.element (x, z)) {
    message (&quot;Du hast gewonnen!&quot;)
    Sys.sleep (2.0)
    message (&quot;Dein Gewinn beträgt &quot;, Gewinn, &quot; Euro.&quot; )
  } else {
    message (&quot;Du hast verloren!&quot;)
    Sys.sleep (2.0)
    message (&quot;Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.&quot;)
  }
}</code></pre>
<p>Das testen wir jetzt, indem wir die Funktion einmal benutzen. In diesem Beispiel setzen wir 10 Euro auf <code>RED</code>.</p>
<pre class="r"><code>Roulette(10,RED)</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 36.</code></pre>
<pre><code>## Du hast gewonnen!</code></pre>
<pre><code>## Dein Gewinn beträgt 10 Euro.</code></pre>
<p>Die Ausgabe in diesem Beispiel ist schon deutlich schöner/authentischer und hält alle nötigen Informationen bereit.</p>
<p>In dieser Funktion kann man jedoch nur einmal spielen und muss die Funktion dann erneut starten. Dafür können wir eine neue Funktion schreiben, die die alte Funktion dahingehend erweitert, als dass man mehrere Runden auf einmal spielen kann. Das wird im zweiten Abschnitt erläutert.</p>
</details>
<details>
<summary>
Abschnitt 2 anzeigen
</summary>
<p>Für das Umsetzen einer Roulette-Funktion mit variabler Rundenzahl müssen wir einige Anpassungen und Erweiterungen an der Funktion in Abschnitt 1 vornehmen. Übernehmen können wir wiederum die Zufallsziehung und die Gewinnberechnung aus den vorherigen Aufgaben. Wir wissen auch schon, dass wir drei Variablen haben werden: <code>y</code> = Einsatz, <code>z</code> = Wette und <code>o</code> = Anzahl der Runden. Die Funktion nennen wir <code>Roulette_Schleife</code>. Das sieht dann vorerst folgendermaßen aus:</p>
<pre class="r"><code>Roulette_Schleife &lt;- function(y, z, o) {
  x &lt;- sample(0:36, 1)
  Gewinn &lt;- if (is.element(x, z)) {
    if (identical(z, RED) | identical(z, BLACK) |
        identical(z, ODD) | identical(z, EVEN)) {
      y
    } else if (identical(z, firstThird) |
        identical(z, secondThird) |
        identical(z, lastThird)) {
      y * 2
    } else {
      y * 35
    }
  } else {
  -y
  }
}</code></pre>
<p>Jetzt müssen wir uns überlegen, wie wir Zufallsziehung und Gewinnberechnung wiederholt durchführen können bis eine bestimmte Anzahl an Runden gespielt wurde. Wir wissen, dass die Variable <code>o</code> angibt, wie viele Runden gespielt werden sollen. Wir erstellen also eine weitere Variable <code>Durchgaenge</code>, die die gespielten Runden zählen soll. Das Vorgehen dabei sollte bereits aus den vorherigen Aufgaben bekannt sein. Mithilfe dieser beiden Variablen <code>o</code> und <code>Durchgaenge</code> können wir nun eine Bedingung erstellen, sodass gespielt wird bis <code>o == Durchgaenge</code> gilt.</p>
<p>Dafür verwenden wir eine neue Funktion: die <code>repeat</code>-Funktion. Diese Funktion führt alle ihre Operationen durch, bis die Bedingung (in unserem Fall <code>o == Durchgaenge</code>) erfüllt ist. Anders als bei bereits bekannten Funktionen schreibt man die Bedingung hier an das Ende der Funktion. Und zwar ist die <code>repeat</code>-Funktion folgendermaßen aufgebaut: <code>repeat {Operation 1 ENTER Operation 2 ENTER etc. ENTER if (o == Durchgaenge) break}</code>. Das sieht dann bei uns folgendermaßen aus:</p>
<pre class="r"><code>Roulette_Schleife &lt;- function (y, z, o) {
  Durchgaenge &lt;- 0
  repeat {
    Durchgaenge &lt;- Durchgaenge + 1
    x &lt;- sample (0:36, 1)
    Gewinn &lt;- if (is.element(x, z)) {
      if (identical(z, RED) | identical(z, BLACK) |
          identical(z, ODD) | identical(z, EVEN)) {
        y
      } else if (identical(z, firstThird) |
          identical(z, secondThird) |
          identical(z, lastThird)) {
        y * 2
      } else {
        y * 35
      }
    } else {
      -y
    }
  if(Durchgaenge == o) break
  }
}</code></pre>
<p>Ebenso wie bei der Funktion im ersten Abschnitt fehlt nun eine Ausgabe mit den wichtigen Informationen/Ergebnissen. Dazu können wir unsere Funktion nun um die Pausen und Nachrichten aus dem ersten Abschnitt erweitern.</p>
<pre class="r"><code>Roulette_Schleife &lt;- function (y, z, o) {
  Durchgaenge &lt;- 0
  repeat {
    Durchgaenge &lt;- Durchgaenge + 1
    x &lt;- sample (0:36, 1)
    Gewinn &lt;- if (is.element(x, z)) {
      if (identical(z, RED) | identical(z, BLACK) |
          identical(z, ODD) | identical(z, EVEN)) {
        y
      } else if (identical(z, firstThird) |
          identical(z, secondThird) |
          identical(z, lastThird)) {
        y * 2
      } else {
        y * 35
      }
    } else {
      -y
    }
    message (&quot;Roulettekugel startet&quot;)
    Sys.sleep (2.0)
    message (&quot;Rien ne va plus!&quot;)
    Sys.sleep (2.0)
    message (&quot;Es ist eine &quot;, x, &quot;.&quot;)
    Sys.sleep (2.0)
    if (is.element (x, z)) {
      message (&quot;Du hast gewonnen!&quot;)
      Sys.sleep (2.0)
      message (&quot;Dein Gewinn beträgt &quot;, Gewinn, &quot; Euro.&quot; )
      Sys.sleep (1.0)
    } else {
      message (&quot;Du hast verloren!&quot;)
      Sys.sleep (2.0)
      message (&quot;Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.&quot;)
      Sys.sleep (1.0)
    }
  if(Durchgaenge == o) break
  }
}</code></pre>
<p>Jetzt ist die Ausgabe schon um einiges schöner, doch einige relevante Informationen fehlen noch. In dieser Funktion besteht nämlich die Möglichkeit, mehrere Runden auf einmal zu spielen. Damit kann man noch zusätzlich Information zur aktuellen Runde und zum aktuellen Gesamtgewinn ausgeben.</p>
<p>Die Ausgabe des Gesamtgewinns gestaltet sich jedoch nicht so leicht wie die Rundenzahl, denn den Gesamtgewinn muss man jede Runde aufs Neue updaten. Das Prinzip für solche Operationen wurde bereits in einer vorherigen Aufgabe beschrieben. Bevor die Schleife beginnt erstellt man ein Objekt <code>Gesamtgewinn</code> beginnend mit der Null. In der Schleife nutzt man dann dieses Objekt und überschreibt diesen Wert jede Runde aufs Neue, indem man immer wieder den <code>Gewinn</code> aus der gerade laufenden Runde addiert. [Achtung: Die Nachricht zum Gesamtgewinn muss nach dieser erneuten Gesamtgewinn-Berechnung erfolgen, ansonsten gibt man den jeweils den Gesamtgewinn nach der vorherigen Runde an.]</p>
<p>Nachdem man diese beiden Dinge impliziert hat, sieht die Funktion folgendermaßen aus:</p>
<pre class="r"><code>Roulette_Schleife &lt;- function (y, z, o) {
  Durchgaenge &lt;- 0
  Gesamtgewinn &lt;- 0
  repeat {
    Durchgaenge &lt;- Durchgaenge + 1
    message (&quot;Runde &quot;, Durchgaenge, &quot;!&quot;)
    x &lt;- sample (0:36, 1)
    Gewinn &lt;- if (is.element(x, z)) {
      if (identical(z, RED) | identical(z, BLACK) |
          identical(z, ODD) | identical(z, EVEN)) {
        y
      } else if (identical(z, firstThird) |
          identical(z, secondThird) |
          identical(z, lastThird)) {
        y * 2
      } else {
        y * 35
      }
    } else {
      -y
    }
    Gesamtgewinn &lt;- Gesamtgewinn + Gewinn
    message (&quot;Roulettekugel startet&quot;)
    Sys.sleep (2.0)
    message (&quot;Rien ne va plus!&quot;)
    Sys.sleep (2.0)
    message (&quot;Es ist eine &quot;, x, &quot;.&quot;)
    Sys.sleep (2.0)
    if (is.element (x, z)) {
      message (&quot;Du hast gewonnen!&quot;)
      Sys.sleep (2.0)
      message (&quot;Dein Gewinn beträgt &quot;, Gewinn, &quot; Euro.&quot; )
      Sys.sleep (1.0)
      message (&quot;Damit liegt dein Gesamtgewinn bisher bei &quot;, Gesamtgewinn, &quot; Euro.&quot;)
      Sys.sleep (1.0)
    } else {
      message (&quot;Du hast verloren!&quot;)
      Sys.sleep (2.0)
      message (&quot;Damit liegt dein Gesamtgewinn bisher bei &quot;, Gesamtgewinn, &quot; Euro.&quot;)
      Sys.sleep (1.0)
      message (&quot;Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.&quot;)
      Sys.sleep (1.0)
    }
  if(Durchgaenge == o) break
  }
}</code></pre>
<p>Insgesamt funktioniert die Funktion, jedoch endet das Spiel nun ganz abrupt ohne irgendeine abschließende Nachricht. Aus diesem Grund fügen wir nun noch mehrere Nachrichten ein:</p>
<ul>
<li>Eine Nachricht, dass die <code>o</code> Runden nun gespielt sind.</li>
<li>Eine Nachricht, die Einsatz, Wette und Rundenzahl nocheinmal zusammenfasst und den daraus folgenden Gesamtgewinn beinhaltet.</li>
<li>Eine Nachricht, die vom Gesamtgewinn abhängt (Ob Geld gewonnen oder verloren wurde oder ob am Ende bei Null rauskam, soll durch verschiedene Nachrichten angezeigt werden.)</li>
</ul>
<p>Das kann dann folgendermaßen aussehen:</p>
<pre class="r"><code>Roulette_Schleife &lt;- function (y, z, o) {
  Durchgaenge &lt;- 0
  Gesamtgewinn &lt;- 0
  repeat {
    Durchgaenge &lt;- Durchgaenge + 1
    message (&quot;Runde &quot;, Durchgaenge, &quot;!&quot;)
    x &lt;- sample (0:36, 1)
    Gewinn &lt;- if (is.element(x, z)) {
      if (identical(z, RED) | identical(z, BLACK) |
          identical(z, ODD) | identical(z, EVEN)) {
        y
      } else if (identical(z, firstThird) |
          identical(z, secondThird) |
          identical(z, lastThird)) {
        y * 2
      } else {
        y * 35
      }
    } else {
      -y
    }
    Gesamtgewinn &lt;- Gesamtgewinn + Gewinn
    message (&quot;Roulettekugel startet&quot;)
    Sys.sleep (2.0)
    message (&quot;Rien ne va plus!&quot;)
    Sys.sleep (2.0)
    message (&quot;Es ist eine &quot;, x, &quot;.&quot;)
    Sys.sleep (2.0)
    if (is.element (x, z)) {
      message (&quot;Du hast gewonnen!&quot;)
      Sys.sleep (2.0)
      message (&quot;Dein Gewinn beträgt &quot;, Gewinn, &quot; Euro.&quot; )
      Sys.sleep (1.0)
      message (&quot;Damit liegt dein Gesamtgewinn bisher bei &quot;, Gesamtgewinn, &quot; Euro.&quot;)
      Sys.sleep (1.0)
    } else {
      message (&quot;Du hast verloren!&quot;)
      Sys.sleep (2.0)
      message (&quot;Damit liegt dein Gesamtgewinn bisher bei &quot;, Gesamtgewinn, &quot; Euro.&quot;)
      Sys.sleep (1.0)
      message (&quot;Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.&quot;)
      Sys.sleep (1.0)
    }
  if(Durchgaenge == o) break
  }
  message (&quot;Deine &quot;, Durchgaenge, &quot; Runden sind durch.&quot;)
  Sys.sleep (3.0)
  message (&quot;Du hast heute in &quot;, Durchgaenge, &quot; Spielrunden jeweils mit einem Einsatz von &quot;, y, &quot; Euro auf &quot;, z, &quot; einen Gesamtgewinn von &quot;, Gesamtgewinn, &quot; Euro erzielt!&quot;)
  Sys.sleep (3.0)
  if (Gesamtgewinn &gt; 0) {
    message(&quot;Herzlichen Glueckwunsch!&quot;)
  } else if (Gesamtgewinn == 0) {
    message(&quot;Sie haben heute nichts gewonnen. Wollen Sie wirklich schon gehen?&quot;)
  } else {
    message(&quot;Schade. Aber seien Sie nicht traurig. Das nächste Mal steht das Glueck wieder auf Ihrer Seite!&quot;)
  }
}</code></pre>
<p>Hier seht ihr jetzt zwei Beispiele:</p>
<ul>
<li>Ein Mal wurden in 3 Runden jeweils 5 Euro auf BLACK gesetzt.</li>
<li>Ein Mal wurden in 4 Runden jeweils 100 Euro auf ODD gesetzt.</li>
</ul>
<pre class="r"><code>Roulette_Schleife(5, BLACK, 3)</code></pre>
<pre><code>## Runde 1!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 2.</code></pre>
<pre><code>## Du hast gewonnen!</code></pre>
<pre><code>## Dein Gewinn beträgt 5 Euro.</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei 5 Euro.</code></pre>
<pre><code>## Runde 2!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 3.</code></pre>
<pre><code>## Du hast verloren!</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei 0 Euro.</code></pre>
<pre><code>## Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.</code></pre>
<pre><code>## Runde 3!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 17.</code></pre>
<pre><code>## Du hast gewonnen!</code></pre>
<pre><code>## Dein Gewinn beträgt 5 Euro.</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei 5 Euro.</code></pre>
<pre><code>## Deine 3 Runden sind durch.</code></pre>
<pre><code>## Du hast heute in 3 Spielrunden jeweils mit einem Einsatz von 5 Euro auf 24681011131517202224262829313335 einen Gesamtgewinn von 5 Euro erzielt!</code></pre>
<pre><code>## Herzlichen Glueckwunsch!</code></pre>
<pre class="r"><code>Roulette_Schleife(100, ODD, 4)</code></pre>
<pre><code>## Runde 1!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 14.</code></pre>
<pre><code>## Du hast verloren!</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei -100 Euro.</code></pre>
<pre><code>## Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.</code></pre>
<pre><code>## Runde 2!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 27.</code></pre>
<pre><code>## Du hast gewonnen!</code></pre>
<pre><code>## Dein Gewinn beträgt 100 Euro.</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei 0 Euro.</code></pre>
<pre><code>## Runde 3!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 27.</code></pre>
<pre><code>## Du hast gewonnen!</code></pre>
<pre><code>## Dein Gewinn beträgt 100 Euro.</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei 100 Euro.</code></pre>
<pre><code>## Runde 4!</code></pre>
<pre><code>## Roulettekugel startet</code></pre>
<pre><code>## Rien ne va plus!</code></pre>
<pre><code>## Es ist eine 26.</code></pre>
<pre><code>## Du hast verloren!</code></pre>
<pre><code>## Damit liegt dein Gesamtgewinn bisher bei 0 Euro.</code></pre>
<pre><code>## Gib nicht auf! In der nächsten Runde wird das Glück wieder auf deiner Seite stehen.</code></pre>
<pre><code>## Deine 4 Runden sind durch.</code></pre>
<pre><code>## Du hast heute in 4 Spielrunden jeweils mit einem Einsatz von 100 Euro auf 1357911131517192123252729313335 einen Gesamtgewinn von 0 Euro erzielt!</code></pre>
<pre><code>## Sie haben heute nichts gewonnen. Wollen Sie wirklich schon gehen?</code></pre>
</details>
</div>
