---
title: "Loops und Funktionen"
date: '2021-03-30'
slug: loops-und-funktionen
categories:
  - BSc7
tags:
  - Loops
  - Funktionen
  - for-loop
  - while-loop
  - repeat-loop
  - if-else
  - Simulation
  - Regression
subtitle: ''
summary: ''
authors: [irmer, schueller, wallot]
lastmod: '2022-03-28 12:00:12 CEST'
featured: no
header:
  image: "/header/PsyBSc7_Loops.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/1457161)"
projects: []
---



<p>In diesem Block werden wir verschiedene Arten von Loops (Schleifen) kennenlernen und lernen, vertieft mit Funktionen zu arbeiten. Dieses Wissen wollen wir dann nutzen, um nochmals Power- bzw. Simulationsanalysen durchzuführen, welche wir in der <a href="/post/simulation">Sitzung zu Simulationsstudien und Poweranalysen</a> bereits kennengelernt haben. Vorab beschäftigen wir uns noch mit einigen Grundlagen zum Thema logische Abfragen.</p>
<div id="logische-abfragen-und-bedingungen-if-und-else" class="section level1">
<h1>Logische Abfragen und Bedingungen: <code>if</code> und <code>else</code></h1>
<p>Im Prozess der Datenaufbereitung und -auswertung kommt man häufig an den Punkt, an dem ein bestimmter Befehl nur unter bestimmten Bedingungen ausgeführt werden soll, oder in dem abhängig von einer Bedingung unterschiedliche Aktionen ausgeführt werden sollen. Dabei bezieht sich die Bedingung auf einen Wert in einer bestimmten Variable, der sich zwischen den Versuchspersonen unterscheidet. Dafür können wir sogenannte <em>Wenn-Dann-Bedingungen</em>, oder auch <em>if-Abfragen</em> nutzen, in denen wir definieren, unter welchen Bedingungen ein folgender Befehl ausgeführt werden soll.
&gt;Beispiel: In einer neuen Variable <em>Med</em> wollen wir für alle Versuchspersonen eine 1 vergeben, die in der Variable “Dosis” einen gültigen Wert haben, und eine 0 vergeben für alle Personen, die in der Variable “Dosis” ein NA haben.</p>
<p>Im letzten Semester hatten wir das über die Bedingungen in eckigen Klammern angewandt auf einen <code>data.frame</code> erreicht. <code>if</code> bietet eine Alternative hierzu.</p>
<div id="if-abfragen" class="section level2">
<h2>if-Abfragen</h2>
<div id="einfache-if-abfrage" class="section level3">
<h3>Einfache if-Abfrage</h3>
<p>Wie in eigentlich allen Programmiersprachen werden <em>Wenn-Dann-Bedingungen</em> auch in <code>R</code> mit dem Befehl <code>if</code> erzeugt. Dabei folgt auf ein <code>if</code> in runden Klammern die Bedingung, die entweder wahr (<code>TRUE</code>) oder falsch (<code>FALSE</code>) sein kann. Auf die Bedingung folgt die Konsequenz. Ist die Konsequenz nur eine Zeile lang, kann sie direkt hinter der runden Klammer stehen. Geht sie über mehrere Zeilen, müssen geschwungene Klammern <code>{...}</code> genutzt werden, was die ganze Sache auch übersichtlicher macht!</p>
<p>Die Konsequenz wird nur ausgeführt, wenn die Bedingung das Ergebnis <code>TRUE</code> erbringt. Zum Beispiel könnten wir für eine Variable <code>a</code> testen, ob diese einen bestimmten Wert enthält und daraus eine Konsequenz ziehen.</p>
<pre class="r"><code>a &lt;- 3 #Zunächst definieren wir eine Variable
# mehrere Zeilen
if (a == 3) {
  print(&quot;Ja, die Variable a enthält den Wert 3&quot;)
}</code></pre>
<pre><code>## [1] &quot;Ja, die Variable a enthält den Wert 3&quot;</code></pre>
<pre class="r"><code># eine Zeile 
if (a == 3) print(&quot;Ja, die Variable a enthält den Wert 3&quot;)</code></pre>
<pre><code>## [1] &quot;Ja, die Variable a enthält den Wert 3&quot;</code></pre>
<p>Für das Verständnis solcher Abfragen ist es hilfreich, die verschiedenen Schritte der Syntax einzeln zu betrachten. Das gilt auch für die restlichen Themen dieses Blocks. In <code>R</code>-Studio können Sie einzelne Abschnitte des Codes markieren und ausführen, um zu testen, was diese beinhalten. Füren Sie Ihren Code immer in kleinen Schnipseln aus, wenn Sie verstehen wollen, was passiert.
Hier wird im ersten Schritt die Bedingung evaluiert:</p>
<pre class="r"><code>(a == 3)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>In diesem Fall stimmt die logische Abfrage (<code>a</code> enthält tatsächlich den Wert 3), und wir erhalten in der Konsole den Output <code>TRUE</code>. Deshalb wird der danach definierte <code>print</code>-Befehl ausgeführt.</p>
<p>Wenn jedoch <code>a</code> einen anderen Wert enthält, trifft die Bedingung nicht zu (<code>FALSE</code>) und der folgende Befehl wird deshalb nicht ausgeführt.</p>
<pre class="r"><code>a &lt;- 5
if (a == 3) {
  print(&quot;Ja, die Variable a enthält den Wert 3&quot;)
}</code></pre>
<p>Wenn Sie diesen Code wieder Schritt für Schritt ausführen (z.b. lediglich die Abfrage in den runden Klammern), können Sie sich so die Zusammenhänge innerhalb der if-Abfrage verdeutlichen.</p>
</div>
<div id="if-abfrage-mit-mehreren-möglichkeiten" class="section level3">
<h3>if-Abfrage mit mehreren Möglichkeiten</h3>
<p>Oft haben wir aber mehrere Argumente, die untersucht werden können. Bspw. können wir testen, ob ein Wert sich in einer Liste wiederfindet. Wenn wir beispielsweise herausfinden wollen, ob die Person, die in der Variable <code>person</code> gespeichert ist, ein Hauptcharakter aus der Serie <em>Friends</em> ist, können wir dies mit dem folgenden Befehl tun:</p>
<pre class="r"><code>person = &quot;Monica&quot;
if (person %in%  c(&quot;Monica&quot;, &quot;Rachel&quot;, &quot;Chandler&quot;,  &quot;Phoebe&quot;, &quot;Ross&quot;, &quot;Joey&quot;)) {
  print(&quot;Yes, this is a character from Friends.&quot;)
}</code></pre>
<pre><code>## [1] &quot;Yes, this is a character from Friends.&quot;</code></pre>
<p>Hier erhalten wir die Antwort, ja, Monica ist eine Figur aus der Serie. Der Ausdruck <code>%in%</code> steht sinngemäß für “ist ein Element aus der folgenden Auswahl”.</p>
<p>Wenn wir die gleiche Abfrage auf eine andere Person anwenden, trifft die Bedingung nicht zu, und der Befehl wird nicht ausgeführt.</p>
<pre class="r"><code>person = c(&quot;Marcus&quot;)
if (person %in%  c(&quot;Monica&quot;, &quot;Rachel&quot;, &quot;Chandler&quot;,  &quot;Phoebe&quot;, &quot;Ross&quot;, &quot;Joey&quot;)) {
  print(&quot;Yes, this is a character from Friends.&quot;)
}</code></pre>
<p>Genauso könnten wir aber auch eine Liste von Personen haben und uns entweder fragen, ob mindestens eine Person aus dieser Liste bei “Friends” mitgewirkt hat, oder ob alle Personen dort mitgewirkt haben. Dies geht mit <code>any</code> oder <code>all</code>:</p>
<pre class="r"><code>persons = c(&quot;Monica&quot;, &quot;Marcus&quot;)
if (any(persons %in%  c(&quot;Monica&quot;, &quot;Rachel&quot;, &quot;Chandler&quot;,  &quot;Phoebe&quot;, &quot;Ross&quot;, &quot;Joey&quot;))) {
  print(&quot;Yes, at least one of them is a character from Friends.&quot;)
}</code></pre>
<pre><code>## [1] &quot;Yes, at least one of them is a character from Friends.&quot;</code></pre>
<pre class="r"><code>if (all(persons %in%  c(&quot;Monica&quot;, &quot;Rachel&quot;, &quot;Chandler&quot;,  &quot;Phoebe&quot;, &quot;Ross&quot;, &quot;Joey&quot;))) {
  print(&quot;Yes, at all of them are a character from Friends.&quot;)
}</code></pre>
<p>An diesem Beispiel wird der Unterschied der beiden Befehle deutlich. Um das Ganze nochmals zu untermauern:</p>
<pre class="r"><code># mindestens 1 ist TRUE
any(persons %in%  c(&quot;Monica&quot;, &quot;Rachel&quot;, &quot;Chandler&quot;,  &quot;Phoebe&quot;, &quot;Ross&quot;, &quot;Joey&quot;)) </code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code># alle 1 sind TRUE
all(persons %in%  c(&quot;Monica&quot;, &quot;Rachel&quot;, &quot;Chandler&quot;,  &quot;Phoebe&quot;, &quot;Ross&quot;, &quot;Joey&quot;))</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Mit diesen beiden Befehlen können wir leicht prüfen, ob alle Elemente oder mindestens einer eine Eigenschaft erfüllt.</p>
</div>
<div id="abgleich-mit-einem-datum" class="section level3">
<h3>Abgleich mit einem Datum</h3>
<p>Es sind beispielsweise auch logische Abfragen mit Zeitpunkten und Daten möglich. Zum Beispiel können wir mit dem Befehl <code>weekdays(Sys.Date())</code> ermitteln, welcher Wochentag gerade ist, und dann abgleichen, ob Freitag ist. Wenn Sie diesen Befehl selbst testen, achten Sie darauf, ob nach der Voreinstellung Ihres Rechners der aktuelle Wochentag auf Englisch oder Deutsch ausgegeben wird. Das finden Sie heraus, indem Sie nur den kleinen Codeabschnitt <code>weekdays(Sys.Date())</code> ausführen.</p>
<pre class="r"><code>if (weekdays(Sys.Date()) == &quot;Friday&quot;) {
  print(&quot;Fast Wochenende!&quot;)
}</code></pre>
</div>
<div id="verknüpfung-logischer-abfragen" class="section level3">
<h3>Verknüpfung logischer Abfragen</h3>
<p>Wie im letzten Semester bereits besprochen, können logische Bedingungen mit <code>&amp;</code> (logisches “und”) und <code>|</code> (logisches “oder”) verknüpft werden. Wenn die gesamte logische Abfrage als Ergebnis <code>TRUE</code> zurückgibt, wird die <code>R</code>-Syntax in den geschwungenen Klammern ausgeführt; wenn es <code>FALSE</code> ergibt, passiert nichts. Zum Beispiel könnten wir so testen, ob <em>entweder</em> Samstag <em>oder</em> Sonntag ist und herausfinden, ob wir uns freuen dürfen.</p>
<pre class="r"><code>if (weekdays(Sys.Date()) == &quot;Saturday&quot; | weekdays(Sys.Date()) == &quot;Sunday&quot;) {
  print(&quot;Hoch die Hände, Wochenende!&quot;)
}</code></pre>
<p>Durch die logische Verknüpfung mit <code>|</code> (logisches “oder”) wird die gesamte Abfrage wahr, wenn entweder der erste oder der zweite Teil zutrifft (in Worten “ist heute entweder Samstag <strong>oder</strong> Sonntag?”). Hätten wir an dieser Stelle stattdessen eine Verknüpfung mit <code>&amp;</code> (logisches “und”) gewählt, könnte die Bedingung “ist heute Samstag <strong>und</strong> Sonntag?” nicht zutreffen, würde also immer <code>FALSE</code> zurückgeben. An anderer Stelle ist das <code>&amp;</code> aber notwendig, wenn mehrere Bedingungen erfüllt sein sollen.</p>
<p>Bei der Verknüpfung dieser logischen Abfragen muss auf Klammersetzung geachtet werden, wenn die Verknüpfung komplizierter wird. Beispiel: “Ist heute (Samstag <strong>oder</strong> Sonntag) <strong>und</strong> scheint die Sonne?”. Als Übung können Sie versuchen diese logische Abfrage mit fiktiven Variablen in Code auszudrücken.</p>
</div>
</div>
<div id="abgleich-mit-mehreren-alternativen-if-else-abfragen" class="section level2">
<h2>Abgleich mit mehreren Alternativen: if-else-Abfragen</h2>
<p>Häufig wollen wir nicht nur konditional einen Befehl ausführen, oder nicht ausführen, sondern möchten einen anderen Befehl angeben, der ausgeführt wird, wenn die Bedingung nicht zutrifft. Um zwischen zwei alternativen Befehlen auszuwählen, ergänzen wir das <code>else</code>. Der Befehl nach dem <code>else</code> kommt zum Tragen, wenn die Bedingung <em>nicht</em> zutrifft. Dies lässt sich fast wörtlich lesen “If the condition is true, then do one thing. Otherwise (else), do the other thing.”</p>
<pre class="r"><code># mehrere Zeilen
if (weekdays(Sys.Date()) == &quot;Saturday&quot; | weekdays(Sys.Date()) == &quot;Sunday&quot;) {
  print(&quot;Hoch die Hände, Wochenende!&quot;)
}else{
  print(&quot;Nur noch wenige Tage bis zum ersehnten Wochenende!&quot;)
}</code></pre>
<pre><code>## [1] &quot;Nur noch wenige Tage bis zum ersehnten Wochenende!&quot;</code></pre>
<pre class="r"><code># eine enorm lange Zeile
if (weekdays(Sys.Date()) == &quot;Saturday&quot; | weekdays(Sys.Date()) == &quot;Sunday&quot;) print(&quot;Hoch die Hände, Wochenende!&quot;) else print(&quot;Nur noch wenige Tage bis zum ersehnten Wochenende!&quot;)</code></pre>
<pre><code>## [1] &quot;Nur noch wenige Tage bis zum ersehnten Wochenende!&quot;</code></pre>
<p>Bei Code über mehrere Zeilen ist es wichtig, die geschweiften Klammern korrekt zu setzen. Nach der Bedingungsabfrage öffnen sich geschweifte Klammern, die den ersten konditionalen Befehl einschließen. Das <code>else</code> folgt darauf. Danach wird der alternative Befehl wieder in geschweiften Klammern eingefasst. Der <code>else</code>-Befehl muss in der gleichen Zeile stehen wie die geschlossene geschweifte Klammer. Der Beginn der geschweiften Klammern kann auch in die nächste Zeile verschoben werden:</p>
<pre class="r"><code>if (weekdays(Sys.Date()) == &quot;Saturday&quot; | weekdays(Sys.Date()) == &quot;Sunday&quot;) 
{
  print(&quot;Hoch die Hände, Wochenende!&quot;)
}else
{
  print(&quot;Nur noch wenige Tage bis zum ersehnten Wochenende!&quot;)
}</code></pre>
<pre><code>## [1] &quot;Nur noch wenige Tage bis zum ersehnten Wochenende!&quot;</code></pre>
<p>Das gilt sowohl für <code>if</code>, als auch für <code>else</code>. Die einzige Bedingung ist, dass <code>}else</code> eine Zeile ergibt, damit <code>R</code> weiß, auf welches <code>if</code> sich das <code>else</code> bezieht!</p>
<div id="else-if-bedingungen" class="section level3">
<h3><code>else if</code>-Bedingungen</h3>
<p>Häufig werden mehrere Abfragen ineinander geschachtelt, sodass die Ausdrücke schnell sehr kompliziert werden können. Falls in mehreren Schritten verschiedene Bedingungen abgefragt werden, und verschiedene Konsequenzen folgen sollen, kann auch das <code>else if</code> verwendet werden. Hierbei werden verschiedene Möglichkeiten abgefragt, für die verschiedene Befehle ausgeführt werden sollen. Wenn die erste Bedingung nicht zutrifft, wird die zweite Bedingung (nach dem <code>else if</code>) geprüft, wenn diese auch nicht zutrifft, wird das nächste <code>else if</code> geprüft. Der Befehl nach dem <code>else</code> wird dann nur ausgeführt, wenn keine der vorherigen Bedingungen zutrifft.</p>
<p><img src="/post/date.jpg" style="width:70.0%" /></p>
<p>Hier sehen Sie ein Beispiel für eine if-else-Abfrage, die Sie jeden Morgen nutzen können, um herauszufinden, wie Sie sich heute fühlen sollten.</p>
<pre class="r"><code>if (weekdays(Sys.Date()) %in% c(&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)) {
  if (weekdays(Sys.time()) == &#39;Monday&#39;) {
    print(&#39;Zurück ins Bett...&#39;)
    } else if (weekdays(Sys.time()) == &#39;Wednesday&#39;) { 
    print(&#39;Wuhu, es ist Mitte der Woche!&#39;)
      } else if (weekdays(Sys.time()) == &#39;Friday&#39;) { 
    print(&#39;Yeah, das Wochenende steht bevor!&#39;)
        } else {
    print(&#39;Es ist irgendein anderer Tag.&#39;)
        }
  } else {
  print(&quot;Hoch die Hände, Wochenende!&quot;)
}</code></pre>
<pre><code>## [1] &quot;Hoch die Hände, Wochenende!&quot;</code></pre>
<p>Wir versuchen nachzuvollziehen, was in dieser verschachtelten <code>if-else-Abfrage</code> passiert. Zunächst wird geprüft, ob es sich heute um einen Wochentag handelt:</p>
<pre class="r"><code>if (weekdays(Sys.Date()) %in% c(&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)) {</code></pre>
<p>Wenn dem so ist, wird der nächste Block ausgeführt:</p>
<pre class="r"><code>if (weekdays(Sys.time()) == &#39;Monday&#39;) {
    print(&#39;Zurück ins Bett...&#39;)
    } else if (weekdays(Sys.time()) == &#39;Wednesday&#39;) { 
    print(&#39;Wuhu, es ist Mitte der Woche!&#39;)
      } else if (weekdays(Sys.time()) == &#39;Friday&#39;) { 
    print(&#39;Yeah, das Wochenende steht bevor!&#39;)
        } else {
    print(&#39;Es ist irgendein anderer Tag.&#39;)
        }</code></pre>
<p>Dieser fragt ab, ob heute Montag ist (<code>if (weekdays(Sys.time()) == 'Monday') {</code>), falls dem nicht so ist, wird geprüft ob Mittwoch ist (<code>} else if (weekdays(Sys.time()) == 'Wednesday') {</code>), wenn dem wiederum nicht so ist, dann wird geprüft ob Freitag ist (<code>} else if (weekdays(Sys.time()) == 'Friday') {</code>) und falls dem auch nicht so ist, dann wird <code>else</code> ausgeführt.</p>
<p>Ist heute kein Wochentag, dann wird direkt die <code>else</code> Bedingung für die erste <code>if</code>-Abfrage ausgedruckt, nämlich</p>
<pre class="r"><code>  } else {
  print(&quot;Hoch die Hände, Wochenende!&quot;)
}</code></pre>
<p>Dieses Spiel der Verschachtelung lässt sich beliebig erweitern.</p>
<p>Natürlich sind Wenn-Dann-Abfragen eigentlich hauptsächlich dann nützlich, wenn der Code für verschiedene Daten, Objekte oder Funktionen mehrfach genutzt werden soll und man nicht in jedem Einzelfall schon vorher weiß, welche Inhalte die Objekte haben, mit denen man arbeitet. Ein einfaches Beispiel mit einer zufällig gezogenen Zahl könnte so aussehen:</p>
<pre class="r"><code>x &lt;- sample(1:10, 1)
if (x &gt; 5) {
  y &lt;- 1
} else {
  y &lt;- 0
}
x</code></pre>
<pre><code>## [1] 7</code></pre>
<pre class="r"><code>y</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Wenn Sie diesen Code mehrfach ausführen, bekommen Sie immer wieder unterschiedliche Paare an <code>x</code> und <code>y</code>. Auch der erste Versuch muss nicht mit den hier auf <code>PandaR</code> zu findenden Ergebnissen übereinstimmen, da wir keinen Seed verwenden. Probieren Sie dies gerne aus!</p>
</div>
<div id="funktion-ifelse" class="section level3">
<h3>Funktion <code>ifelse</code></h3>
<p>Wenn nur eine Bedingung abgefragt werden soll, und je nach Ergebnis einer von zwei Befehlen folgen soll, kann der Code abgekürzt werden. Für einzelne Ereignisse kann in <code>R</code> die Notation mithilfe der <code>ifelse</code>-Funktion verwendet werden. Diese ist (anders als die <code>if-Abfragen</code>) eine klassische Funktion mit Argumenten. Die Funktion nimmt drei Argumente entgegen:</p>
<ul>
<li><code>test</code>: die Bedingung</li>
<li><code>yes</code>: was getan werden soll, wenn die Bedingung zutrifft</li>
<li><code>no</code>: was getan werden soll, wenn die Bedingung nicht zutrifft</li>
</ul>
<pre class="r"><code>ifelse(test = weekdays(Sys.Date()) == &#39;Friday&#39;, yes = &#39;Yeah, das Wochenende steht bevor!&#39;, no = &#39;Es ist irgendein anderer Tag...&#39;)</code></pre>
<pre><code>## [1] &quot;Es ist irgendein anderer Tag...&quot;</code></pre>
<p>So wird die gleiche <code>if-else-Abfrage</code> verkürzt dargestellt. Gerade für komplexere Abfragen kann aber nicht immer diese verkürzte Form gewählt werden. Die längere Version ist immer dann von Vorteil, wenn der auszuführende <code>R</code>-Code mehrere Zeilen lang ist oder z.B. weitere Bedingungen enthält. Auch lässt er sich oft übersichtlicher gestalten.</p>
</div>
</div>
<div id="loops-schleifen" class="section level2">
<h2>Loops (Schleifen)</h2>
<p>Beim Programmieren kommt es häufig vor, dass der gleiche Befehl mehrfach angewandt werden muss. Loops (oder Schleifen) bieten die Möglichkeit, den gleichen <code>R</code>-Code mehrmals anzuwenden, ohne ihn wiederholt schreiben zu müssen.</p>
<blockquote>
<p>Wichtiges Grundprinzip des Programmierens: DRY = Don’t Repeat Yourself (Hunt &amp; Thomas, “The Pragmatic Programmer”)</p>
</blockquote>
<p>Gerade in Kombination mit <code>if</code> und <code>else</code> kann man so sehr kurze, leserliche Skripte verfassen und potentielle Fehler, die sich in sehr lange Skripte gerne einschleichen, umgehen. In <code>R</code> werden drei Arten von Loops unterschieden: <code>for</code>-Loops, <code>while</code>-Loops und <code>repeat</code>-Loops.</p>
<div id="for-loops" class="section level3">
<h3><code>for</code>-Loops</h3>
<p>In <code>for</code>-Loops wird ein Abschnitt eines R-Codes für jedes Element in einem vorab festgelegten Objekt durchgeführt. Mit dem <code>for</code>-Loop wird ein Befehl für jedes Element dieses Objekts bzw. Vektors durchgeführt. Das funktoiniert über den Befehl <code>for (i in vekt) {}</code>. Das <code>i</code> ist hierbei ein willkürlicher Platzhalter für die Elemente im Vektor <code>vekt</code>, über die dann iteriert wird. <code>vekt</code> muss vorher definiert sein (somit ist der Name auch “willkürlich”, wir müssen ihn jedoch vorher schon als Objekt hinterlegt haben) und kann anstelle eines Vektors auch eine Liste enthalten (dann würde über eine Liste iteriert werden). <code>i</code> nimmt nacheinander alle vorhandenen Werte in <code>vekt</code> an und durchläuft mit jedem dieser Elemente die Befehle in den geschweiften Klammern.</p>
<p>Dies lässt sich anschaulich darstellen, wenn der Befehl, der für jedes Element im Vektor ausgeführt wird, die <code>print</code>-Funktion ist. <code>i</code> wird nacheinander als jedes der drei Elemente (hier Wörter/Sätze) des Vektors definiert, und dann durch <code>print(i)</code> in die Konsole geschrieben.</p>
<pre class="r"><code>vekt &lt;- c(&quot;Hallo!&quot;, &quot;Viel Spaß im R Praktikum.&quot;, &quot;Viel Erfolg für das weitere Semester.&quot;)
for (i in vekt) {
  print(i)
}</code></pre>
<pre><code>## [1] &quot;Hallo!&quot;
## [1] &quot;Viel Spaß im R Praktikum.&quot;
## [1] &quot;Viel Erfolg für das weitere Semester.&quot;</code></pre>
<p>Es ist für den <code>for</code>-Loop nötig, vorher zu wissen, für welche Fälle ein Skript durchgeführt werden muss. In diesem Beispiel sind die Fälle die drei Elemente des Vektors <code>vekt</code>.</p>
<p><em>Anwendungsbeispiel:</em> Loops sind zum Beispiel nützlich für das Rekodieren von Items. Der <code>mdbf</code> Datensatz enthält 98 Beobachtungen in 12 Variablen, allesamt Items des <strong>M</strong>ehr<strong>d</strong>imensionalen <strong>B</strong>efindlichkeits<strong>f</strong>ragebogens. In diesem Fragebogen werden Adjektive zur Beschreibung der aktuellen Stimmung genutzt um die drei Dimensionen der Stimmung - Gut vs. Schlecht, Wach vs. Müde und Ruhig vs. Unruhig - zu erheben. Dafür laden wir zunächst den mdbdf-Datensatz von der Pandar-Website, und schauen uns die ersten Zeilen an.</p>
<pre class="r"><code>load(url(&quot;https://pandar.netlify.app/post/mdbf.rda&quot;))
head(mdbf)</code></pre>
<pre><code>##   stim1 stim2 stim3 stim4 stim5 stim6 stim7 stim8 stim9 stim10 stim11 stim12
## 1     4     4     3     2     3     4     1     4     3      3      2      3
## 2     4     2     1     1     4     5     4     4     2      4      1      3
## 3     4     3     4     3     2     3     2     3     4      2      3      2
## 4     4     4     1     1     3     3     4     4     1      3      1      4
## 5     4     3     2     2     3     4     3     4     2      3      2      4
## 6     4     4     3     2     2     3     2     4     3      3      3      3</code></pre>
<table>
<thead>
<tr class="header">
<th>Variable</th>
<th>Adjektiv</th>
<th>Richtung</th>
<th>Dimension</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>stim1</code></td>
<td>zufrieden</td>
<td>positiv</td>
<td>Gut vs. Schlecht</td>
</tr>
<tr class="even">
<td><code>stim2</code></td>
<td>ausgeruht</td>
<td>positiv</td>
<td>Wach vs. Müde</td>
</tr>
<tr class="odd">
<td><code>stim3</code></td>
<td>ruhelos</td>
<td>negativ</td>
<td>Ruhig vs. Unruhig</td>
</tr>
<tr class="even">
<td><code>stim4</code></td>
<td>schlecht</td>
<td>negativ</td>
<td>Gut vs. Schlecht</td>
</tr>
<tr class="odd">
<td><code>stim5</code></td>
<td>schlapp</td>
<td>negativ</td>
<td>Wach vs. Müde</td>
</tr>
<tr class="even">
<td><code>stim6</code></td>
<td>gelassen</td>
<td>positiv</td>
<td>Ruhig vs. Unruhig</td>
</tr>
<tr class="odd">
<td><code>stim7</code></td>
<td>müde</td>
<td>negativ</td>
<td>Wach vs. Müde</td>
</tr>
<tr class="even">
<td><code>stim8</code></td>
<td>gut</td>
<td>positiv</td>
<td>Gut vs. Schlecht</td>
</tr>
<tr class="odd">
<td><code>stim9</code></td>
<td>unruhig</td>
<td>negativ</td>
<td>Ruhig vs. Unruhig</td>
</tr>
<tr class="even">
<td><code>stim10</code></td>
<td>munter</td>
<td>positiv</td>
<td>Wach vs. Müde</td>
</tr>
<tr class="odd">
<td><code>stim11</code></td>
<td>unwohl</td>
<td>negativ</td>
<td>Gut vs. Schlecht</td>
</tr>
<tr class="even">
<td><code>stim12</code></td>
<td>entspannt</td>
<td>positiv</td>
<td>Ruhig vs. Unruhig</td>
</tr>
</tbody>
</table>
<p>In der Spalte <em>Dimension</em> sehen wir, dass die Items 3 verschiedene Dimensionen abbilden: <em>Gut vs. Schlecht</em>, <em>Wach vs. Müde</em> und <em>Ruhig vs. Unruhig</em>. Die Items sind dabei unterschiedlich gepolt - die Adjektive “ausgeruht” und “schlapp” erfasst beide die Dimension <em>Wach vs. Müde</em>, jedoch in unterschiedlicher Ausrichtung. Um die drei Skalenwerte berechnen zu können müssen die jeweils “negativen” Adjektive ins Positive umgepolt werden. Hierzu gibt es zum Beispiel folgende zwei Möglichkeiten, die wir bereits aus dem vergangenen Semester kennen. Zum Einen können wir bei den entsprechenden Items die Skalenwerte ersetzen:</p>
<pre class="r"><code>mdbf$stim4_r[mdbf$stim4 == 1] &lt;- 4
mdbf$stim4_r[mdbf$stim4 == 2] &lt;- 3
mdbf$stim4_r[mdbf$stim4 == 3] &lt;- 2
mdbf$stim4_r[mdbf$stim4 == 4] &lt;- 1</code></pre>
<p>Oder wir können das Vorgehen verkürzen, indem wir die folgende Berechnungsweise anwenden:</p>
<pre class="r"><code>mdbf$stim4_r &lt;- -1 * (mdbf$stim4 - 5)</code></pre>
<p>Aber trotz der Verkürzung haben wir nun erst ein einziges Item umcodiert. Mit Hilfe von Loops können wir uns die Arbeit ersparen, diesen Abschnitt für jedes negative Adjektiv schreiben zu müssen. <em>Wir erinnern uns: Für den <code>for</code>-Loop müssen wir wissen, für welche Fälle ein Skript durchgeführt werden muss.</em> Für die Umcodierung der Items speichern wir also alle negativen Items in einem Vektor <code>neg</code> (Häufig werden auch die Spaltennummern verwendet):</p>
<pre class="r"><code># Kopie des Datensatzes erstellen, um Datenverlust vorzubeugen
mdbf_r &lt;- mdbf

# Vektor der negativen Items
neg &lt;- c(&quot;stim3&quot;, &quot;stim4&quot;, &quot;stim5&quot;, &quot;stim7&quot;, &quot;stim9&quot;, &quot;stim11&quot;)</code></pre>
<p>In <code>neg</code> wird kodiert, welche Items negativ formuliert sind, und in die Umcodierung einbezogen werden sollen. Danach wenden wir die oben bereits gezeigte Formel erneut an, hier jedoch nacheinander auf jedes der Elemente, die in <code>neg</code> gespeichert sind. Dabei nimmt i nacheinander die Namen der Variablen an stim3, stim4, stim5, stim7,… an. Nun können wir mit <code>mdbf_r[, i]</code> (bzw. <code>mdbf[, i]</code>) die richtige Spalte im Datensatz anwählen (<code>mbdf_r[[i]]</code> geht entsprechend auch, da es sich bei <code>mdbf_r</code> um einen <code>data.frame</code> handelt), also im ersten Schritt mit <code>mdbf_r[, "stim3"]</code> (bzw. <code>mdbf[, "stim3"]</code>) die dritte Variable <em>stim3</em>, also das dritte Item. Der Platzhalter <code>i</code>iteriert also durch die Elemente von <code>neg</code>. Damit bei mehrmaligem durchführen des Skriptes nicht immer hin- und herkodiert wird, speichern wir die Berechnung mit Hilfe von <code>mdbf[, i]</code> in <code>mdbf_r[, i]</code> ab.</p>
<pre class="r"><code>for (i in neg) {
  mdbf_r[, i] &lt;- -1 * (mdbf[, i] - 5)
}</code></pre>
<p>Zur Prüfung des Erfolges berechnen wir die Korrelation des Items <code>stim3</code> im originalen Datensatz und im umcodierten Zustand.</p>
<pre class="r"><code>cor(mdbf[, &quot;stim3&quot;], mdbf_r[, &quot;stim3&quot;])</code></pre>
<pre><code>## [1] -1</code></pre>
<p>Um Ihr Verständnis zu überprüfen, versuchen Sie, in einer neuen Kopie des Datensatzes jetzt stattdessen alle positiven Items umzucodieren!</p>
<p>Zudem können <code>for</code>-Loops ineinander geschachtelt werden. Dabei wird für die zweite Iteration häufig <code>ii</code> als Platzhalter verwendet. Im Befehl kann dann auf <code>i</code> und <code>ii</code> Bezug genommen werden. Hier sehen Sie beispielsweie, wie Sie ineinander geschachtelt durch einen Vektor aus Buchstaben und einen Vektor aus Zahlen iterieren. Was passiert, wenn Sie den ersten <code>print</code>-Befehl außerhalb des inneren Loops platzieren? Versuchen Sie, den Unterschied nachzuvollziehen.</p>
<pre class="r"><code>Buchstaben &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)
Zahlen &lt;- c(1,2)
for (i in Buchstaben) {
  for (ii in Zahlen) {
    print(i)
    print(ii) 
  }
}</code></pre>
<pre><code>## [1] &quot;A&quot;
## [1] 1
## [1] &quot;A&quot;
## [1] 2
## [1] &quot;B&quot;
## [1] 1
## [1] &quot;B&quot;
## [1] 2
## [1] &quot;C&quot;
## [1] 1
## [1] &quot;C&quot;
## [1] 2</code></pre>
<p>Das <code>i</code> und <code>ii</code> sind hier willkürlich gewählte Platzhalter. Wir könnten auch jeden anderen Buchstaben (oder Zeichenkombination) wählen. Es bietet sich an, Namen zu vergeben, die sinnvoll für den Sachverhalt sind und es auch bei mehreren Schachtelungen möglich machen, zu erkennen, um was es sich gerade handelt. Für dieses Beispiel würde sich bspw. <code>for(buchstabe in Buchstaben)</code> [oder auch: <code>for(b in Buchstaben)</code>] und <code>for(zahl in Zahlen)</code> [oder auch: <code>for(z in Zahlen)</code>] anbieten.</p>
</div>
<div id="weitere-loops" class="section level3">
<h3>Weitere Loops</h3>
<p>Weitere häufig verwendete Loops sind die <code>while</code> und die <code>repeat</code>-Loop: In <code>while</code>-Loops wird der Code so lange ausgeführt, bis eine vorab definierte Bedingung erfüllt ist. Im Gegensatz zu <code>for</code> und <code>while</code> wird bei <code>repeat</code> zunächst kein explizites Abbruchkriterium definiert. Stattdessen wird <code>repeat</code> häufig genutzt, wenn es verschiedene oder veränderliche Abbruchkriterien für den Loop gibt. Diese Kriterien werden bei <code>repeat</code> allerdings innerhalb des Loops definiert - in den meisten Fällen wird dazu über <code>if</code> mindestens eine Bedingung definiert, unter der die Ausführung abgebrochen werden soll. Eine Loop (auch <code>for</code> oder <code>while</code>) können mit dem <code>break</code>-Befehl beendet werden. Für mehre Informationen zu <code>while</code>, <code>repeat</code> und <code>break</code> siehe <a href="#AppendixA">Appendix A</a>.</p>
<p><em>Anmerkung:</em> Generell sollten Loops in <code>R</code> nur genutzt werden, wenn keine vektorbasierte Alternative zur Verfügung steht. Zum Beispiel: um eine Variable zu zentrieren sollte nicht ein Loop genutzt werden, der von jedem Element des Vektors den Mittelwert abzieht (bei Interesse an einem Laufzeitvergleich siehe <a href="#AppendixB">Appendix B</a>. Stattdessen ist <code>R</code> in der Lage den Mittelwert direkt von jedem Element des Vektors abzuziehen (elementeweise Anwendung) - diese Umsetzung ist also direkt Vektor-basiert und in <code>R</code> (beinahe ausnahmslos) die schnellere und effizientere Variante.</p>
</div>
</div>
<div id="function" class="section level2">
<h2>Funktionen</h2>
<p>Sie haben bereits gelernt, dass (fast) alle Aktionen, die in <code>R</code> ausgeführt werden, sich sogenannte Funktionen zunutze machen. Hier wollen wir noch einen Schritt weiter gehen, und lernen, wie Sie <em>selbst Funktionen schreiben</em> können. Funktionen, die in <code>R</code> angewendet werden können, sind ebenfalls Objekte. Dadurch können eigene Funktionen wie andere Objekte auch angelegt werden - dazu müssen sie lediglich mit der <code>function</code>-Funktion erstellt werden. Im Allgemeinen sieht das wie folgt aus:</p>
<pre class="r"><code>eigene_funktion &lt;- function(argument1, argument2, ...) {
  # Durchgeführte Operationen
}</code></pre>
<p>Der Name der erstellen Funktion steht hier ganz am Anfang. <code>function</code> ist die Funktion, die dafür zuständig ist, neue Funktionen zu definieren. In den runden Klammern dahinter müssen Sie angeben, welche <em>Argumente</em> Ihre Funktion annehmen soll. Auf diese Argumente können Sie in der Beschreibung der Operationen zugreifen. In geschweiften Klammern geben Sie als nächstes an, welche Operationen mit den genannten Argumenten durchgeführt werden sollen. Als Argumente können beliebig viele Einstellungen für die Funktion definiert werden, auf die dann in der Funktion Bezug genommen wird. Wichtig ist dabei, dass Funktionen keinen generellen Zugriff auf den Workspace haben, sondern alle Objekte, die sie benötigen, durch die Argumente an sie weitergegeben werden müssen. Auch innerhalb einer Funktion definierte Objekte können nicht außerhalb der Funktion genutzt werden!</p>
<div id="beispiel-varianzfunktion" class="section level3">
<h3>Beispiel Varianzfunktion</h3>
<p>In <code>R</code> wird mit der <code>var</code>-Funktion die Schätzung für die Populationsvarianz <span class="math inline">\(\widehat{\sigma}^2\)</span> und nicht die empirische Varianz <span class="math inline">\(s\)</span> bestimmt. Wir könnten also eine eigene Funktion anlegen, die die empirische Varianz schätzt. Dafür können wir die Formel zur Varianzberechnung einfach in <code>R</code>-Code übersetzen:</p>
<p><span class="math display">\[s^2 = \frac{\sum_{i=1}^n(x_i - \bar{x})^2}{n}\]</span></p>
<p>Als <code>R</code>-Code würde wir also zunächst die einzelnen Elemente definieren, und dann nach dem Vorbild der Formel die Varianz berechnen.</p>
<pre class="r"><code>x &lt;- mdbf[, 1]
n &lt;- length(x)
s2 &lt;- sum((x - mean(x))^2) / n
s2</code></pre>
<pre><code>## [1] 0.482299</code></pre>
<p>Dieser Code funktioniert allerdings nur für eine einzige Variable mit dem Namen <code>x</code> und wir müssten den Code für jede einzelne Anwendung wiederholen. Um das abzukürzen, können wir eine eigene, <em>wiederverwendbare</em> Funktion anlegen. Dafür nutzen wir wie oben beschrieben die Funktion <code>function</code>. Unsere neue Funktion soll <code>empVar</code> heißen, und erhält nur ein einziges Argument <code>x</code>. In den geschweiften Klammern definieren wir, wie die Berechnung funktionieren soll.</p>
<pre class="r"><code>empVar &lt;- function(x) {
  n &lt;- length(x)
  s2 &lt;- sum((x - mean(x))^2)/n
}

empVar(mdbf[, 1])</code></pre>
<p>Nun erhalten wir jedoch kein Ergebnis, wenn wir diese Funktion auf <code>empVar(mdbf[, 1])</code> anwenden. Dafür müssen wir zusätzlich mit <code>return</code> definieren, was der <em>Ausgabewert</em> der Funktion sein soll. In diesem Fall wird das Ergebnis der Berechnung ausgegeben. Wenn kein <code>return</code>-Wert definiert wird, gibt die Funktion bei der Anwendung kein Ergebnis in die Konsole aus. Wir haben auch keinen Zugriff auf das Objekt s2. Eine Funktion ohne <code>return</code> wird zwar ausgeführt, man hat aber keinen Zugriff auf das Ergebnis, weil alle innerhalb der Funktion angelegten Objekte entfernt werden, sobald die Durchführung der Funktion abgeschlossen ist. Funktionen sollten also prinzipiell mit <code>return</code> Ergebnisse nach außen geben:</p>
<pre class="r"><code>empVar &lt;- function(x) {
  n &lt;- length(x)
  s2 &lt;- sum((x - mean(x))^2)/n
  return(s2)
}</code></pre>
<p>Diese Funktion kann jetzt auf jede beliebige Variable angewendet werden:</p>
<pre class="r"><code>empVar(mdbf[, 1])</code></pre>
<pre><code>## [1] 0.482299</code></pre>
<pre class="r"><code>empVar(mdbf[, 2])</code></pre>
<pre><code>## [1] 0.7213661</code></pre>
<p>Das Einzige, was diese Funktion von in <code>R</code> implementierten Paketen unterscheidet ist, dass sie explizit im Workspace bzw. Environment angezeigt wird. Dies können Sie mit dem <code>ls()</code>-Befehl ausprobieren. Außerdem sehen Sie die Funktion in <code>R</code>-Studio oben rechts in dem Fenster, in dem auch die Daten etc. dargestellt werden unter <strong>Functions</strong>.</p>
<p>Weil beim Durchführen von Funktionen als erstes der Workspace nach definierten Funktionen durchsucht wird, sollten Funktionen möglichst einzigartig benannt werden, weil sonst nicht mehr (so leicht) auf die <code>R</code>-internen Funktionen zugegriffen werden kann.</p>
<p>Zusätzlich sollte beachtet werden, dass <code>return</code> nur ein einziges Argument entgegennimmt: Funktionen in <code>R</code> können also nur ein einziges Objekt als Ergebnis liefern. Wenn mehrere Ergebnisse ausgegeben werden sollen, müssen diese vorher innerhalb der Funktion zu einem Objekt (meistens einer Liste) zusammengefasst werden. Eine Liste kann benannt werden, indem zunächst die Namen geschrieben werden und diesen dann via <code>=</code> etwas zugeordnet wird:</p>
<pre class="r"><code>empVar &lt;- function(x) {
  n &lt;- length(x)
  s2 &lt;- sum((x - mean(x))^2)/n
  out &lt;- list(&quot;s2&quot; = s2, &quot;n&quot; = n)
  return(out)
}
empVar(mdbf[, 2])</code></pre>
<pre><code>## $s2
## [1] 0.7213661
## 
## $n
## [1] 98</code></pre>
<p>Funktionen können eine beliebige Anzahl von Argumenten entgegennehmen, aber nur ein einziges Objekt als Ergebnis liefern (wobei dieses Objekt natürlich mehrere Elemente haben kann, bspw. hat eine Vektor ja mehrere Einträge oder eine Liste kann auch aus mehreren Vektoren, Matrizen oder anderem bestehen). Um eine gemeinsame Funktion für beide Formen der Varianz zu haben, könnten wir die Anzahl der Argumente erweitern.</p>
<pre class="r"><code>Vari &lt;- function(x, empirical) {
  n &lt;- length(x)
  if (empirical) {
    s2 &lt;- sum((x - mean(x))^2)/n
  } else {
    s2 &lt;- sum((x - mean(x))^2)/(n-1)
  }
  return(s2)
}</code></pre>
<p>Das Argument namens <code>empirical</code> kann in dieser Funktion genutzt werden, um zu entscheiden, welche Varianz-Formel angewandt werden soll. In diesem Fall wird also eine Einstellung für <code>empirical</code> benötigt, die dann von <code>if</code> als <code>TRUE</code> oder <code>FALSE</code> bewertet werden kann:</p>
<pre class="r"><code>Vari(mdbf[, 2], TRUE)</code></pre>
<pre><code>## [1] 0.7213661</code></pre>
<pre class="r"><code>Vari(mdbf[, 2], FALSE)</code></pre>
<pre><code>## [1] 0.7288029</code></pre>
<p>Wenn wir die Einstellung vergessen, wird - wie bei allen anderen <code>R</code> Funktionen auch - ein Fehler produziert. Probieren Sie dies aus, und beachten Sie den Wortlaut der Fehlermeldung. Jetzt sollten Sie verstehen, was diese aussagt und wie der Fehler behoben werden kann!</p>
<pre class="r"><code>Vari(mdbf[, 2])</code></pre>
<pre><code>## Error in Vari(mdbf[, 2]) : 
##   argument &quot;empirical&quot; is missing, with no default</code></pre>
<p>Die Fehlermeldung beinhaltet die Worte <em>with no default</em>. Dies impliziert, dass eine Voreinstellung für das Argument gesetzt werden könnte. Dann müssen Nutzer:innen das Argument nicht mehr zwingend angeben. Wenn Voreinstellungen für Argumente festgelegt werden sollen, erreichen wir das, indem in der runden Klammer direkt der default-Wert für ein Argument mit angegeben wird.</p>
<pre class="r"><code>Vari &lt;- function(x, empirical = TRUE) {
  n &lt;- length(x)
  if (empirical) {
    s2 &lt;- sum((x - mean(x))^2)/n
  } else {
    s2 &lt;- sum((x - mean(x))^2)/(n-1)
  }
  return(s2)
}</code></pre>
<pre class="r"><code>Vari(mdbf[, 2])</code></pre>
<pre><code>## [1] 0.7213661</code></pre>
<p>Solange jetzt nicht explizit etwas bei der Anwendung der Funktion für <code>empirical</code> deklariert wird, wird von der Voreinstellung <code>TRUE</code> ausgegangen.</p>
<p>Außerdem gibt es noch Funktionen wie <code>replicate</code>, <code>apply</code>, <code>lapply</code>, <code>sapply</code>, etc. die die Grenzen zwischen Schleifen und Funktionen etwas verwaschen. Siehe auch <a href="#AppendixA">Appendix A</a>.</p>
</div>
</div>
<div id="anwendung-simulationsstudien-und-poweranalysen" class="section level2">
<h2>Anwendung: Simulationsstudien und Poweranalysen</h2>
<p>In der Sitzung zu <a href="/post/simulation">Simulationsstudien und Poweranalysen</a> aus dem vergangenen Semester hatten wir empirisch die Power und den <span class="math inline">\(\alpha\)</span>-Fehler des <span class="math inline">\(t\)</span>-Tests sowie des Korrelationstest untersucht. Dabei hatten wir <code>replicate</code> verwendet. Bspw. hatten wir mit folgendem Code den <span class="math inline">\(p\)</span>-Wert des <span class="math inline">\(t\)</span>-Tests unter der <span class="math inline">\(H_0\)</span> Hypothese untersucht:</p>
<pre class="r"><code>N &lt;- 20
set.seed(1234)
replicate(n = 10, expr = {X &lt;- rnorm(N)
                          Y &lt;- rnorm(N)
                          ttestH0 &lt;- t.test(X, Y, var.equal = TRUE)
                          ttestH0$p.value})</code></pre>
<pre><code>##  [1] 0.26352442 0.03081077 0.21285027 0.27429670 0.53201656 0.79232864
##  [7] 0.93976306 0.43862992 0.96766599 0.68865560</code></pre>
<p>Wenn wir nun genauer hinschauen, dann sehen wir, dass der Block</p>
<pre class="r"><code>{X &lt;- rnorm(N)
 Y &lt;- rnorm(N)
 ttestH0 &lt;- t.test(X, Y, var.equal = TRUE)
 ttestH0$p.value}</code></pre>
<p>im Grunde nichts weiter darstellt, als das Innere einer Funktion. <code>replicate</code> ist im Grunde nichts anderes als eine bestimmte <code>for</code>-Schleife, nämlich eine <code>for</code>-Schleife, in welcher das Argument nicht genutzt wird! Wir schreiben das Ganze mal mittels einer Funktion:</p>
<pre class="r"><code>mySim &lt;- function(N)
{
  X &lt;- rnorm(N)
  Y &lt;- rnorm(N)
  ttestH0 &lt;- t.test(X, Y, var.equal = TRUE)
  return(ttestH0$p.value)
}
set.seed(1234)
replicate(n = 10, expr = mySim(N = 20))</code></pre>
<pre><code>##  [1] 0.26352442 0.03081077 0.21285027 0.27429670 0.53201656 0.79232864
##  [7] 0.93976306 0.43862992 0.96766599 0.68865560</code></pre>
<p>In der Sitzung zu <a href="/post/simulation">Simulationsstudien und Poweranalysen</a> hatten wir außerdem den empirischen <span class="math inline">\(t\)</span>-Wert untersucht. Diesen können wir nun ganz leicht mit aufnehmen.</p>
<pre class="r"><code>mySim2 &lt;- function(N)
{
  X &lt;- rnorm(N)
  Y &lt;- rnorm(N)
  ttestH0 &lt;- t.test(X, Y, var.equal = TRUE)
  return(c(&quot;p&quot; = ttestH0$p.value, &quot;t&quot; = ttestH0$statistic))
}
set.seed(1234)
replicate(n = 10, expr = mySim2(N = 20))</code></pre>
<pre><code>##          [,1]        [,2]      [,3]       [,4]      [,5]      [,6]      [,7]
## p   0.2635244  0.03081077 0.2128503  0.2742967 0.5320166 0.7923286 0.9397631
## t.t 1.1349024 -2.24295556 1.2670437 -1.1092419 0.6306927 0.2651479 0.0760693
##           [,8]        [,9]     [,10]
## p    0.4386299  0.96766599 0.6886556
## t.t -0.7827414 -0.04080374 0.4037557</code></pre>
<p>Wir sehen, dass die <code>p</code>-Werte und die <code>t</code>-Werte nun gleichzeitig ausgegeben werden und zwar in zwei Zeilen untereinander, da wir den Output als Vektor gewählt haben! In diesem Semester hatten wir uns bisher mit der Regressionsanalyse beschäftigt. Aus diesem Grund wollen wir an dieser Stelle noch kurz anschneiden, wie eine Simulationsstudie für eine Regression durchgeführt werden könnte. Zunächst brauchen wir dazu Prädiktoren. Mit Hilfe der <code>rmvnorm</code> Funktion aus dem <code>mvtnorm</code>-Paket lassen sich leicht multivariat-normalverteilte Zufallsvariablen simulieren, deren Mittelwerte und Kovarianz bekannt ist:</p>
<pre class="r"><code>S &lt;- matrix(c(1, .7, .7, 2), 2, 2) # Populationskovarianzmatrix
S</code></pre>
<pre><code>##      [,1] [,2]
## [1,]  1.0  0.7
## [2,]  0.7  2.0</code></pre>
<pre class="r"><code># install.packages(&quot;mvtnorm&quot;)
library(mvtnorm)
set.seed(1234)
X &lt;- rmvnorm(n = 10^3, mean = c(2, 3), sigma = S)
colMeans(X)</code></pre>
<pre><code>## [1] 1.997926 2.980730</code></pre>
<pre class="r"><code>cov(X)</code></pre>
<pre><code>##          [,1]     [,2]
## [1,] 1.046158 0.719314
## [2,] 0.719314 1.871493</code></pre>
<p>Für größeres <code>n</code> landen wir näher bei den Populationswerten:</p>
<p><span class="math display">\[ \mathbb{E}[X] = \begin{pmatrix} 2 \\ 3 \end{pmatrix},\quad \mathbb{C}ov[X]=\begin{pmatrix} 1 &amp; .7 \\ .7 &amp; 2 \end{pmatrix}.\]</span></p>
<p>Für eine Regressionsanalyse brauchen wir jetzt nur noch ein Residuum, sowie die <span class="math inline">\(\beta\)</span>-Gewichte, um die Variable <span class="math inline">\(Y\)</span> zu definieren. Angenommen wir wollen folgendes Populationsmodell untersuchen:</p>
<p><span class="math display">\[Y_i = 0.3 + 0.5\cdot X_{1i} + 0.3\cdot X_{2i} + \varepsilon_i\]</span></p>
<p>wobei <span class="math inline">\(\varepsilon_i\)</span> eine Residualstandardabweichung von 1.3 haben soll:</p>
<pre class="r"><code>eps &lt;- rnorm(10^3, sd = 1.3)
X1 &lt;- X[,1]
X2 &lt;- X[,2]
Y &lt;- 0.3 + 0.5*X1 + 0.3*X2 + eps
df &lt;- data.frame(&quot;X1&quot; = X1, &quot;X2&quot; = X2, &quot;Y&quot; = Y)</code></pre>
<p>Dann können wir nun leicht eine Regressionsanalyse durchführen:</p>
<pre class="r"><code>reg &lt;- lm(Y ~ 1 + X1 + X2, data = df)
coef(reg) # Koeffizienten abgreifen</code></pre>
<pre><code>## (Intercept)          X1          X2 
##   0.4480455   0.5145347   0.2532168</code></pre>
<p>Wir sehen, dass die Koeffizienten recht nah an den “wahren” Werten liegen. Verpacken wir das Ganze in eine Funktion, so können wir den Bias der Schätzung untersuchen. Der Bias ist die durchschnittliche Abweichung der Schätzung vom wahren Wert. Ein Bias von 0 ist somit erstrebenswert!</p>
<pre class="r"><code>myRegSim &lt;- function(N)
{
  S &lt;- matrix(c(1, .7, .7, 2), 2, 2) # Populationskovarianzmatrix
  X &lt;- rmvnorm(n = N, mean = c(2, 3), sigma = S)
  eps &lt;- rnorm(N, sd = 1.3)
  X1 &lt;- X[,1]
  X2 &lt;- X[,2]
  Y &lt;- 0.3 + 0.5*X1 + 0.3*X2 + eps
  df &lt;- data.frame(&quot;X1&quot; = X1, &quot;X2&quot; = X2, &quot;Y&quot; = Y)
  reg &lt;- lm(Y ~ 1 + X1 + X2, data = df)
  coef(reg) # Koeffizienten abgreifen
  return(coef(reg))
}
set.seed(1234)
replicate(n = 10, expr = myRegSim(N = 10^3))</code></pre>
<pre><code>##                  [,1]      [,2]      [,3]      [,4]      [,5]      [,6]
## (Intercept) 0.4480455 0.4645526 0.0959823 0.4036081 0.3621404 0.4454766
## X1          0.5145347 0.4229675 0.5794930 0.6167309 0.4935631 0.4068533
## X2          0.2532168 0.3155510 0.3264700 0.2033327 0.2789048 0.3184694
##                  [,7]      [,8]      [,9]     [,10]
## (Intercept) 0.2000509 0.2704179 0.2343473 0.4723725
## X1          0.5341167 0.4260486 0.5119222 0.4416930
## X2          0.3038769 0.3344544 0.3198885 0.3067544</code></pre>
<p>Speichern wir das Ganze ab, transponieren es und bilden <code>colMeans</code>, so erhalten wir eine Schätzung für die durchschnittliche Schätzung unseres Experiments (das wir insgesamt 10 Mal unter identischen Voraussetzungen durchführen konnten):</p>
<pre class="r"><code>set.seed(1234)
mySimErg &lt;- t(replicate(n = 10, expr = myRegSim(N = 10^3)))
colMeans(mySimErg)</code></pre>
<pre><code>## (Intercept)          X1          X2 
##   0.3396994   0.4947923   0.2960919</code></pre>
<p>Selbst bei nur 10 Wiederholungen und einer Stichprobengröße von 1000 ist der Bias schon sehr gering (zum Vergleich, die wahren Werte waren 0.3, 0.5, 0.3). Der Bias wird nun so bestimmt:</p>
<p><span class="math display">\[\hat{\theta} - \theta_0,\]</span></p>
<p>wobei <span class="math inline">\(\hat{\theta}\)</span> der durchschnittliche Koeffizient und <span class="math inline">\(\theta_0\)</span> der wahre Koeffizient ist. In den Übungen werden wir uns mit diesem Sachverhalt noch etwas genauer beschäftigen und die neuen Erkenntnisse der Regressionsanalyse mit einfachen Simulationen untermauern. Weitere interessante Größen einer Simulationsstudie sind die Power und der <span class="math inline">\(\alpha\)</span>-Fehler, sowie der mittlere Standardfehler und der Vergleich zwischen mittlerem Standardfehler (<span class="math inline">\(\bar{SE}(\hat{\theta})\)</span> mittlerer geschätzter Streuung der Schätzungen anhand der Daten) und der tatsächlichen Streuung der Schätzungen (<span class="math inline">\(SD(\hat{\theta})\)</span>). Diese Werte können wir untersuchen, indem wir die <code>summary</code> auf das Regressionsobjekt anwenden und anschließend wieder mit <code>coef</code> die Parameterschätzer <code>Estimate</code>, die Standardfehler <code>Std.Error</code>, sowie den <span class="math inline">\(t\)</span>-Wert und den zugehörigen <span class="math inline">\(p\)</span>-Wert bestimmen. Diese Werte sind entscheidend für Signifikanzentscheidungen und somit für Power und <span class="math inline">\(\alpha\)</span>-Fehler.</p>
<p>Zum Abschluss noch ein Gedankenexperiment: Wenn wir immer wieder Daten simulieren, dann erhalten wir von Mal zu Mal unterschiedliche Parameterschätzer. Die <code>Estimates</code> streuen also. Diese Streuung beschreibt die Unsicherheit, die beim Schätzen in einem “endlichen” Sample entsteht. Sie nennt sich bezogen auf eine Monte-Carlo-Simulationsstudie (die wir gerade durchgeführt hatten) MCSD (für Monte-Carlo-Standardabweichung). Der Standardfehler, den wir mit jedem Mal Schätzen bekommen, soll nun eine Schätzung für diese wahre Streuung der Parameterschätzungen sein. Aus diesem Grund wird in Simulationsstudien häufig der durchschnittliche Standardfehler (MCSE) mit der MCSD verglichen. Eine gute Schätzung des SEs für MCSD ist also entscheidend dafür, dass der statistische Test vertrauenserweckende Ergebnisse liefert!</p>
<hr />
</div>
<div id="AppendixA" class="section level2">
<h2>Appendix A</h2>
<details>
<summary>
<strong><code>while</code> und <code>repeat</code>-Loops &amp; weitere Loop-Funktionen</strong>
</summary>
<div id="while-loops" class="section level3">
<h3><code>while</code>-Loops</h3>
<p>In <code>while</code>-Loops wird der Code so lange ausgeführt, bis eine vorab definierte Bedingung erfüllt ist. Ein einfaches Beispiel wäre, so lange einen Münzwurf zu simulieren, bis man 10 mal “Kopf” geworfen hat. Dafür müssen wir zum Einen die Münze als Objekt mit zwei Auswahlmöglichkeiten <em>Kopf</em> und <em>Zahl</em> anlegen, und ein leeres Objekt, in das wir die Ergebnisse der Münzwürfe speichern können.</p>
<pre class="r"><code># Münze erstellen
coin &lt;- c(&#39;Kopf&#39;, &#39;Zahl&#39;)

# Leeres Objekt für die Aufzeichnung erstellen
toss &lt;- NULL</code></pre>
<p>Als nächstes schreiben wir den eigentlichen Loop. Dieser enthält eine logische Abfrage, die abfragt, ob die Anzahl der Kopf-Würfe unter 10 ist. Führen Sie nacheinander die Codeabschnitte <code>toss == 'Kopf'</code>, <code>sum(toss == 'Kopf')</code> und <code>sum(toss == 'Kopf')&lt;10</code> aus, um zu verstehen, wie sich die logische Abfrage zusammensetzt. (<em>Hinweis</em>: den logischen Werten <code>TRUE</code> und <code>FALSE</code> sind die Zahlen 1 und 0 zugeordet.)</p>
<pre class="r"><code># Loop
while (sum(toss == &#39;Kopf&#39;)&lt;10) {
  toss &lt;- c(toss, sample(coin, 1))
}

# Würfe ansehen
toss</code></pre>
<pre><code>##  [1] &quot;Zahl&quot; &quot;Kopf&quot; &quot;Kopf&quot; &quot;Zahl&quot; &quot;Zahl&quot; &quot;Zahl&quot; &quot;Kopf&quot; &quot;Kopf&quot; &quot;Zahl&quot; &quot;Kopf&quot;
## [11] &quot;Kopf&quot; &quot;Kopf&quot; &quot;Zahl&quot; &quot;Kopf&quot; &quot;Kopf&quot; &quot;Kopf&quot;</code></pre>
</div>
<div id="repeat" class="section level3">
<h3><code>repeat</code>-Loops</h3>
<p>Im Gegensatz zu <code>for</code> und <code>while</code> wird bei <code>repeat</code> zunächst kein explizites Abbruchkriterium definiert. Stattdessen wird <code>repeat</code> häufig genutzt, wenn es verschiedene oder veränderliche Abbruchkriterien für den Loop gibt. Diese Kriterien werden bei <code>repeat</code> allerdings innerhalb des Loops definiert - in den meisten Fällen wird dazu über <code>if</code> mindestens eine Bedingung definiert, unter der die Ausführung abgebrochen werden soll.</p>
<p>Ein einfaches Beispiel hierfür ist es, eine Fibonacci-Sequenz zu bilden (eine Sequenz in der eine Zahl immer die Summe der vorherigen beiden Zahlen ist):</p>
<p><span class="math display">\[a_n := a_{n-1} + a_{n-2}\]</span>
für <span class="math inline">\(n&gt;1\)</span> und <span class="math inline">\(a_1=a_0=1\)</span>.</p>
<p>Wir können nun <code>repeat</code> nutzen, um die Sequenz abzubrechen, wenn die letzte Zahl z.B. größer als 1000 ist. An dieser Stelle wissen wir nicht, welches Element das sein wird, bzw. nach wie vielen Schritten dies passiert, wodurch es geschickter ist, innerhalb des Loops das Kriterium zu evaluieren. Wir nutzen hier <code>n-1</code>, <code>n</code>, und <code>n+1</code> als Schritte, da es das 0-te Element in Vektoren in <code>R</code> nicht gibt.</p>
<pre class="r"><code>fibo &lt;- c(1, 1)

repeat {
  n &lt;- length(fibo)
  fibo[n+1] &lt;- fibo[n] + fibo[n - 1]
  if (fibo[n+1] &gt; 1000) break
}

fibo</code></pre>
<pre><code>##  [1]    1    1    2    3    5    8   13   21   34   55   89  144  233  377  610
## [16]  987 1597</code></pre>
<p>Loops können mit <code>break</code> unterbrochen werden - das gilt nicht nur für <code>repeat</code>, sondern auch für die anderen beiden Formen von Loops. Hier wurde eine <code>if</code>-Bedingung in den Loop geschachtelt. In jedem einzelnen Durchlauf des Loops wird geprüft, ob die Bedingung erfüllt ist, und die Durchführung wird beendet (<code>break</code>), sobald dies der Fall ist.</p>
<p>Ergänzen Sie <code>print(fibo)</code> vor der <code>if</code>-Abfrage, und schauen Sie sich das Ergebnis an. Dies zeigt Ihnen gewissermaßen das “Innenleben” Ihres Loops. Sie sehen so genauer, was in jedem Schritt des Loops passiert, und können oftmals leichter nachvollziehen, wodurch beispielsweise Fehler entstehen.</p>
</div>
<div id="apply-funktionen" class="section level3">
<h3><code>apply</code>-Funktionen</h3>
<p>Auch <code>apply</code> und seine Varianten können genutzt werden, um bspw. einen <code>for</code>-Loop auszudrücken. Diese Funktion verkürzt die Schreibweise und kann manchmal auch die Laufzeit verkürzen, insbesondere wenn bspw. das <code>pbapply</code>-Paket verwendet wird, welches einfaches Parallelisieren erlaubt.</p>
<pre class="r"><code>A &lt;- data.frame(&quot;a&quot; = c(2,3,4), &quot;b&quot; = c(1,1,1))
apply(A, 2, mean) # Mittelwert über Spalten/Variablen</code></pre>
<pre><code>## a b 
## 3 1</code></pre>
<pre class="r"><code>colMeans(A)</code></pre>
<pre><code>## a b 
## 3 1</code></pre>
<pre class="r"><code>apply(A, 1, mean) # Mittelwert über Zeilen/Personen/Beobachtungen</code></pre>
<pre><code>## [1] 1.5 2.0 2.5</code></pre>
<pre class="r"><code>rowMeans(A)</code></pre>
<pre><code>## [1] 1.5 2.0 2.5</code></pre>
<pre class="r"><code>apply(A, 2, sd) # Standardabweichung über Spalten/Variable</code></pre>
<pre><code>## a b 
## 1 0</code></pre>
</details>
</div>
</div>
<div id="AppendixB" class="section level2">
<h2>Appendix B</h2>
<details>
<summary>
<strong>Loops vs. Vektorbasiert</strong>
</summary>
<p>An den folgenden Laufzeiten sehen wir, dass Loops tatsächlich deutlich langsamer sind, als die vektorwertige Alternative.</p>
<pre class="r"><code># simuliere 1000 Beobachtungen und bestimme den Mittelwert 
X &lt;- rnorm(10^3, mean = 1, sd = 2)
m &lt;- mean(X)

t1 &lt;- Sys.time() # speichere die Startzeit
X_c &lt;- X
for(x in X)
{
  X_c[i] &lt;- x - m
}
Sys.time() - t1 # bestimmte die Laufzeit durch aktuelle Zeit minus Startzeit</code></pre>
<pre><code>## Time difference of 0.01418686 secs</code></pre>
<pre class="r"><code>t2 &lt;- Sys.time() # speichere die Startzeit
X_c &lt;- X - m
Sys.time() - t2 # bestimmte die Laufzeit durch aktuelle Zeit minus Startzeit</code></pre>
<pre><code>## Time difference of 0.001097918 secs</code></pre>
<p>Loops sind in diesem Beispiel fast um den Faktor 10 langsamer (zumindest, wenn Sie den Code für <code>10^6</code> Beobachtungen durchführen, die Maske, die für diese Website genutzt wird, ist deutlich langsamer, weswegen hier auf <code>10^3</code> ausgewichen wurde…). Es gibt jedoch viele Anwendungsgebiete, wo Loops das Mittel der Wahl sind!</p>
</details>
<hr />
</div>
<div id="r-skript" class="section level2">
<h2>R-Skript</h2>
<p>Den gesamten <code>R</code>-Code, der in dieser Sitzung genutzt wird, können Sie <a href="/post/PsyBSc7_R_Files/Loops-und-Funktionen.R"><svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;"><path d="M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zm368 56a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"/></svg>hier herunterladen</a>.</p>
</div>
</div>
