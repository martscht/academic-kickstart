---
title: Tipps
date: '2019-12-14T21:00:00'
slug: tipps2
categories:
  - Projekt 2
tags: []
subtitle: ''
summary: ''
authors: [mehler]
lastmod: '2019-12-14T18:27:37+01:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

## Vorwarnung


Achtung! Im Folgenden geben wir dir ein paar Tipps, die auch Teile der Lösung enthalten können. Deshalb sollten diese nur dann benutzt werden, wenn du bei einer Aufgabe nicht weiterkommst.


## Tipp 1: Grundprinzip Roulette

In diesem Tipp soll es um die Zufallsziehung und die Gewinnberechnung beim Roulette gehen.

<details><summary> Tipp zur Zufallsziehung </summary>
<p>
Für eine einfache Simulation der Zufallsziehung beim Roulette benutzt man den `sample`-Befehl. Für weitere Informationen zu dieser Funktion und den Argumenten schau dir die interne Hilfe an. Roulette ist nicht sehr kompliziert, du brauchst also nur die Basics.
</p>
<p>
Willst du jetzt 50 Ziehungen in einem Objekt speichern, so gibt es zwei Möglichkeit:

- Entweder du bleibst bei der `sample`-Funktion und benutzt passende Argumente dafür,
- oder du benutzt eine `for`-Schleife, um 50 Mal den gleichen Befehl auszuführen und das Ergebnis jeweils einem Objekt hinzuzufügen. 

</p>
</details>

<details><summary> Tipp zur Gewinnberechnung </summary>
<p>

<p>
Jetzt solltest du einen Vektor mit 50 Ziehungen haben. Wie berechnet man jetzt daraus den Gewinn, für eine Wette auf die 9?
</p>

Dafür benötigst du eine Art der `if`-Funktion. Diese Funktion ist auf Vektoren anwendbar und überführt die einzelnen Zufallsziehungen entweder in ein Ergebnis A (wenn deine Bedingung [9] zutrifft) oder in ein Ergebnis B (wenn du verlierst). Daraus entsteht also ein neuer Vektor der die Zufallsziehungen in Gewinn bzw. Verlust für diese Ziehung überführt. Daraus lässt sich dann durch einfache Addition der Gesamtgewinn berechnen. Wichtig: Die gesuchte Funktion lässt sich leicht im Internet finden. Geh dort auf die Suche!

</p>
</details>

## Tipp 2: Implementierung verschiedener Wettmöglichkeiten

<details> <summary> Tipp zur Überarbeitung der Gewinnberechnung </summary>
<p>

<p>
Mehrere Dinge müssen verändert werden, um weitere Wettmöglichkeiten in die Gewinnberechnung zu implizieren.
</p>

<p>
Zum einen muss man an die Bedingung verändern. `==` eignet sich nicht dafür, zu überprüfen, ob eine Zahl Element einer Zahlengruppe ist. Aus diesem Grund sollte man hierfür nun `is.element()` benutzen. Sofern nicht klar ist, was diese Funktion macht und wie sie aufgebaut ist, schaut euch die Funktion in der Hilfefunktion von R an. 
</p>

<p>
Zum anderen muss man beachten, dass es nun unterschiedliche Quoten für die verschiedenen Wetten gibt. Aus diesem Grund muss man nun eine weitere `if`-Funktion mit mehreren `elseif`-Fortsätzen einfügen, die für jede Wettmöglichkeit die Gewinnausschüttung angibt [z.B. `if (x == RED){y} elseif (x == firstThird){2y}` mit `x` = Wette und `y` = Einsatz]. Für das Beispiel heißt das: Wenn auf RED gewettet wurde, so liegt der Gewinn bei Eintreffen der Wette bei `y`, man erhält seinen Einsatz also doppelt zurück. 
</p>

Nicht vergessen: Die Zahlengruppen, wie z.B. ROT und SCHWARZ, müssen zuvor erstellt werden. Dafür erstellt man Objekte, die die jeweiligen Zahlen enthalten.

</p>
</details>

<details> <summary> Tipp zur Erstellung der neuen Schleife </summary>
<p>

Im letzten Schritt benutzt man eine `for`-Schleife. In diese setzt du die Zufallsziehung und die Gewinnberechnung ein, sodass in jedem Durchlauf direkt auch der Gewinn ausgegeben werden kann. Wichtig: Beide Variablen müssen in einem Objekt abgespeichert werden! Falls du nicht weißt, wie man das bei einer Schleife macht, schau dir das Beispiel in der [Übersicht](/post/uebersicht2/) an.

</p>
</details>

## Tipp 3: Spiele bis du X Euro gewonnen hast.

Alternativ kannst du dir einen der beiden Möglichkeiten anschauen. Falls du es mit der ersten Möglichkeit nicht klappt, schau dir die zweite Möglichkeit an. Diese gibt dir Hinweise zu den einzelnen Schritten bis zur Lösung des Problems.

<details> <summary> Möglichkeit 1: Übertragen von Modell </summary>
<p>
Falls du da noch nicht drauf gekommen bist, schau dir doch das Beispiel auf der [Übersichtsseite](/post/uebersicht2) von diesem Projekt an. Dort findest du eine Funktion nach dem gleichen Schema, wie es auch hier gefordert ist. Falls dir das nicht ausreicht, kannst du zusätzlich dazu auch noch Möglichkeit 2 nutzen.
</p>
</details>

<details> <summary> Möglichkeit 2: Schrittweise Anleitung </summary>
<p>

<p>
Zunächst einmal solltest du dich damit vertraut machen, welche neue Funktion man in dieser Aufgabe verwenden muss. Überlege dir, welche der Funktionen unter dem Reiter "Programmierung" hier Sinn ergeben würde. 
</p>

<p>
Schau dir zunächst einmal an, was du aus den vorherigen Abschnitten übernehmen kannst. Ändert sich etwas an der Zufallsziehung und der Gewinnberechnung? Was kommt neu hinzu?
</p>

<p>
In kurz: Zufallsziehung und Gewinnberechnung bleiben gleich; können also 1:1 übernommen werden. Neu sind die Bedingung mit dem Gesamtgewinn, das Updaten des Gesamtgewinns und das Zählen der Durchgänge.
</p>

<p>
Beginnen wir bei der Bedingung: Die Bedingung sollte den Befehl geben, dass die Schleife so lange wiederholt wird, bis der Gesamtgewinn nicht mehr kleiner als der gewünschte Gesamtgewinn ist. 
</p>

<p>
Die Berechnung des Gesamtgewinns erfordert eine neue "Technik", da dieser jeden Durchgang aktualisiert werden muss. Dazu muss vor der Durchführung der Funktion ein `Gesamtgewinn`-Objekt mit dem Wert 0 erstellt werden. Jede Runde soll dieser Gesamtgewinn dann erneuert werden, indem man den alten Gesamtgewinn und den Gewinn der aktuellen Runde addiert.
Achtung: Diese Berechnung muss nach der Berechnung des aktuellen Gewinns geschehen, ansonsten rechnet man mit dem Gewinn aus der vorherigen Runde.
</p>

<p>
Der letzte Schritt sollte sein, die Durchgänge zu zählen. Das beruht auf der gleichen Methode, wie die Berechnung des Gesamtgewinns.
</p>

</p>
</details>

## Tipp 4: Funktionen

In diesem Abschnitt beschäftigen wir uns mit dem Erstellen von eigenen Funktionen und erstellen eine authentische Ausgabe bezogen auf Roulette. Da die Problemstellung in zwei Teile geteilt ist und man zwei Funktionen erstellen soll, teilen wir auch die Tipps in zwei Teile.

<details> <summary> Teil 1 </summary>
<p>

<p>
Als allererstes solltest du dir diesen [Link](https://de.wikibooks.org/wiki/GNU_R:_Eigene_Funktionen_programmieren) zu der `function`-Funktion in R durchlesen. Hierin wird erklärt, wie diese Funktion in R funktioniert. Sofern du das schon verstanden hast, kannst du bereits mit dem Erstellen der Funktion beginnen.
</p>

<p>
Ein wichtiger Bestandteil der Funktion sind die Parameter in der normalen Klammer. Hier stellt sich die Frage: Wie viele "Unbekannte" wird meine Funktion haben? Welche Information braucht meine Funktion? - In unserem Fall handelt es sich nur um zwei Unbekannte, die man als Spieler im vorhinein angeben muss:

- 1. Der Einsatz: Wie viel will ich setzen?
- 2. Die Wette: Auf was will ich setzen?

Diese zwei Variablen müssen also in der normalen Klammer benannt werden (dafür kannst du jegliche sich unterscheidende Buchstaben verwenden).
</p>

<p>
Jetzt kannst du mit dem Schreiben mit der Funktion beginnen. Dafür kannst du einige Operationen aus den vorherigen Aufgaben übernehmen. Beachte dabei nur, die Variablen aus der normalen Klammer bei den Operationen an der richtigen Stelle einzusetzen.
</p>

<p>
Das Grundgerüst für Roulette sollte nun stehen, nur gibt die Funktion nun noch nichts aus. Dafür können wir den `message`-Befehl benutzen. Dieser ermöglicht es uns auch Variablen in den Text einzufügen. Hier ein Beispiel:

```{r}
Wuerfeln1 <- function (){
  message ("Bitte jetzt wuerfeln!")
  Augenzahl <- sample (1:6, 1)
  message ("Du hast eine ", Augenzahl, " geworfen!")}
Wuerfeln1 ()
```

Nutze das für deine Nachricht(en) aus!
</p>

Um das Ganze noch authentischer zu gestalten, kannst du jetzt Pausen für die Ausgabe einbauen. Dafür benutzt man den `Sys.sleep`-Befehl, der in Klammern die Pausenzeit in Sekunden enthält. So kann beim Würfeln zum Beispiel die Zeit zum Fallen des Würfels simulieren:

```{r}
Wuerfeln2 <- function (){
  message ("Bitte jetzt wuerfeln!")
  Augenzahl <- sample (1:6, 1)
  Sys.sleep (3.0)
  message ("Du hast eine ", Augenzahl, " geworfen!")}
Wuerfeln2 ()
```

</p>
</details>

<details> <summary> Teil 2 </summary>
<p>

<p>
Diese Funktion gestaltet sich etwas komplexer als die vorherige Funktion. Hier werden wir mit dem `repeat`-Befehl und `if (condition) break` arbeiten. Schau dir die Funktionsweise davon im Internet oder in den vorgeschlagenen Websiten auf der [Übersichtsseite dieses Projekts](/post/uebersicht2) an. An sich funktioniert dieser Befehl genauso wie eine `for`- oder `while`-Schleife, nur dass wir die Schleife hier erst dann stoppen wollen, wenn ein explizites Ereignis eintritt.
</p>

<p>
Wie bereits in allen anderen Aufgaben solltest du auch hier auf den bereits vorhandenen Operationen aufbauen. Für diese Funktion eignet sich logischerweise die Funktion aus Teil 1 dieses Abschnitts. Es kommt nur eine weitere Variable - neben Einsatz und Wette - hinzu: die Rundenzahl. Das ist die erste Ergänzung die du vornehmen kannst: Erstelle eine neue Rundenvariable in der normalen Klammer. (Außerdem solltest du dieser Funktion einen neuen Namen geben, um die erste Funktion beizubehalten.)
</p>

<p>
Hier soll es nun darum gehen, wie wir die neue Rundenvariable (die durch den Spieler angegeben wird) mit der gerade gespielten Runde abgleichen können, sodass die Schleife dann endet. Dafür muss nach bereits angewendetem Prinzip eine weitere Variable erstellt werden, die die aktuelle Runde zählt (also jede Runde +1). Diese muss dann ganz am Ende der `repeat`-Schleife mit der durch den Spieler angegebenen Rundenzahl abgeglichen werden. Wenn beide Variablen den gleichen Wert haben, dann soll die Schleife abgebrochen werden.
</p>

<p>
Das Rundenproblem sollte damit gelöst sein. Hinzu kommt jedoch noch der Gesamtgewinn. Dieser wird bis jetzt nicht ermittelt (nur der Gewinn jede Runde für sich wird immer wieder ermittelt und überschrieben). Natürlich kann der Gewinn jeder Runde in einer Nachricht ausgegeben werden, dadurch erhält man jedoch keinen Gesamtgewinn. Dieser sollte auch nach bereits bekanntem und angewendetem Schema ermittelt werden: Variable mit Wert 0 <b> vor </b> der `repeat`-Schleife erstellen; dann jede Runde updaten.
</p>

<p>
Der letzte Schritt sind Nachrichten und Pausen. Hier kann man kreativ werden; auf jeden Fall kann man die Nachrichten aus der Funktion in Teil 1 übernehmen. Diese werden ründlich ausgegeben. Außerdem sollte man (auch ründlich) den Gesamtgewinn durchgeben. Neben diesen Nachrichten sollten auch bei Beenden der Schleife noch Nachrichten folgen, die das Spiel zusammenfassen. Hierbei kann man auch verschiedene "Pfade" erstellen, je nach Gesamtgewinn.
</p>

<p>
Zu bedenken ist dabei, in welcher Reihenfolge die Funktion die Informationen für die Nachrichten berechnet, sodass jede Runde die aktuellen Daten ausgegeben werden und nicht die Daten der vorherigen Runde. --> Schreibe die ründlichen Nachrichten an das Ende der `repeat`-Funktion (direkt über `if (cond) break`). Die anderen Nachrichten schreibst du an das Ende der gesamten Funktion. So gehst du in jedem Fall auf Nummer sicher.
</p>

</p>
</details>

### [Weiter zu den Lösungen](/post/loesungen2/)
