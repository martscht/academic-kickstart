install.packages(c("osmdata", "sf"))
install.packages('units')
install.packages('units')
install.packages(c("osmdata", "sf"))
install.packages(c("osmdata", "sf"))
blogdown:::serve_site()
ui <- fluidPage(
titlePanel(title = em(strong('Beispiel für die Übersicht in Projekt 7'))),
hr(),
plotOutput('Histogramm'),
hr(),
wellPanel(
sliderInput(inputId = 'Stichprobengroesse',
label = 'Stichprobengröße',
value = 1000, min = 100, max = 10000, step = 100),
sliderInput(inputId = 'Breaks',
label = 'Balken im Histogramm',
value = 10, min = 2, max = 100),
fluidRow(
column(6, numericInput(inputId = 'Mittelwert',
label = 'Mittelwert',
value = 100, min = -1000, max = 1000)),
column(6, selectInput(inputId = 'Mass',
label = 'Maß der zentralen Tendenz für die Stichprobe',
choices = c('Kein Maß', 'Median', 'Mittelwert')))
),
fluidRow(
column(6, numericInput(inputId = 'Standardabweichung',
label = 'Standardabweichung',
value = 15, min = 0, max = 1000)),
column(3, radioButtons(inputId = 'Normalverteilung',
label = 'Normalverteilungskurve einzeichnen',
inline = TRUE,
choices = c('Ja', 'Nein'),
selected = 'Nein')),
column(3,
br(),
actionButton(inputId = 'Update',
label = 'Histogramm aktualisieren'))
)
),
hr()
)
library(shiny)
ui <- fluidPage(
titlePanel(title = em(strong('Beispiel für die Übersicht in Projekt 7'))),
hr(),
plotOutput('Histogramm'),
hr(),
wellPanel(
sliderInput(inputId = 'Stichprobengroesse',
label = 'Stichprobengröße',
value = 1000, min = 100, max = 10000, step = 100),
sliderInput(inputId = 'Breaks',
label = 'Balken im Histogramm',
value = 10, min = 2, max = 100),
fluidRow(
column(6, numericInput(inputId = 'Mittelwert',
label = 'Mittelwert',
value = 100, min = -1000, max = 1000)),
column(6, selectInput(inputId = 'Mass',
label = 'Maß der zentralen Tendenz für die Stichprobe',
choices = c('Kein Maß', 'Median', 'Mittelwert')))
),
fluidRow(
column(6, numericInput(inputId = 'Standardabweichung',
label = 'Standardabweichung',
value = 15, min = 0, max = 1000)),
column(3, radioButtons(inputId = 'Normalverteilung',
label = 'Normalverteilungskurve einzeichnen',
inline = TRUE,
choices = c('Ja', 'Nein'),
selected = 'Nein')),
column(3,
br(),
actionButton(inputId = 'Update',
label = 'Histogramm aktualisieren'))
)
),
hr()
)
server <- function(input, output, session) {
}
shinyApp(ui, server)
#### UI Side ####
ui <- fluidPage(
titlePanel(title = em(strong('Beispiel für die Übersicht in Projekt 7'))),
hr(),
plotOutput('Histogramm'),
hr(),
wellPanel(
sliderInput(inputId = 'Stichprobengroesse',
label = 'Stichprobengröße',
value = 1000, min = 100, max = 10000, step = 100),
sliderInput(inputId = 'Breaks',
label = 'Balken im Histogramm',
value = 10, min = 2, max = 100),
fluidRow(
column(6, numericInput(inputId = 'Mittelwert',
label = 'Mittelwert',
value = 100, min = -1000, max = 1000)),
column(6, selectInput(inputId = 'Mass',
label = 'Maß der zentralen Tendenz für die Stichprobe',
choices = c('Kein Maß', 'Median', 'Mittelwert')))
),
fluidRow(
column(6, numericInput(inputId = 'Standardabweichung',
label = 'Standardabweichung',
value = 15, min = 0, max = 1000)),
column(3, radioButtons(inputId = 'Normalverteilung',
label = 'Normalverteilungskurve einzeichnen',
inline = TRUE,
choices = c('Ja', 'Nein'),
selected = 'Nein')),
column(3,
br(),
actionButton(inputId = 'Update',
label = 'Histogramm aktualisieren'))
)
),
hr()
)
#### Server Side ####
server <- function(input, output, session) {
rv <- reactiveValues(data = rnorm(1000, mean = 100, sd = 15))
observeEvent(input$Update, {
rv$data <- rnorm(input$Stichprobengroesse,
mean = input$Mittelwert,
sd = input$Standardabweichung)
})
output$Histogramm <- renderPlot({
zentraleTendenz <- input$Mass
Normalverteilungskurve <- input$Normalverteilung
hist(rv$data, breaks = input$Breaks, freq = FALSE)
if(Normalverteilungskurve == 'Ja'){
curve(
dnorm(x,
mean = isolate(input$Mittelwert),
sd = isolate(input$Standardabweichung)),
add = TRUE, lwd = 3)
}
if(zentraleTendenz == 'Median'){
abline(v = median(rv$data), lwd = 1, col = 'orange')
} else if (zentraleTendenz == 'Mittelwert'){
abline(v = mean(rv$data), lwd = 1, col = 'red')
} else {}
})
}
shinyApp(ui, server)
install.packages("plot.matrix")
runApp('~/projekte/raw/Test 1.R')
blogdown:::serve_site()
X <- rnorm(1000, 0, 1)
Y  <- 0.5*X + rnorm(1000,0,1)
par(mfrow=c(1,1),cex.axis = 1.1, cex.lab= 2, cex.main = 2.5, mar = c(5, 5, 2, 1),
bty="n",bg="grey95", mgp=c(2, 0.8, 0))
plot(X,Y, pch = 19, cex = 1.5,  main ="No Missings")
X <- runif(300)
y <- 3*X + rnorm(300, sd  = 0.5)
reg3 <- lm(y~X)
windows(width = 10, 8 )
par(mfrow=c(1,1),cex.axis = 1.1, cex.lab= 2, cex.main = 2.5, mar = c(5, 5, 2, 1),
bty="n",bg="grey95", mgp=c(2, 0.8, 0))
plot(reg3$fitted.values, reg3$residuals, main = "Residualplot",
xlab = expression("Vorhergesagte Y-Werte ["~hat(Y)~"]"), ylab = "Residuen [r]", pch = 16,
col = "red", cex = 2, xaxt = "n", yaxt = "n", ylim = c(-2,2)); abline(h = 0, lwd = 2)
par(mfrow=c(2,2),cex.axis = 1.1, cex.lab= 1.2, cex.main = 1.3, mar = c(5, 5, 2, 1),
bty="n",bg="grey95", mgp=c(2, 0.8, 0))
library(car)
X <- sort(rnorm(25))
y <- X + rnorm(25, sd = 0.3)
reg <- lm(y~X)
X_ <- c(X, 0)
y_ <- c(y, 0 + 0 + rnorm(1, sd = 0.3))
reg1 <- lm(y_ ~ X_)
plot(X_,y_, pch = 16, main = "kleine CD, kleiner Hebelwert", xlab = "X", ylab = "Y", xlim = c(-2,4), ylim = c(-2, 4))
abline(reg = reg, lwd = 3)
abline(reg = reg1, lwd = 5, col = "blue")
legend(x="topleft", legend = c("normal", "outlier"), col = c("black", "darkblue"), pch = 16, cex = 1.1, box.col = "grey")
points(X_[length(X)+1], y_[length(X)+1], pch = 15, cex = 2.8, col = "gold")
points(X_[length(X)+1], y_[length(X)+1], pch = 16, cex = 2, col = "darkblue")
X_ <- c(X, 4)
y_ <- c(y, 3.7 + rnorm(1, sd = 0.3))
reg1 <- lm(y_ ~ X_)
plot(X_,y_, pch = 16, main = "Kleine CD, großer Hebelwert", xlab = "X", ylab = "Y", xlim = c(-2,4), ylim = c(-2, 4))
abline(reg = reg, lwd = 3)
abline(reg = reg1, lwd = 5, col = "blue")
points(X_[length(X)+1], y_[length(X)+1], pch = 15, cex = 2.8, col = "gold")
points(X_[length(X)+1], y_[length(X)+1], pch = 16, cex = 2, col = "darkblue")
legend(x="topleft", legend = c("normal", "outlier"), col = c("black", "darkblue"), pch = 16, cex = 1.1, box.col = "grey")
X_ <- c(X, 0)
y_ <- c(y, 0 + 3.7 + rnorm(1, sd = 0.3))
reg1 <- lm(y_ ~ X_)
plot(X_,y_, pch = 16, main = "große CD, kleiner Hebelwert", xlab = "X", ylab = "Y", xlim = c(-2,4), ylim = c(-2, 4))
abline(reg = reg, lwd = 3)
abline(reg = reg1, lwd = 5, col = "blue")
legend(x="topleft", legend = c("normal", "outlier"), col = c("black", "darkblue"), pch = 16, cex = 1.1, box.col = "grey")
points(X_[length(X)+1], y_[length(X)+1], pch = 15, cex = 2.8, col = "gold")
points(X_[length(X)+1], y_[length(X)+1], pch = 16, cex = 2, col = "darkblue")
X_ <- c(X, 4)
y_ <- c(y, 0  + rnorm(1, sd = 0.3))
reg1 <- lm(y_ ~ X_)
plot(X_,y_, pch = 16, main = "große CD, großer Hebelwert", xlab = "X", ylab = "Y", xlim = c(-2,4), ylim = c(-2, 4))
abline(reg = reg, lwd = 3)
abline(reg = reg1, lwd = 5, col = "blue")
legend(x="topleft", legend = c("normal", "outlier"), col = c("black", "darkblue"), pch = 16, cex = 1.1, box.col = "grey")
points(X_[length(X)+1], y_[length(X)+1], pch = 15, cex = 2.8, col = "gold")
points(X_[length(X)+1], y_[length(X)+1], pch = 16, cex = 2, col = "darkblue")
par(mfrow=c(1,1),cex.axis = 1, cex.lab= 1.3, cex.main = 1.5, mar = c(4, 5, 5, 1),bty="n",bg="grey95", mgp=c(2, 0.8, 0))
mu1 <- c(0,0)
mu2 <- c(1,0)
S1 <- matrix(c(1,1,1,4),2,2)
#S2 <- matrix(c(4,0,0,1),2,2)
plot(0, col = "white", xlim = c(-3,3.5),ylim = c(-6,6), xlab = "Variable 1", ylab = "Variable 2",
main = "Kurven gleicher Wahrscheinlichkeit/ Kurven gleicher Mahalanobisdistanz")
points(mu1[1],mu1[2],pch=19,col="green", cex = 3)
#points(mu2[1],mu2[2],pch=19, col = "blue", cex = 3)
# plotte einzelne Kovarianzmatrizen
color <- c("yellow","gold3", "gold3", "red")
i <- 1
for (q in c(0.5, 0.8,0.95,.99))
{
lines(ellipse(S1,level=q)[,1]+mu1[1],ellipse(S1,level=q)[,2]+mu1[2], col = color[i], lwd = 4)
#lines(ellipse(S2,level=q)[,1]+mu2[1],ellipse(S2,level=q)[,2]+mu2[2],col= color [i], lwd = 4)
i <- i +1
}
X <- ellipse(S1,level=0.8)[,1]+mu1[1]
Y <- ellipse(S1,level=0.8)[,2]+mu1[2]
###############################################################
###################
###
### Mahalanobis-Distanz
###
library(ellipse)
par(mfrow=c(1,1),cex.axis = 1, cex.lab= 1.3, cex.main = 1.5, mar = c(4, 5, 5, 1),bty="n",bg="grey95", mgp=c(2, 0.8, 0))
mu1 <- c(0,0)
mu2 <- c(1,0)
S1 <- matrix(c(1,1,1,4),2,2)
#S2 <- matrix(c(4,0,0,1),2,2)
plot(0, col = "white", xlim = c(-3,3.5),ylim = c(-6,6), xlab = "Variable 1", ylab = "Variable 2",
main = "Kurven gleicher Wahrscheinlichkeit/ Kurven gleicher Mahalanobisdistanz")
points(mu1[1],mu1[2],pch=19,col="green", cex = 3)
#points(mu2[1],mu2[2],pch=19, col = "blue", cex = 3)
# plotte einzelne Kovarianzmatrizen
color <- c("yellow","gold3", "gold3", "red")
i <- 1
for (q in c(0.5, 0.8,0.95,.99))
{
lines(ellipse(S1,level=q)[,1]+mu1[1],ellipse(S1,level=q)[,2]+mu1[2], col = color[i], lwd = 4)
#lines(ellipse(S2,level=q)[,1]+mu2[1],ellipse(S2,level=q)[,2]+mu2[2],col= color [i], lwd = 4)
i <- i +1
}
X <- ellipse(S1,level=0.8)[,1]+mu1[1]
Y <- ellipse(S1,level=0.8)[,2]+mu1[2]
i <- 25
lines(c(X[i], 0), c(Y[i], 0), lwd = 3, col = "blue")
points(X[i],Y[i], cex = 2, pch = 16)
l <- sqrt(X[i]^2 + Y[i]^2)
i <- 1
l2 <-  sqrt(X[i]^2 + Y[i]^2)
lines(c(0, X[i]), c(0, Y[i]), lwd = 3)
arrows(x0=0,x1= X[i]*l/l2, y0=0,y1= Y[i]*l/l2, lwd = 3, col = "blue", code = 3, angle = 90, length = 0.1)
points(X[i],Y[i], cex = 2, pch = 16)
points(mu1[1],mu1[2],pch=19,col="green", cex = 3)
