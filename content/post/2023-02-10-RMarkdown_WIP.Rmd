---
title: "RMarkdown"
date: '2023-02-10'
slug: RMarkdown
categories:
  - extras
tags:
subtitle: ''
summary: ''
authors: [pommeranz]
lastmod: '`r Sys.Date()`'
featured: no
header:
  image: "/header/" #https://pxhere.com/de/photo/29 maybe this?
  caption: "[Courtesy of pxhere](https://pxhere.com/de/photo/29)"
projects: []
---

```{r knitr options, echo=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, eval = FALSE)
```

```{r include = FALSE, eval=TRUE}

numberFunc <- sample(1:20, 2, replace = T)
```

`r blogdown::shortcode_open("detail_disclosure", "Kernfragen dieses Beitrags")`
<!-- Die divs sind wichtig, damit die Liste funktioniert! Innerhalb dieses Shortcodes ist HTML erlaubt (safeHTML) -->
<div>
* Was ist [**RMarkdown**](#RMarkdown)?
* Wie [**erstelle**](#Erstellen) ich eine RMarkdown-Datei?
* Wie hängen [**RMarkdown und Pandoc**](#Zusammenspiel) zusammen?
* Wie ist eine Rmd [**aufgebaut**](#Aufbau)?
* Was kann ein [**Code Chunk**](#Codechunk) besonders in RMarkdown?
* Was macht den [**Setup-Chunk**](#Setup) besonders im Vergleich zu anderen Code Chunks?
* Wie ist das [**Working Directory**](#WD) bei RMarkdown aufgebaut?
* Wie kann ich meinen Code direkt [**in meinen Text einbinden**](#Inline)?
</div>

`r blogdown::shortcode_close("detail_disclosure")`

***

## Was ist RMarkdown? {#RMarkdown .anchorheader}

RMarkdown ist ein Framework, welches es ermöglicht, die Arbeit mit Daten in der Programmiersprache R möglichst transparent darzustellen und in einem Dokument aufzubereiten.Der Nutzen dahinter liegt unter anderem in gut einsehbarer und reproduzierbarer Forschung, da man damit seinen Workflow erweitert erläutern und visualisieren kann. Mit hinterlegtem Quellcode können auch mögliche Fehler in der Datenaufbereitung und -verarbeitung transparent von außen einsehbar werden.


## RMarkdown-Datei erstellen {#Erstellen .anchorheader}

Um eine RMarkdown-Datei zu erstellen, muss man in RStudio oben links eine neue Datei erstellen, und dort RMarkdown auswählen. Nun sollte sich ein Fenster öffnen in dem man einige Angaben treffen kann. Die ersten drei Parameter sind dabei relativ selbsterklärend, der Titel des Markdown-Dokuments, das Datum der Erstellung sowie der Name der/des Autor*in des Dokuments. Das Output-Format hingegen bestimmt, in welcher Form das Dokument ausgegeben werden soll, PDF, Word oder Html. Diese Parameter lassen sich später aber noch anpassen.

<!--- Bild hier einfügen? -->

[]: # (Bild hier einfügen?)

Im Anschluss wird für das Beispiel alles vorgenerierte aus dem RMD gelöscht und der Inhalt unseres alten MDs eingesetzt.

## RMarkdown und Pandoc {#Zusammenspiel .anchorheader}

Die RMarkdown-Datei wird mit dem Knit-Button, welcher in der Leiste unterhalb des Dateifensters ist, zu einem Dokument nach vordefiniertem Format kompiliert. Dabei wird zuerst der R-Code ausgeführt und dann in ein normales Markdown-Dokument kompiliert, dies ist die Funktion von "knitr". Im Anschluss wird das Markdown-Dokument mit Pandoc zu einem fertigen Dokument im gewünschten Format kompiliert. Innerhalb dieses Ablaufs wird aus dem Rmd bspw. eine Homepage oder ein PDF.

<!--- Bild hier einfügen? -->

[]: # (Bild hier einfügen?)

## Working Directory {#WD .anchorheader}

Das Working Directory funktioniert identisch zum Markdown zuvor, oder auch wie R-Skripte. Mit einem Setup-Befehl lässt sich dieser auch anpassen, dieser sieht etwas komplexer aus, als man es von `setwd()` vielleicht gewohnt ist, erfüllt aber die selbe Funktion. 

```
knitr::opts_knit$set(root.dir = '/Ordner')
```

## Aufbau des Dokuments {#Aufbau .anchorheader}

Eine RMarkdown-Datei enthält typischerweise einen **Head** und einen **Textkörper**, sowie **Code-Chunks/Code-Blöcke**.

Im Head des Dokuments befinden sich die Argumente die beim Erstellen übergeben wurden. Es gibt viele weitere Output-Möglichkeiten wie beispielsweise Powerpoint-Slides. Auf der [Seite von RStudio](https://rmarkdown.rstudio.com/lesson-9.html) gibt es eine Liste weiterer Optionen.

Im eigentlichen Textkörper steht einfacher Text, wie er auch hier steht. Manchmal sind im Text [Links]() gesetzt, oder auch *schiefgestellter* oder **fettgedruckter** Text, dies wird auch mit Markdown-Syntax umgesetzt.

Die Code Chunks sind das, was ein RMarkdown von einem "normalen" Markdown-Dokument unterscheidet. Mit ihnen lässt sich R-Code in ein Dokument einbauen und ausführen, womit man unter anderem Grafiken und Ergebnisse automatisch berechnen und darstellen lassen kann.

Wie diese Bestandteile im Detail funktionieren und sich auf unseren Bericht anwenden lassen, wird im folgenden schrittweise aufgeklärt.

## Code Chunks {#Codechunk .anchorheader}

Mit Code Chunks, welche zuvor im Markdown-Tutorial rein visuell verwendet wurden, lässt sich R-Code in ein Dokument einbauen um Ergebnisse, Analysen und Grafiken dynamisch in einen Fließtext zu integrieren. Erstellt werden diese mit einem Codeblock und einem Zusatzargument, der die Programmiersprache des Blocks definiert.
```
```{r }⠀
R-Code
```⠀
```
Hier ein Beispiel basierend auf dem Fragebogendatensatz fb22.

```{r , eval=TRUE}
#Fragebogendaten aus PsyBsc2 laden
load(url('https://pandar.netlify.app/post/fb22.rda'))

#prüfen, ob n >= 30
length(na.omit(fb22$nerd[fb22$job==2])) #Student*innen mit Nebenjob
length(na.omit(fb22$nerd[fb22$job==1])) #Student*innen ohne Nebenjob

```

Es gibt auch Parameter, die unter anderem die Darstellung des Codes und der Ergebnisse beeinflussen.
Man kann dabei mit `{r echo=c (-ErsteZeile:-LetzteZeile)}` einzelne Zeilen und Abschnitte des Codes verstecken, etwa wie im Folgenden eine logische Abfrage, die einen passenden Text für jedes Ergebnis eines leveneTests ausgibt.

```{r echo=c(-2,-4:-7), eval=TRUE}
#Prüfung der Homoskedastizität
library(car)
leveneTest(fb22$nerd[!is.na(fb22$nerd) & !is.na(fb22$job)] ~ as.factor(fb22$job[!is.na(fb22$nerd) & !is.na(fb22$job)]))

if (leveneTest(fb22$nerd[!is.na(fb22$nerd) & !is.na(fb22$job)] ~ as.factor(fb22$job[!is.na(fb22$nerd) & !is.na(fb22$job)]))[1,3] < 0.05){
  ausgabe <-("Die Homoskedastizitätsannahme wird verworfen, daher wird eine Welch-Korrektur genutzt. (Dieser Text wurde aus der logischen Abfrage erstellt)")
} else{
  ausgabe <- ("Die Homoskedastizität kann angenommen werden. (Dieser Text wurde aus der logischen Abfrage erstellt)")
}

```

`r ausgabe`

Und mit `{r results="hide"}` kann man verhindern, dass Ergebnisse, wie das vom leveneTest, überhaupt ausgegeben werden.

```{r results="hide", eval=TRUE}
leveneTest(fb22$nerd[!is.na(fb22$nerd) & !is.na(fb22$job)] ~ as.factor(fb22$job[!is.na(fb22$nerd) & !is.na(fb22$job)]))
```

Die Plotdarstellung kann ähnlich manipuliert und angepasst werden:

```{r fig.keep=c(2), fig.align='left', eval=TRUE}
#Erster QQ-Plot
qqnorm(scale(fb22$nerd[fb22$job==2]))
qqline(scale(fb22$nerd[fb22$job==2]))

#Zweiter QQ-Plot
qqnorm(scale(fb22$nerd[fb22$job==1]))
qqline(scale(fb22$nerd[fb22$job==1]))
```

Hier wurde im Codeblock `{r fig.keep=c(2), fig.align='left'}` festgelegt, deswegen wird nun im Text nur der erste QQ-Plot gezeigt und dieser linksbündig dargestellt, während der andere nicht dargestellt wird. Auch hier gibt es wieder eine Vielzahl an Optionen, mit denen man Plots verschieden individualisieren kann. PARAMETER VERLINKEN

Wir können nun die existierenden Codeblöcke mit Code Chunks austauschen, die direkt die korrekte Syntax zeigen. Mit der Option `tidy` können wir unseren Code auch zusätzlich automatisch formatieren lassen, damit dieser visuell ansprechend angeordnet ist mit gleichmäßigen Abständen und übersichtlicherer Gliederung. Weiterhin ersetzen wir unsere bisherigen per Bild eingebundenen Plots und lesen diese nun direkt über den R-Code ein. Ebenfalls werden die Chunks dabei etwas umformatiert um von ihrer Funktionalität direkt zu profitieren.

<!--- Version 1 hier einfügen? -->

[]: # (Bild hier einfügen?)

In dieser ersten Lösung steht der gesamte umformatierte Code mit allen Änderungen, die bisher durchgeführt wurden. Es empfiehlt trotzdem vorher selbst einmal die Code-Chunks auszuprobieren, vor allem da die nächsten Schritte unabhängig vom Aufbau des Berichts durchgeführt werden können.

`r blogdown::shortcode_open("detail_disclosure", "Zeig mir die Lösung an")`
<pre>
---
title: Minibericht
author: Kevin Pommeranz
abstract: Im folgenden Bericht werde ich eine lineare Regression und ihre Ergebnisse beispielhaft abbilden, um zu zeigen wie Markdown im wissenschaftlichen Austausch genutzt werden kann. Es ist kein formaler wissenschaftlicher Bericht, sondern nur zur Veranschaulichung!
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4

---


## RMarkdown Version 1

#### **Übersicht**

- [Datensatz](#Datensatz)
- [Deskriptivstatistik](#Deskriptivstatistik)
- [Durchführungsplan](#Durchführung)
- [Voraussetzungsprüfung](#Vorraussetzungsprüfung)
- [Ergebnis](#Ergebnis)

#### **Datensatz** {#Datensatz}
Der Datensatz kann mit folgendem Befehl geladen werden:
```{r}
load(url('https://pandar.netlify.app/post/fb22.rda')) 
```

#### **Deskriptiv** {#Deskriptivstatistik}

Von der Stichprobe dieses Fragebogen wurde nur die Geschlechterverteilung aufgenommen, welche folgendermaßen aussieht:

```{r}
fb22$geschl_faktor <- factor(fb22$geschl
                             ,levels = 1:3,
                             labels = c("weiblich"
                                        ,
                                        "männlich", "anderes"))
table(fb22$geschl_faktor)
```

#### **Was wurde durchgeführt?** {#Durchführung}

Es wurde eine <span style='color: red'>lineare Regression</span> durchgeführt, um zu sehen, ob innerhalb des Datenatz die Nerdigkeit einen linearen Zusammenhang mit der Neurotizität aufzeigt.

Als Hypothesen formuliert:

>
>Hypothesen
>
> #. H1: Das Regressionsgewicht $b_1$ des Prädiktors Nerdigkeit ist signifikant von Null verschieden ($b_1 \neq 0$). Der Zusammenhang von Nerdigkeit und Neurotizität ist statistisch bedeutsam. 
>
> #. H0: Das Regressionsgewicht $b_1$ des Prädiktors Nerdigkeit ist nicht signifikant von Null verschieden ($b_1 = 0$). Der Zusammenhang von Nerdigkeit und Neurotizität ist nicht statistisch bedeutsam. 
>
***

Der Code dazu sah folgenderweise aus:
```{r}
model <- lm(neuro ~ nerd, fb22)
```

#### **Vorraussetzungsprüfung** {#Vorraussetzungsprüfung}

Die Vorrausssetzungsprüfungen wurden graphisch durchgeführt.

```{r}
UV <- fb22$nerd
AV <- fb22$neuro

## Linearität
plot(UV, AV, xlab = "Nerdigkeit", ylab = "Neurozität", 
     main= "Zusammenhang zwischen Gewicht und Treibstoffeffizienz"
     , pch =19)
lines(loess.smooth(UV, AV), col = 'blue')

## Restliche Prüfungen
par(mfrow = c(2, 2)) #vier Abbildungen gleichzeitig
plot(model)

## Varianzhomogenität
#Siehe Plot

## Unabhängigkeit der Residuen
# Siehe plot


## Normalverteilung der Residuen
shapiro.test(model[["residuals"]]) #Zusatz da unklar durch graphische Prüfung
# + Normal Q-Q


```
Sie sind alle annehmbar, wobei die Normalverteilung noch zusätzlich mit einem shapiro Test (p = .0698) überprüft wurde, da der dargestellte QQ-Plot schon an der Grenze zu liegen scheint.

***



#### **Ergebnis** {#Ergebnis}

Das Ergebnis ist, dass unser Prädiktor nicht signifikant von Null verschieden ist (p-Wert von 0.3406 bei einem Alpha von .05). Die Alternativhypothese wird verworfen und die Nullhypothese bleibt erhalten.

***

Der Code dazu sah folgenderweise aus:
```{r}
summary(model)
p = 0.3406

if(p < 0.05){
  print("Die Nullhypothese wird verworfen")
}else{
  print("Die Nullhypothese bleibt erhalten.")
}
```

</pre>
`r blogdown::shortcode_close("detail_disclosure")`

## Der Sonderfall: Setup mit knitr {#Setup .anchorheader}

Der erste Code-Chunk in einem Dokument, der beim Erstellen eines neuen RMarkdown-Dokuments auch in RStudio miterstellt wird, ist typischerweise der Setup-Chunk. In ihm lassen sich durch Argumente verschiedene Regeln festlegen die im `default` auf jeden weiteren Code-Chunk zutreffen werden. Die [möglichen Befehle](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf?_ga=2.102259713.1013981012.1677056319-671987487.1666819594) innerhalb des Setup-Chunks sind weitreichend, meist wird dort aber nur definiert, ob man seinen Code und seine Ergebnisse standardmäßig anzeigen möchte und ob Warnungen oder Nachrichten angezeigt werden sollen. Letztere Optionen lauten beispielsweise:

```
knitr::opts_chunk$set(include= TRUE, echo = TRUE, message = TRUE, warning = TRUE)

```

Diese muss man aber nicht unbedingt selbst setzen, diese 4 Werte sind beispielsweise als `default = TRUE`, also standardmäßig auf `TRUE` gesetzt, und müssen daher eigentlich nur angepasst werden, wenn man sie spezifisch auf `FALSE` setzen will.

Man kann auch globale R-Optionen in diesem Chunk einstellen, wie bspw. `options(digits)` um die globale Anzahl an Nachkommastellen zu setzen

Diesen besonderen Chunk nutzen wir nun, um `tidy` global zu setzen, damit der Code endlich schön und einheitlich ist. Bisher waren absichtlich unschöne Darstellungen, wie `=` statt eine Zuweisungspfeil, oder schlecht indentierter Code, diese sollten nun mit tidy verschwinden. Wer dies selbst umsetzen möchte statt die Lösung zu betrachten sollte sich [Den entsprechenden Abschnitt im RMarkdown-Cookbok anschauen](https://bookdown.org/yihui/rmarkdown-cookbook/opts-tidy.html).

<!--- Version 2 hier einfügen? -->

[]: # (Bild hier einfügen?)

`r blogdown::shortcode_open("detail_disclosure", "Zeig mir die Lösung an")`
Der neue Setup-Chunk:
<pre>

```{r setup, echo=FALSE}⠀
knitr::opts_chunk$set(tidy = TRUE,tidy.opts = list(arrow=TRUE, indent=2, width.cutoff=50))
```⠀

</pre>
`r blogdown::shortcode_close("detail_disclosure")`

## Inline Code & Parameter {#Inline .anchorheader}

Genau so, wie man Abschnitte im Text visuell als Code herausstellen kann in RMarkdown, lässt sich auch R-Code im Text ausführen. In diesem Dokument wurden bspw. zu Beginn in einem nicht sichtbaren Codeblock zwei zufällige Zahlen zwischen 1 und 20 in einen Vektor gelegt.

Dieser Vektor lässt sich nun direkt darstellen mit ` r numberFunc ` , umschlossen von zwei Backticks ` `` `: `r numberFunc`.

Der Vektor der zwei Zahlen wird dabei direkt in einer Aufführung mit Kommas dargestellt. Die Zahlen werden immer neu randomisiert, wenn das Dokument bearbeitet und neu geladen wird.

Unsere Testergebnisse aus dem Bericht müssen nun nicht mehr per Hand eingegeben werden, sondern werden automatisch ausgefüllt. Dies ist nützlich, wenn man beispielsweise weitere Daten hat, die die Ergebnisse leicht verändern, da man dann die einzelnen Werte im Text nicht zwingend per Hand eintragen muss. Jedoch müssen wir die einzelnen Werte dafür auch noch zusätzlich im R-Code vor ihrem Auftauchen speichern, dies wird realisiert indem wir den Code zum speichern schreiben (in Zeile x bis y) und danach die Chunkoption `echo=-c(x:y)` einsetzen, womit der Code von Zeile x bis y im fertigen Dokument nicht angezeigt wird. Hier nun der finale Minibericht:

<!--- Version 3 hier einfügen? -->

[]: # (Bild hier einfügen?)

`r blogdown::shortcode_open("detail_disclosure", "Zeig mir die Lösung an")`
Nach Vorrausetzungsprüfung wird ein neuer Block eingesetzt um die Werte zu speichern, bevor sie im Text danach erwähnt werden
<pre>

```{r echo=FALSE}⠀
p = 0.3406
p_shap = 0.0698
```⠀

Sie sind alle annehmbar, wobei die Normalverteilung noch zusätzlich mit einem shapiro Test (p = ```r
p_shap```) überprüft wurde, da der dargestellte QQ-Plot schon an der Grenze zu liegen scheint.

***

#### **Ergebnis** {#Ergebnis}

Das Ergebnis ist, dass unser Prädiktor nicht signifikant von Null verschieden ist (p-Wert von "r p" bei einem Alpha von .05). Die Alternativhypothese wird verworfen und die Nullhypothese bleibt erhalten.

***

Der Code dazu sah folgenderweise aus:
```{r}
summary(model)
p = 0.3406

if(p < 0.05){
  print("Die Nullhypothese wird verworfen")
}else{
  print("Die Nullhypothese bleibt erhalten.")
}
```
</pre>
`r blogdown::shortcode_close("detail_disclosure")`

## Fazit

RMarkdown kombiniert alle Facetten von Markdown, Pandoc und RMarkdown und kann so genutzt werden um R-Code und andere Inhalte dynamisch in einer Reihe verschiedener Formate auszugeben und darzustellen. Es kann ein mächtiges Werkzeug sein, wenn man einen Sachverhalt in R schriftlich erklären möchte, und auch um replizierbare, zugängliche wissenschaftliche Arbeit zu betreiben.


***
