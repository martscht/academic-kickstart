---
title: "RMarkdown"
date: '2022-12-06'
slug: RMarkdown
categories:
  - extras
tags:
subtitle: ''
summary: ''
authors: [pommeranz]
lastmod: '2022-11-19T10:00:00+01:00'
featured: no
header:
  image: "/header/" #https://pxhere.com/de/photo/29 maybe this?
  caption: "[Courtesy of pxhere](https://pxhere.com/de/photo/29)"
projects: []
---

```{r knitr options, echo=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

```{r include = FALSE}

numberFunc <- sample(1:20, 2, replace = T)
```
## RMarkdown-Datei erstellen
Um eine RMarkdown-Datei zu erstellen, muss man in RStudio oben links eine neue Datei erstellen, und dort RMarkdown auswählen. Nun sollte sich ein Fenster öffnen in dem man einige Angaben treffen kann. Die ersten drei Parameter sind dabei relativ selbsterklärend, der Titel des Markdown-Dokuments, das Datum der Erstellung sowie der Name der/des Autor*in des Dokuments. Das Output-Format hingegen bestimmt, in welcher Form das Dokument ausgegeben werden soll, PDF, Word oder Html. Dies lässt sich später aber noch anpassen.

<!-- Hier Bild einfügen -->



## Aufbau des Dokuments
Eine RMarkdown-Datei enthält typischerweise einen head und einen Textkörper, sowie Code-Chunks.

Im Head des Dokuments befinden sich die Argumente die beim Erstellen übergeben wurden. Es gibt viele weitere Output-Möglichkeiten wie beispielsweise Powerpoint-Slides. Auf der [Seite von RStudio](https://rmarkdown.rstudio.com/lesson-9.html) gibt es eine Liste weiterer Optionen.

Im eigentlichen Textkörper steht einfacher Text, wie er auch hier steht. Manchmal sind im Text [Links]() gesetzt, oder auch *schiefgestellter* oder **fettgedruckter** Text, dies wird auch mit Markdown-Syntax umgesetzt.

Die Code Chunks sind das, was ein RMarkdown von einem "normalen" Markdown-Dokument unterscheidet. Mit ihnen lässt sich R-Code in ein Dokument einbauen und ausführen, womit man unter anderem Grafiken und Ergebnisse automatisch berechnen und darstellen lassen kann.

Wie diese Bestandteile im Detail funktionieren, wird im folgenden schrittweise aufgeklärt.


## Markdown Syntax
RMarkdown verwendet eine Syntax, die auf [Pandoc Markdown](https://pandoc.org/MANUAL.html#pandocs-markdown) basiert. Pandocs Markdown ist dabei ein Vermittler, der zwischen verschiedenen Markdownformaten übersetzen kann, wenn zwischen diesen minimale Unterschiede bestehen. Markdown ist im allgemeineren eine Auszeichnungssprache, die in fast jeder textbasierten Anwendung in relativ normierter Form vorkommt, um spezifische Textdarstellungen und Inhalte in Texten zu ermöglichen. 

Ein Beispiel dafür ist die *Inline Formatierung*. Mit ihr kann man beispielsweise mit  `**Text**`  **Text fett schreiben** oder auch per  `~~Text~~`  ~~Text durchstreichen~~. Dies kann man meist in vergleichbarer Form auch in einem Messenger der Wahl replizieren, in WhatsApp etwa lässt sich Text mit `~Text~` streichen!

Auch *Blockelemente* lassen sich in Markdown erstellen, womit man beispielsweise Codeblocks teilen kann, dazu ein Beispiel aus dem PsyBsc2-Kurs:

```
#### Was bisher geschah: ----

# Daten laden
load(url('https://pandar.netlify.app/post/fb22.rda'))  


```

Dies geht mit drei Backticks ` ``` ` die jeweils über und unter dem Codeabschnitt stehen

Zuletzt lassen sich mit Markdown auch mathematische Ausdrücke formulieren und Matrizen darstellen.

Beispielsweise  werden 
```
$$f(k) = {n \choose k} p^{k} (1-p)^{n-k}$$
```
und
```
$$\begin{array}{ccc}
x_{11} & x_{12} & x_{13}\\
x_{21} & x_{22} & x_{23}
\end{array}$$
```
durch RMarkdown zu

$$f(k) = {n \choose k} p^{k} (1-p)^{n-k}$$

und

$$\begin{array}{ccc}
x_{11} & x_{12} & x_{13}\\
x_{21} & x_{22} & x_{23}
\end{array}$$

## Code Chunks
Mit Code Chunks lässt sich, wie bereits erwähnt, R-Code in ein Dokument einbauen um Ergebnisse, Analysen und Grafiken in einen Fließtext dynamisch zu integrieren. Hier ein Beispiel basierend auf dem Fragebogendatensatz fb22, bei dem wir hier exemplatorisch ein paar Vorraussetzungsprüfung testen zwischen Student\*innen mit und Student\*innen ohne Nebenjob im Bezug auf ihre Nerdiness.

```{r echo=c(-17:-22)}
#Fragebogendaten aus PsyBsc2 laden
load(url('https://pandar.netlify.app/post/fb22.rda'))

#prüfen, ob n >= 30
length(na.omit(fb22$nerd[fb22$job==2])) #Student*innen mit Nebenjob
length(na.omit(fb22$nerd[fb22$job==1])) #Student*innen ohne Nebenjob

#Zusätzliche Prüfung der NV
qqnorm(scale(fb22$nerd[fb22$job==2]))
qqline(scale(fb22$nerd[fb22$job==2]))

qqnorm(scale(fb22$nerd[fb22$job==1]))
qqline(scale(fb22$nerd[fb22$job==1]))


#Prüfung der Homoskedastizität
library(car)
leveneTest(fb22$nerd[!is.na(fb22$nerd) & !is.na(fb22$job)] ~ as.factor(fb22$job[!is.na(fb22$nerd) & !is.na(fb22$job)]))

if (leveneTest(fb22$nerd[!is.na(fb22$nerd) & !is.na(fb22$job)] ~ as.factor(fb22$job[!is.na(fb22$nerd) & !is.na(fb22$job)]))[1,3] < 0.05){
  ausgabe <-("Die Homoskedastizitätsannahme wird verworfen, daher wird eine Welch-Korrektur genutzt.")
} else{
  ausgabe <- ("Die Homoskedastizität kann angenommen werden.")
}


```

`r ausgabe`

Man kann dabei, wie es einigen Lesern vielleicht schon aufgefallen ist, sogar einzelne Abschnitte des Codes verstecken, etwa eigene Kommentare oder wie hier, die logische Abfrage des p-Wert des leveneTest und den Test selbst, um direkt eine Antwort mit `print()` zu schreiben!

Die Plotdarstellung kann ähnlich manipuliert und auch anderweitig im Text angepasst werden:

```{r fig.keep=c(2), fig.align='left'}
#Erster QQ-Plot
qqnorm(scale(fb22$nerd[fb22$job==2]))
qqline(scale(fb22$nerd[fb22$job==2]))

#Zweiter QQ-Plot
qqnorm(scale(fb22$nerd[fb22$job==1]))
qqline(scale(fb22$nerd[fb22$job==1]))
```

Hier wurde im Codeblock `{r fig.keep=c(2), fig.align='left'}` festgelegt, deswegen wird nun im Text nur der erste QQ-Plot mit Linie gezeigt und dieser linksbündig dargestellt. Auch hier gibt es wieder eine Vielzahl an Optionen, mit denen man den Codeblock und seinen Output weiter personalisieren kann.

## Setup mit knitr
Der erste Code-Chunk in einem Dokument, der beim Erstellen eines neuen RMarkdown-Dokuments auch in RStudio miterstellt wird, ist typischerweise der Setup-Chunk. In ihm lassen sich durch Argumente verschiedene Regeln festlegen die im `default` auf jeden weiteren Code-Chunk zutreffen werden. Die [möglichen Befehle](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf?_ga=2.102259713.1013981012.1677056319-671987487.1666819594) innerhalb des Setup-Chunks sind weitreichend, meist wird dort aber nur definiert, ob man seinen Code und seine Ergebnisse anzeigen möchte und ob Warnungen oder Nachrichten angezeigt werden sollen. Letztere Optionen lauten bspw.

```
knitr::opts_chunk$set(include= TRUE, echo = TRUE, message = TRUE, warning = TRUE)
```

wenn man alle Elemente mit anzeigen möchte. Aber dies muss man auch nicht unbedingt selbst setzen, diese 4 Werte sind beispielsweise als `default = TRUE`, also standardmäßig auf `TRUE` gesetzt, und müssen daher eigentlich nur angepasst werden, wenn man sie spezifisch auf `FALSE` setzen will.


## Inline Code & Parameter
Genau so, wie man beim Text Codeblocks im Text oder als Block darstelen kann, lässt sich auch R-Code in Blöcken oder im Text ausführen.

In diesem Dokument wurden bspw. zu Beginn zwei zufällige Zahlen zwischen 1 und 20 definiert in einem im Dokument selbst nicht sichtbaren Codeblock.

Diese lassen sich nun mit Inline Code direkt darstellen: `r numberFunc`.

Der Vektor der zwei Zahlen wird dabei direkt in einer Aufführung mit Kommas dargestellt! Die Zahlen werden aber nur neu randomisiert, wenn das Dokument bearbeitet und neu geladen wird, nicht wenn diese Seite neu aufgerufen wird.


## Zitationen einbauen



***
