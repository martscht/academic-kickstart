---
title: WhatsApp Chats
date: '2020-01-30T23:15:00'
slug: projekt-whatsappchats
categories:
  - Projekt 3
tags: []
subtitle: ''
summary: ''
authors: [berger]
lastmod: '2022-12-12'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
header:
  image: "/header/whatsapp_post.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/1561391)"
---



<div id="übersicht" class="section level1">
<h1>Übersicht</h1>
<p>Als Psychologe wird man oft von anderen Menschen mit Laienpsychologie konfrontiert. Psychologische Weisheiten und angebliche psychologische Tests verbreiten sich heutzutage überall im Netz. Wir wollen uns nun anschauen, wie so ein angeblich psychologischer Test entwickelt wird. Der Test, den wir erstellen möchten, beschäftigt sich mit der Frage: „Wer sind deine wahren Freunde?“, indem er die WhatsApp-Chats mit deinen Freunden analysiert und dir zeigt, wem du am wichtigsten zu sein scheinst.</p>
<div id="zielsetzung" class="section level2">
<h2>Zielsetzung</h2>
<p>In dieser Aufgabe sollst du lernen, Texte zu analysieren; und zwar nicht mehr wie im Deutschunterricht auf Stilmittel, sondern z.B. auf Stimmungen. R kann dir dabei helfen, auffällige Häufigkeiten von Wörtern, Uhrzeiten und auch Stimmungen zu entdecken. Dafür wirst du weiterführende Kenntnisse zur Textanalyse mithilfe von <code>Udpipe</code> lernen. Außerdem wirst du deine neu erlernten Fähigkeiten für <code>ggplot</code> aus <a href="/post/uebersicht1">Projekt 1</a> und für Loops aus <a href="/post/uebersicht2">Projekt 2</a> anwenden können.</p>
</div>
<div id="vorbereitung" class="section level2">
<h2>Vorbereitung</h2>
<p>Für diese Aufgabe benötigst du die Handyapplikation WhatsApp und einen Gruppenchat mit Freunden oder Bekannten von dir. Diesen kannst du exportieren, indem du an deinem Handy auf deinen Gruppenchat drückst. Oben rechts siehst du drei vertikale Punkte und unter „Mehr“ findest du „Chat exportieren“. Den Chat solltest du zunächst ohne Medien exportieren.</p>
<p><img src="/post/2019-11-13-uebersicht3_files/whatsapp1.jpeg" style="width:40.0%" />
<img src="/post/2019-11-13-uebersicht3_files/whatsapp2.jpeg" style="width:40.0%" /></p>
<p><img src="/post/2019-11-13-uebersicht3_files/whatsapp3.jpeg" style="width:40.0%" /> <img src="/post/2019-11-13-uebersicht3_files/whatsapp4.jpeg" style="width:40.0%" /></p>
<p>Es sollte sich ein Fenster öffnen, in dem verschiedene Möglichkeiten zum Versenden der Datei angezeigt werden. Du kannst dir den Text beispielsweise per E-Mail schicken, um auch von deinem Computer auf die Datei zugreifen zu können. Lade die Textdatei auf deinen Computer und speichere sie im gleichen Ordner, in dem du auch deine R-Datei speichern möchtest.
Nun hast du eine Textdatei (.txt), in der jede Nachricht mit Name, Datum und Uhrzeit festgehalten ist.</p>
<p>Um den Chat in R einzulesen, brauchst du den folgenden Befehl:</p>
<pre class="r"><code>install.packages(&#39;rwhatsapp&#39;)
library(rwhatsapp)
raw &lt;- rwa_read(&#39;MeineGruppe.txt&#39;)</code></pre>
<p>Dafür wird ein zusätzliches Paket für das Einlesen von Whatsappchats verwendet. Die Textdatei wird direkt in verschiedene Spalten zerlegt, in denen Uhrzeit, Absender, Nachricht und Emojis stehen.</p>
<p>Zur Analyse werden wir das R-Paket <code>Udpipe</code> verwenden.
Im folgenden Absatz sind ein paar Links, die du dir zu <code>Udpipe</code> anschauen kannst. Dort findest du hilfreiche Befehle aus dem Paket. Vielleicht helfen sie dir auch, wenn du in der Aufgabe später nicht weiterkommst.</p>
<p><a href="https://towardsdatascience.com/easy-text-analysis-on-abc-news-headlines-b434e6e3b5b8">Hier</a> findest du die Aufbereitung eines Datensatzes mit Udpipe und ein paar Visualisierungen der Daten. Eine Übersicht zu Befehlen, die du mit <code>Udpipe</code> verwenden kannst, findest du direkt in der <a href="https://cran.r-project.org/web/packages/udpipe/vignettes/udpipe-annotation.html">Dokumentation des Pakets</a>. Auf <a href="https://datascienceplus.com/introducing-udpipe-for-easy-natural-language-processing-in-r/">dieser Seite</a> findest du eine sehr umfangreiche Besprechung von Sprachverarbeitung in R - was auch andere Dinge, außer <code>Udpipe</code>, betrifft.</p>
<p>Bevor du <code>Udpipe</code> verwenden kannst, musst du es installieren und laden:</p>
<pre class="r"><code>install.packages(&#39;udpipe&#39;)
library(udpipe)
model &lt;- udpipe_download_model(language = &quot;german&quot;)
udpipe_german &lt;-udpipe_load_model(file = dir(pattern = &#39;udpipe&#39;))</code></pre>
<p>Und jetzt kann es losgehen - viel Spaß beim Bearbeiten dieses Projekts.</p>
</div>
</div>
<div id="aufgaben" class="section level1">
<h1>Aufgaben</h1>
<div id="aufgabe-1-datensammlung-und--aufbereitung" class="section level2">
<h2>Aufgabe 1: Datensammlung und -aufbereitung</h2>
<p>Als Datengrundlage musst du, wie gerade beschrieben, einen deiner WhatsApp Chats exportieren und in R einlesen.</p>
<p>Wenn du dir nun den Datensatz anschaust, dann wirst du sehen, dass es in manchen Zeilen keinen Absender und keine Zeitangabe gibt. Das passiert, wenn jemand einen Absatz in seiner Nachricht gemacht hat.
Um dies zu beheben, müssen wir erst alle Zeilen identifizieren, die dieses Problem aufweisen. Dann musst du die Uhrzeit und den Absender aus der vorherigen Nachricht kopieren und in den ersten beiden Spalten der folgenden Nachricht einfügen.</p>
<p>Es gibt noch zwei weitere Sonderfälle in unserem Datensatz. Das sind zum einen die Fälle, in denen jemand dem Chat beigetreten ist bzw. ihn verlassen hat und zum anderen die ausgeschlossenen Medien. Um den ersten Sonderfall zu bearbeiten, musst du wieder zunächst die entsprechenden Zeilen identifizieren. Das kannst du auf ähnliche Weise wie bei den Absätzen machen (auch in diesen Zeilen gibt es keinen Absender). Dann soll hier aber nichts reinkopiert, sondern die ganze Zeile gelöscht werden. <br/>
Die ausgeschlossenen Medien entsprechen immer der gleichen Benachrichtigung, daher kannst du alle Zeilen, die dieses Muster aufweisen, auswählen und löschen. <br/>
Wenn du dir nun deinen Datensatz anschaust, sollte er keine leeren Zeilen oder Spalten mehr aufweisen. Damit hast du einen großen Schritt geschafft und wir können anfangen, mit dem Datensatz zu arbeiten.</p>
<p>Falls du von alleine nicht weiterkommen solltest, kannst du dir die <strong>Tipps</strong> anschauen.</p>
Tipp 1 hilft dir dabei, bei der Datenaufbereitung die Zeilenumbrüche im Datensatz zu beheben:
<details>
<summary>
Tipp 1
</summary>
<p>Die Nachrichten mit Zeilenumbrüchen lassen sich identifizieren, indem wir mit <code>which</code> zwei Bedingungen verknüpfen. Das geht ganz einfach mit dem ‘&amp;’ Zeichen. Danach kannst du in einer <code>for</code> Schleife den Absender und die Uhrzeit aus der vorherigen Nachricht in die Zeilen ohne Absender und Uhrzeit kopieren.</p>
</details>
<br>
In Tipp 2 wird erläutert, wie du mit den ausgeschlossenen Medien umgehen kannst.
<details>
<summary>
Tipp 2
</summary>
<p>Die ausgeschlossenen Medien lassen sich identifizieren, indem mit <code>grep</code> die Einträge eines character-Vektors ermittelt werden, die ein bestimmtes Textstück enthalten.</p>
</details>
<br>
Wenn du fertig mit der Bearbeitung der Aufgabe bist, kannst du einen Blick in die Lösung werfen.
<details>
<summary>
Lösung
</summary>
<p>Zunächst muss der Chat eingelesen werden.</p>
<pre class="r"><code>setwd(&#39;...&#39;)
install.packages(&#39;rwhatsapp&#39;)</code></pre>
<pre class="r"><code>library(rwhatsapp)
whatsapp &lt;- rwa_read(&#39;MeineGruppe.txt&#39;)</code></pre>
<p>Wenn du dir nun den Datensatz anschaust (z.B. über <code>View</code>) sollten die ersten sechs Zeilen so aussehen:</p>
<pre><code>## # A tibble: 6 × 6
##   time                author text                          source emoji  emoji…¹
##   &lt;dttm&gt;              &lt;fct&gt;  &lt;chr&gt;                         &lt;chr&gt;  &lt;list&gt; &lt;list&gt; 
## 1 2019-06-23 18:21:13 &lt;NA&gt;   &quot;Du hast die Gruppe \&quot;Meine … Meine… &lt;NULL&gt; &lt;NULL&gt; 
## 2 2019-06-26 11:49:13 Frank  &quot;Wer hat Lust so gegen viert… Meine… &lt;NULL&gt; &lt;NULL&gt; 
## 3 2019-06-26 12:05:13 Marie  &quot;Bin raus:/&quot;                  Meine… &lt;NULL&gt; &lt;NULL&gt; 
## 4 2019-06-26 12:05:13 Hans   &quot; Ich bin jetzt schon essen,… Meine… &lt;NULL&gt; &lt;NULL&gt; 
## 5 2019-06-26 12:06:13 Georg  &quot; Yess, am Cafe dann?&quot;        Meine… &lt;NULL&gt; &lt;NULL&gt; 
## 6 2019-06-26 12:09:13 Petra  &quot;Ich esse Zuhause&quot;            Meine… &lt;NULL&gt; &lt;NULL&gt; 
## # … with abbreviated variable name ¹​emoji_name</code></pre>
<p>Wenn es bei dir einige Zeilen gibt, die keinen Absender und keine Uhrzeit haben, liegt das daran, dass jemand einen Absatz in seiner Nachricht hatte.
Mit <code>which</code> werden hier zunächst alle Zeilen identifiziert, die keine Zeit und keinen Absender haben, also in den ersten beiden Spalten keine Einträge haben.
Im zweiten Schritt wird die Zeit und der Absender aus der jeweils darüber stehenden Zeile genommen und in die leeren ersten zwei Spalten eingefügt. Damit wurde eine einzige Nachricht über zwei Zeilen verteilt, was wir für später im Hinterkopf behalten müssen.
Wenn das bei dir nicht vorkommt, kannst du diesen Schritt einfach weglassen.</p>
<pre class="r"><code>linebreaks &lt;- which(is.na(whatsapp$time) &amp; is.na(whatsapp$author))
for (i in linebreaks) whatsapp[i, 1:2] &lt;- whatsapp[i - 1, 1:2] </code></pre>
<p>Der erste der zwei Sonderfälle sind Nachrichten vom System (wenn jemand der Gruppe beigetreten ist oder sie verlassen hat).
Hierfür überschreiben wir unseren Datensatz mit dem gleichen Chat unter Ausschluss der autorenlosen Zeilen.
Daher ist es wichtig, dass wir im Schritt vorher die Absätze in den Nachrichten bereinigt haben, um diese richtigen Nachrichten nicht zu löschen.</p>
<pre class="r"><code>whatsapp &lt;- whatsapp[!is.na(whatsapp$author),]</code></pre>
<p>Der zweite Sonderfall sind die Medien, die wir beim Exportieren aus Whatsapp ausgeschlossen haben. Mit <code>grep</code> können wir diese Nachrichten heraussuchen und durch NA ersetzen. Hier muss nicht die ganze Nachricht angegeben werden, da jede dieser Nachrichten gleich aufgebaut ist.</p>
<pre class="r"><code>whatsapp$text[grep(&#39;&lt;Medien ausgeschlossen&#39;, whatsapp$text)] &lt;- NA</code></pre>
</details>
</div>
<div id="aufgabe-2-darstellung" class="section level2">
<h2>Aufgabe 2: Darstellung</h2>
<p>Es ist immer sehr gut, wenn man vor einer Analyse erst eine Vorstellung von den Daten bekommt. Das geht am besten, indem man sie visualisiert.<br/>
Dazu gibt es verschiede Möglichkeiten: Wir können mit den <code>basic</code>-Funktionen von R oder mit <code>ggplot</code> arbeiten.
Ich habe mir ein paar Diagramme überlegt, die ich für sinnvoll halte, wenn dir aber etwas anderes einfällt, kannst du das gerne ebenfalls umsetzen.</p>
<ul>
<li>Wer schreibt am häufigsten?
<ul>
<li>als Kreisdiagramm (<code>basic</code>) <br/></li>
<li>als Balkendiagramm (<code>ggplot</code>)</li>
</ul></li>
<li>Wann schreibt ihr am meisten?
<ul>
<li>über die gesammte Zeit verteilt <br/></li>
<li>über die Woche verteilt (Wochentage) <br/></li>
<li>über den Tag verteilt (Uhrzeiten) <br/></li>
</ul></li>
</ul>
Falls du nicht weißt, wie du ein Diagramm über die gesamte Zeit, die Woche oder den Tag erstellst, kannst du dir den folgenden <strong>Tipp</strong> anschauen:
<details>
<summary>
Tipp 1
</summary>
<p>Bei dem Diagramm über die gesamte Zeit und über die Tageszeit hast du eine intervallskalierte Variable. Daher kannst du hier ein Histogramm erstellen. Bei den Wochentagen ist das anders, hierbei handelt es sich um eine diskrete nominalskalierte Variable mit sieben Kategorien. Hier musst du mit <code>geom_bar</code> ein Balkendiagramm erstellen.</p>
</details>
<br>
Wenn du fertig mit der Bearbeitung der Aufgabenstellung sein solltest, kannst du dein Ergebnis jetzt mit der Lösung vergleichen:
<details>
<summary>
Lösung
</summary>
<p>Falls du <code>ggplot2</code> noch nicht geladen hast, solltest du es jetzt tun. Falls du dich noch nicht damit beschäftigt hast, wie man mit diesem Paket Grafiken erzeugt, kannst du das z.B. in unserem Crashkurs zu <a href="/post/grafiken-mit-ggplot2/">Grafiken mit ggplot2</a> nachholen.</p>
<pre class="r"><code>library(&#39;ggplot2&#39;)</code></pre>
<p>Unser erstes Diagramm ist ein Kreisdiagramm zur Nachrichtenhäufigkeit der einzelnen Personen. Du brauchst hier den Befehl <code>table</code> damit du die Häufigkeiten der Personen bekommst. Weil der Autor von <code>ggplot2</code> sich vehement weigert, diese Art von Diagramm direkt zu implementieren, nutzen wir hier den R-eigenen Befehl <code>pie</code>. Dieser benötigt jedoch als Input eine Häufigkeitstabelle:</p>
<pre class="r"><code>tab &lt;- table(whatsapp$author)
tab</code></pre>
<pre><code>## 
##      Anna Anne-Lisa     Frank     Georg      Hans     Marie     Petra 
##       196        33        91       105        95       108       137</code></pre>
<pre class="r"><code>pie(tab, col = c(&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;violet&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;) )</code></pre>
<p><img src="/post/2022-12-12-Projekt-WhatsApp-Chats_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>Wenn wir ein Diagramm zur Nachrichtenhäufigkeit mit <code>ggplot</code> erstellen wollen, müssen wir ein Balkendiagramm benutzten.</p>
<pre class="r"><code>ggplot(whatsapp, aes(x = author)) +
geom_bar(width = 1 , aes(fill = author))</code></pre>
<p><img src="/post/2022-12-12-Projekt-WhatsApp-Chats_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p>Um ein Histogramm zu erzeugen, das aufzeigt, wann ihr - über die gesamte Zeit - am meisten schreibt, kannst du entweder die Basicfunktion <code>hist</code> verwenden oder wieder <code>ggplot</code>. Setzte die Balkenbreite so, wie es für dich Sinn macht.</p>
<pre class="r"><code>hist(whatsapp$time, breaks = 20, freq = TRUE)</code></pre>
<pre><code>## Warning in breaks[-1L] + breaks[-nB]: NAs durch Ganzzahlüberlauf erzeugt</code></pre>
<p><img src="/post/2022-12-12-Projekt-WhatsApp-Chats_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<pre class="r"><code>ggplot(whatsapp, aes(x = whatsapp$time))+ geom_histogram()</code></pre>
<pre><code>## Warning: Use of `whatsapp$time` is discouraged.
## ℹ Use `time` instead.</code></pre>
<p><img src="/post/2022-12-12-Projekt-WhatsApp-Chats_files/figure-html/unnamed-chunk-13-2.png" width="672" /></p>
<p>Für die Wochentage erstellen wir erst eine neue Variable, die die Wochentage enthält. Dafür gibt es in R den gesonderten Befehl <code>weekdays</code>, der den Wochentag eines Datums ausgibt. Da es wenig Sinn macht, die Wochentage alphabetisch zu sortieren, musst du noch einen Faktor erstellen, in dem du die richtigen Levels zuweist.
Da Wochentage nicht intervallskaliert sind, nutzen wir hier ein Balkendiagramm.</p>
<pre class="r"><code>whatsapp$Wochentage &lt;- weekdays(whatsapp$time)
whatsapp$Wochentage &lt;- factor(whatsapp$Wochentage, levels = c(&#39;Montag&#39;,&#39;Dienstag&#39;, &#39;Mittwoch&#39;, &#39;Donnerstag&#39;, &#39;Freitag&#39;, &#39;Samstag&#39;, &#39;Sonntag&#39;))</code></pre>
<pre class="r"><code>ggplot(whatsapp, aes(x = Wochentage)) + geom_bar()</code></pre>
<p><img src="/post/2022-12-12-Projekt-WhatsApp-Chats_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>Für die Uhrzeit erstellen wir erst eine neue Zeitvariable ohne das Datum mittels der Funktion<code>strftime</code>, die uns die Stunde (Hour) und die Minute (Minute), in der die Nachricht geschickt wurde, ausgeben soll (<code>%H:%M</code>). Leider speichert R die neue Zeitvariable wieder als <code>Character</code> ab, sodass du sie nochmal in <code>POSIXct</code> umformen musst. Zur Visualisierung benutzen wir hier ein Histogramm.</p>
<pre class="r"><code>whatsapp$uhrzeit &lt;- strftime(whatsapp$time, format = &#39;%H:%M&#39;)
whatsapp$uhrzeit &lt;- as.POSIXct(whatsapp$uhrzeit, format = &#39;%H:%M&#39;)
ggplot(whatsapp, aes(x = whatsapp$uhrzeit))+ geom_histogram(bins = 10, color = &#39;white&#39;) +
  xlab(&#39;Zeit&#39;)+ ylab(&#39;Nachrichten&#39;) + geom_freqpoly(bins = 10) + scale_x_datetime(date_labels = &#39;%H:%M&#39;)</code></pre>
<pre><code>## Warning: Use of `whatsapp$uhrzeit` is discouraged.
## ℹ Use `uhrzeit` instead.
## Use of `whatsapp$uhrzeit` is discouraged.
## ℹ Use `uhrzeit` instead.</code></pre>
<p><img src="/post/2022-12-12-Projekt-WhatsApp-Chats_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
</details>
</div>
<div id="aufgabe-3-zeitanalyse" class="section level2">
<h2>Aufgabe 3: Zeitanalyse</h2>
<p>Im ersten Schritt unserer Analyse schauen wir, wer am schnellsten antwortet. Dafür vergleichen wir die zentrale Tendenz der Antwortzeiten aller Personen.
Für die Antwortzeiten wird von jeder Uhrzeit die Uhrzeit der darauffolgenden Nachricht abgezogen.
Wenn du dir die Antwortzeiten anschaust, fällt dir dann etwas auf? <br/>
Wie du vielleicht von der Datenaufbereitung noch im Hinterkopf hast, werden aus Nachrichten mit einem Zeilenumbruch zwei Nachrichten in unserem Datensatz. Daher müssen wir alle Nachrichten ausschließen, bei denen Absender und Beantworter gleich sind. <br/>
Weiterhin musst du dir überlegen, welches Maß der zentralen Tendenz das sinnvollste ist.</p>
<p>Für unseren Freundetest erstellen wir nun eine neue Tabelle, in der wir Punkte vergeben. In dieser Tabelle müssen die Namen aller Teilnehmenden und das Ergebnis der Zeitanalyse stehen. Für die Punktevergaben gibt es einen einfachen Befehl, der deinen Freunden einen Rang zuordnet.</p>
<p>Falls du von alleine nicht weiterkommen solltest, kannst du dir die folgenden <strong>Tipps</strong> anschauen:</p>
Bei der Zeitanalyse soll die Differenz aus zwei Uhrzeiten gebildet werden. Tipp 1 zeigt dir wie:
<details>
<summary>
Tipp 1
</summary>
<p>Um die Uhrzeiten möglichst einfach subtrahieren zu können, bringen wir die Zeiten und beide Autoren in eine Zeile. Das bedeutet, dass wir zwei neue Spalten an unseren Datensatz hängen, in denen wir die Uhrzeit und den Absender der folgenden Nachricht speichern.</p>
</details>
<br>
Tipp 2 zeigt dir, wie du die Nachrichten ausschließen kannst, in denen Absender und Beantworter gleich sind.
<details>
<summary>
Tipp 2
</summary>
<p>Zunächst musst du diese Fälle identifizieren und in einer neuen Variable speichern. Anschließend kannst du mithilfe einer <code>for</code> Schleife diesen Fällen in den beiden neuen Spalten (Absender und Zeit der folgenden Nachricht; siehe Tipp 1) NA zuweisen.</p>
</details>
<br>
Welches Maß der zentralen Tendenz du am besten für die Antwortzeit verwendest, zeigt dir Tipp 3.
<details>
<summary>
Tipp 3
</summary>
<p>Wir haben keine Werte kleiner null, aber sehr starke Ausreißer nach oben. Daher ist es am sinnvollsten den Median zu benutzen, da dieser sehr robust gegenüber Ausreißern ist.
Mit <code>tapply</code> kannst du ihn direkt auf alle Personen gleichzeitig anwenden.</p>
</details>
<br>
Hier gibt es einen Tipp 4, wie du am besten mit der Punktevergabe für unsere Freundschaftsanalyse umgehst.
<details>
<summary>
Tipp 4
</summary>
<p>Für die Punktevergabe gibt es den Befehl <code>rank</code>. Beachte in welche Richtung die Punkte vergeben werden: Hier kriegt der mit dem kleinsten Median den Wert 1.</p>
</details>
<br>
Wenn du fertig mit der Bearbeitung der Aufgabenstellung sein solltest, kannst du dein Ergebnis jetzt mit der Lösung vergleichen. Wie auch bei den ersten Teilen (und eigentlich immer bei <code>R</code>) gilt, dass es mehrere Wege zum gleichen Ziel geben kann:
<details>
<summary>
Lösung
</summary>
<p>Wir haben uns hier einen zweiten Datensatz erstellt, damit wir zur Not einen weiteren formatierten Datensatz zur Verfügung haben. Damit vermeiden wir, dass wir von Anfang an alles neu einlesen müssen, wenn das Verändern des Datensatzes schief läuft. Das ist generell auch für die Zukunft immer eine gute Idee, wenn du etwas an deinem Datensatz verändern willst, dir aber nicht ganz sicher bist, wie es geht.</p>
<pre class="r"><code>whatsapp_new &lt;- whatsapp</code></pre>
<p>Wir wollen nun schauen, wer im Chat am schnellsten antwortet. Am einfachsten ist es, etwas zu analysieren, was in der gleichen Zeile steht. Daher erstellen wir eine neue Spalte und fügen jeweils die Zeit aus der darunter stehenden Zeile ein.</p>
<pre class="r"><code>whatsapp_new$response &lt;- NA
whatsapp_new$response &lt;-c(whatsapp_new$time[2:nrow(whatsapp_new)], NA)</code></pre>
<p>Im zweiten Schritt können wir dann beide Zeiten voneinander subtrahieren und haben unsere Antwortzeit.</p>
<pre class="r"><code>whatsapp_new$antwortzeit &lt;- whatsapp_new$response - whatsapp_new$time</code></pre>
<p>Das gleiche machen wir auch mit dem Absender der Antwortnachricht, da wir sonst nicht zuordnen können, wer hier wie schnell geantwortet hat. Wie ihr später noch feststellen werdet, ist es dabei wichtig, dass wir den Absender als Faktor vorliegen haben.</p>
<pre class="r"><code>whatsapp_new$antworter &lt;- NA
whatsapp_new$antworter &lt;-c(as.character(whatsapp_new$author[2:nrow(whatsapp_new)]), NA)
whatsapp_new$antworter &lt;- as.factor(whatsapp_new$antworter)</code></pre>
<p>Wie du dir hoffentlich gemerkt hast, gibt es mehrere Zeilen hintereinander, die eigentlich zur gleichen Nachricht gehören und es gibt auch Personen, die ihre Antwort generell in zwei Nachrichten und nicht in einer verfassen. Daher müssen wir die ausschließen, die “sich selbst antworten”. Dafür identifizieren wir zunächst jene Zeilen, die den gleichen Absender und Beantworter haben. Danach können wir in diesen Zeilen die Einträge in den zwei Spalten <code>antwortzeit</code> und <code>antworter</code> durch NA ersetzen.</p>
<pre class="r"><code>gleich &lt;- which(whatsapp_new$antworter == whatsapp_new$author)
for (i in gleich) {
  whatsapp_new[i,]$antwortzeit &lt;- NA
  whatsapp_new[i,]$antworter &lt;- NA
  }</code></pre>
<p>Nun musst du dir überlegen, welches das sinnvollste Maß der zentralen Tendenz in diesem Fall ist. Bei Betrachtung des Datensatzes sieht man, dass manche Antwortzeiten extrem hoch sind. Das kann daran liegen, dass erst am nächsten Tag geantwortet wurde, oder dass das Gespräch beendet und erst nach 2 Tagen ein neues angefangen wurde. Daher ist es am sinnvollsten, den Median zu nutzen, da dieser am robustesten gegenüber Ausreißern ist.
Mit <code>tapply</code> kannst du ein bestimmtes Maß auf die ganze Tabelle anwenden.</p>
<pre class="r"><code>zeit &lt;- tapply(whatsapp_new$antwortzeit, whatsapp_new$antworter, median)</code></pre>
<p>Um am Ende ein Ergebnis zu bekommen, wer nun wirklich die beste Freundin/der beste Freund ist, brauchen wir ein Punkte-System. Hierfür erstellen wir eine Tabelle mit den Namen aller Chatmitglieder und fügen die Zeit ein. Im zweiten Schritt erhält jeder Punkte, je nachdem auf welchem Platz er sich befindet. Dafür gibt es den Befehl <code>rank</code>, der die Punktevergabe automatisch durchführt.</p>
<pre class="r"><code>tab &lt;- data.frame(levels(whatsapp$author), zeit)
tab$Punkte &lt;- rank(tab$zeit)</code></pre>
<pre><code>##           levels.whatsapp.author. zeit Punkte
## Anna                         Anna  480      5
## Anne-Lisa               Anne-Lisa 1680      7
## Frank                       Frank  840      6
## Georg                       Georg  390      4
## Hans                         Hans  210      2
## Marie                       Marie  360      3
## Petra                       Petra  180      1</code></pre>
</details>
</div>
<div id="aufgabe-4-stimmungsanalyse" class="section level2">
<h2>Aufgabe 4: Stimmungsanalyse</h2>
<p>Für die Stimmungsanalyse benötigen wir zwei Pakete: <code>Udpipe</code> und <code>ggplot2</code>, wie in der <a href="/post/uebersicht3">Vorbereitung</a> schon beschrieben. <code>Udpipe</code> ermöglicht es, Sprache in ihre Einzelteile zerlegen und in ein einheitliches Datenformat umwandeln zu können. Im Anschluss können wir diese Einzelteile (und damit den Text, aus dem sie kommen) auf ihre Emotionalität (<em>Sentiment</em>) analysieren. In unserem Beispiel benutzen wir dafür <a href="http://sentistrength.wlv.ac.uk">Sentistrength</a> (z.B. Thelwall &amp; Buckley, 2013), ein Ansatz in dem jedes Wort in einem Wörterbuch nachgeschlagen wird, um zu sehen, wie emotional geladen es ist. Wenn du es mit einem Beispielsatz ausprobieren willst, kannst du es <a href="http://sentistrength.wlv.ac.uk/#Non-English">hier</a> mit dem “Detect Sentiment in German”-Button mal ausprobieren. Dieses Vorgehen werden wir auf den gesamten WhatsApp-Chat anwenden.</p>
<p>Damit das möglich ist, musst du die drei passenden Tabellen für unsere Analyse in R einlesen. <br/>
<strong>Tipp</strong>: Schau dir eine Datei vor dem Einlesen immer an - welche Trennzeichen sind vorhanden und gibt es eine Überschrift der Spalten?</p>
<p>Bei der ersten Datei <a href="../EmotionLookupTable.txt">„EmotionLookupTable“ <i class="fas fa-download"></i></a> handelt es sich um eine Liste von Wörtern, welche einen Score haben, der aussagt, wie stark positiv oder negativ die Bedeutung des Wortes ist. Zum Beispiel hat das Wort „grausam“ einen Score von -4, weil es sehr stark negativ geprägt ist. Im Gegensatz dazu hat das Wort „Niederlage“ einen Score von -1, weil es zwar negativ geprägt ist, aber nicht in dem gleichen Ausmaß wie „grausam“.</p>
<p>In der zweiten Liste <a href="../BoosterWordList.txt">„BoosterWordList“ <i class="fas fa-download"></i></a> befinden sich sogenannte Verstärker. Auch hier wird jedem Wort ein Score zwischen -1 und 2 zugewiesen . Dabei bedeutet -1, dass es sich um einen Abschwächer handelt und bei 1, um einen Verstärker. Es gibt auch Worte mit 0, die als neutral gelten.</p>
<p>Die dritte Datei <a href="../NegatingWordList.txt">„NegatingWordList“ <i class="fas fa-download"></i></a> ist eine Liste mit Wörtern, die die Bedeutung umkehren können. Wenn zum Beispiel später in der Chatanalyse der Satz „ich habe heute gar keine Lust!“ vorkommt, erkennt der Computer das Wort „Lust“ als ein sehr positiv geprägtes Wort. Daher benötigen wir diese Liste, um Verneinungen zu erkennen.</p>
<p>Um diese Dateien zu benutzten, müssen wir zunächst die “EmotionLookupTable” in einen Dataframe bringen. Die “BoosterWordList” müssen wir aufteilen in Verstärker und Abschwächer. <br/>
Die Analyse können wir sowohl nur für eine bestimmte Person machen, als auch für alle gleichzeitig. Wir werden es erst mit einer Person versuchen, um es im Anschluss auf alle zu erweitern.
Such dir einfach eine Person aus deinem Chat aus und speichere alle Nachrichten von ihr als <code>Character</code> in einer neuen Variable.</p>
<p>Nun kommt unser <code>Udpipe</code>-Paket zum Einsatz. Schau dir den Befehl <code>udpipe()</code> an. Er zerlegt den Quellcode in sogenannte Tokens. Tokens sind logische Einheiten an Wörtern. Bezogen auf unser Beispiel von eben würde der Satz „Ich habe heute überhaupt keinen Spaß!“ in:</p>
<p><em>Ich | Habe | Heute | überhaupt | keinen | Spaß</em></p>
<p>zerlegt werden.</p>
<p>Die wichtigen Wörter hierbei sind:<br/>
- <strong>überhaupt</strong> ist ein Verstärker <br/>
- <strong>keine</strong> ist ein Negator<br/>
- <strong>Spaß</strong> ist das emotionale Wort</p>
<p>Diese Tokens können nun analysiert werden mit dem Befehl <code>txt_sentiment</code>. Schau dir den Befehl am besten als erstes einmal an. Du hast alles eingelesen, was du für den Befehl brauchst.
Um dir das Ergebnis anzuschauen, musst du es einer neuen Variable zuweisen und kannst, wenn du die Spalte <code>overall</code> aufrufst, dein Ergebnis in der Console sehen.</p>
<p>Um diese Analyse mit dem ganzen Chat zu machen, benötigst du erst einen Dataframe, in dem der Chat als <code>Character</code> gespeichert ist. Im Anschluss musst du die Nachrichten wieder verketten. Dies ist mit allen Mitgliedern ein bisschen komplizierter, aber im Grundsatz das Gleiche wie bei der einzelnen Person.</p>
<p>Danach kannst du wie eben vorgehen. Wenn du dir am Ende dein Ergebnis anschaust, stehen dort keine Namen mehr. Du kannst der neuen Tabelle aber einfach die Namen aus der Chatdatei zuweisen.</p>
<p>Für unseren Test ist wichtig, dass jede Person einen Wert bekommen hat. Je höher dieser Wert, desto mehr positive Stimmungen wurden von ihr verbreitet. Wenn du diesen Wert in unserer Punktetabelle speicherst, dann kannst du, wie bei der Zeitanalyse, Rangpunkte vergeben.</p>
<p>Zum Schluss solltest du einen Endscore errechenen und so ein Ergebnis haben, wer dein bester Freund/deine beste Freundin ist. Und? Überrascht?</p>
<p>Falls du von alleine nicht weiterkommen solltest, kannst du dir die folgenden <strong>Tipps</strong> anschauen:</p>
<details>
<summary>
Tipp 1
</summary>
<p>Dieser Tipp hilft dir, wenn du die Wörterlisten nicht einlesen kannst.</p>
<p>Bei allen Dateien musst du angeben:
<code>stringAsFactor = FALSE</code>
Bei der EmotionLookUpTable sind Zeilenumbrüche das Trennzeichen. Das kannst du so hinschreiben: <code>sep = '\t'</code></p>
</details>
<details>
<summary>
Tipp 2
</summary>
<p>Wie du Abschwächer und Verstärker voneinander trennen kannst, erfährst du hier.</p>
<p>Verstärker und Abschwächer kannst du verschieden Variablen zuweisen, indem du sie über ihre Scores unterscheidest. Verstärker haben immer einen Wert über null und Abschwächer immer einen Wert unter null.</p>
</details>
<details>
<summary>
Tipp 3
</summary>
<p>Dieser Tipp hilft dir die Nachrichten für die Stimmungsanalyse vorzubereiten:</p>
<p>Bei der ersten Analyse nur mit deinen Nachrichten kannst du mit <code>grep</code> die Nachrichten auswählen und mit <code>paste</code> wieder verketten.
Wenn du alle Nachrichten hast, brauchst du kein <code>grep</code> mehr, sondern erstellst erst einen neuen Datensatz und verkettest sie in einer <code>for</code> Schleife.</p>
<pre class="r"><code>for (i in levels(whatsapp$who)) {
  chat$what[chat$who == i] &lt;- paste(whatsapp$text[whatsapp$who == i], collapse = &#39; &#39;)
}</code></pre>
</details>
<details>
<summary>
Tipp 4
</summary>
<p>Der letzte Tipp zeigt dir die Punktevergabe bei der Stimmungsanalyse und was du hier anders machen musst:</p>
<p>Bei der Stimmungsanalyse ist ein höherer Wert besser. Das steht im Gegensatz zu der Zeitanalyse, wo ein kleiner Wert besser war. Bei dem <code>rank</code> Befehl kannst du ganz einfach ein minus vor die Variable setzen, um die Punktevergabe umzudrehen.</p>
</details>
<p>Wenn du fertig mit der Bearbeitung der Aufgabenstellung sein solltest, kannst du dein Ergebnis jetzt mit der Lösung vergleichen.</p>
<details>
<summary>
Lösung
</summary>
<p>Falls du es noch nicht getan hast solltest du spätestens hier das Packet <code>Udpipe</code> installiert haben und laden.</p>
<pre class="r"><code># install.packages(&quot;udpipe&quot;)
library(udpipe)</code></pre>
<p>Das Folgende wurde alles bereits erklärt, der Vollständigkeit halber steht es hier aber nochmals. Um <code>udpipe</code> benutzen zu können, musst du das Modell in der richtigen Sprache herunterladen und in die aktuelle Sitzung laden.</p>
<pre class="r"><code># model &lt;- udpipe_download_model(language = &#39;german&#39;)
germodel &lt;- udpipe_load_model(file = dir(pattern = &#39;udpipe&#39;)) </code></pre>
<p>Nun müssen die verschiedenen Listen eingelesen werden. Wir haben die Tabellen mit den richtigen Namen versehen, damit es einfacher und ordentlicher ist. Das ist zwar kein muss, aber umbedingt zu empfehlen.</p>
<pre class="r"><code>emo &lt;- read.csv(&#39;EmotionLookupTable.txt&#39;, sep = &#39;\t&#39;, header = FALSE, stringsAsFactors = FALSE)
names(emo) &lt;- c(&#39;Wort&#39;, &#39;Senti&#39;, &#39;Englisch&#39;, &#39;Quelle&#39;, &#39;Entstehung&#39;)


boost &lt;- read.table(&#39;BoosterWordList.txt&#39;, stringsAsFactors = FALSE)
names(boost) &lt;- c(&#39;Wort&#39;, &#39;Boost&#39;)


negate &lt;- read.table(&#39;NegatingWordList.txt&#39;, stringsAsFactors = FALSE)
negate &lt;- negate[, 1]</code></pre>
<p>Für die Textanalyse brauchen wir eine Tabelle, in der alle Wörter nach ihrer Stärke der Bedeutung sortiert sind.</p>
<pre class="r"><code>polar &lt;- data.frame(term = emo$Wort, polarity = emo$Senti, stringsAsFactors = FALSE)</code></pre>
<p>Die Boostliste wird hier unterteilt in Verstärker und Abschwächer.</p>
<pre class="r"><code>ampli &lt;- boost[boost$Boost &gt; 0, &#39;Wort&#39;]
deamp &lt;- boost[boost$Boost &lt; 0, &#39;Wort&#39;]</code></pre>
<p>Zuerst versuchen wir die Analyse mit Hans. Dafür suchen wir mit <code>grep</code> alle Nachrichten raus, die Hans geschrieben hat.</p>
<pre class="r"><code>hans &lt;- whatsapp$text[grep(&#39;Hans&#39;, whatsapp$author)]
hans &lt;- paste(hans, collapse = &#39; &#39;)</code></pre>
<p>Im zweiten Schritt müssen wir die Nachrichten in <code>Tokens</code> zerlegen. Wenn du nicht mehr weißt, was damit gemeint ist, schau dir unter <a href="/post/problemstellung3">der Problemstellung</a> nochmal die genauere Erklärung an.</p>
<pre class="r"><code>hans &lt;- udpipe(hans, germodel) </code></pre>
<p>Für die Analyse hast du nun vier Komponenten:</p>
<ul>
<li><code>polarity_terms</code> sind die Wörter an sich, welche positiv oder negativ sind.</li>
<li><code>polarity_negators</code> sind die Begriffe, die die Bedeutung umkehren können.</li>
<li><code>polarity_amplifiers</code> sind die Verstärker.</li>
<li><code>polarity_deamplifiers</code>sind die Abschwächer.</li>
</ul>
<pre class="r"><code>senti_hans &lt;- txt_sentiment(hans,
  polarity_terms = polar,
  polarity_negators = negate,
  polarity_amplifiers = ampli,
  polarity_deamplifiers = deamp) </code></pre>
<p>In der Spalte <code>overall</code> sind alle Endergebnisse gespeichert.</p>
<pre class="r"><code>senti_hans$overall </code></pre>
<pre><code>##    doc_id sentiment_polarity sentences terms      terms_positive terms_negative
## 1:   doc1                 -3        21   525 gern, gut, ok, okay  leider, sorry
##    terms_negation terms_amplification
## 1:    kein, nicht       bißchen, voll</code></pre>
<p>Wenn wir das Ganze nun mit allen aus dem Chat machen wollen, müssen wir ein Dataframe mit allen Personen erstellen und die Nachrichten hinzufügen.</p>
<pre class="r"><code>chat &lt;- data.frame(author = levels(whatsapp$author), what = &#39;&#39;, stringsAsFactors = FALSE)
for (i in levels(whatsapp$author)) {
  chat$what[chat$author == i] &lt;- paste(whatsapp$text[whatsapp$author == i], collapse = &#39; &#39;)
}</code></pre>
<p>Auch hier zerlegen wir die Nachricht in <code>Tokens</code> und analysieren den Chat auf die gleiche Art und Weise wie oben.</p>
<pre class="r"><code>chat &lt;- udpipe(chat$what, germodel)

senti_all &lt;- txt_sentiment(chat,
  polarity_terms = polar,
  polarity_negators = negate,
  polarity_amplifiers = ampli,
  polarity_deamplifiers = deamp)
senti_all$overall</code></pre>
<pre><code>##    doc_id sentiment_polarity sentences terms
## 1:   doc1               40.6        23  1176
## 2:   doc2                2.0        17   284
## 3:   doc3               29.6        41   666
## 4:   doc4               15.6        24   700
## 5:   doc5               -3.0        21   525
## 6:   doc6               14.2        42   870
## 7:   doc7               -1.0        30  1130
##                                              terms_positive
## 1: danke, gern, gut, mögen, ok, spaß, super, süß, zufrieden
## 2:                                        gern, gratis, gut
## 3:        danke, gern, gut, inspirieren, okay, super, süßen
## 4:                              gut, hoffentlich, mag, okay
## 5:                                      gern, gut, ok, okay
## 6:                                    gern, gut, super, süß
## 7:                                      gern, gut, ok, okay
##                  terms_negative   terms_negation
## 1:                leider, sorry      kein, nicht
## 2:                       leider            nicht
## 3:                       leider      kein, nicht
## 4:                leider, sorry kein, nicht, nie
## 5:                leider, sorry      kein, nicht
## 6: blöd, kriegen, leider, sorry            nicht
## 7:    leider, schade, vermissen      kein, nicht
##                                          terms_amplification
## 1:                                 bißchen, echt, sehr, voll
## 2:                                      echt, komplett, sehr
## 3: bestimmt, bißchen, definitiv, echt, sehr, wenig, wirklich
## 4:                                          echt, sehr, voll
## 5:                                             bißchen, voll
## 6:                                       bißchen, echt, voll
## 7:                  echt, unglaublich, voll, wirklich, würde</code></pre>
<p>Nun kann man jedoch nicht erkennen, welche Daten zu welcher Person gehören, da der <code>overall</code> Befehl nur Nummern und keine Namen anzeigt. Das Problem können wir aber lösen, indem wir die Autorennamen in einem weiteren Schritt zuweisen.</p>
<pre class="r"><code>senti &lt;- senti_all$overall
senti$doc_id &lt;- levels(whatsapp$author)</code></pre>
<p>Nun kannst du dir die Werte absteigend anschauen. Der höchste Wert ist die positivste Person in deinem Chat.</p>
<pre class="r"><code>senti[order(senti$sentiment_polarity, decreasing = TRUE), ]</code></pre>
<pre><code>##       doc_id sentiment_polarity sentences terms
## 1:      Anna               40.6        23  1176
## 2:     Frank               29.6        41   666
## 3:     Georg               15.6        24   700
## 4:     Marie               14.2        42   870
## 5: Anne-Lisa                2.0        17   284
## 6:     Petra               -1.0        30  1130
## 7:      Hans               -3.0        21   525
##                                              terms_positive
## 1: danke, gern, gut, mögen, ok, spaß, super, süß, zufrieden
## 2:        danke, gern, gut, inspirieren, okay, super, süßen
## 3:                              gut, hoffentlich, mag, okay
## 4:                                    gern, gut, super, süß
## 5:                                        gern, gratis, gut
## 6:                                      gern, gut, ok, okay
## 7:                                      gern, gut, ok, okay
##                  terms_negative   terms_negation
## 1:                leider, sorry      kein, nicht
## 2:                       leider      kein, nicht
## 3:                leider, sorry kein, nicht, nie
## 4: blöd, kriegen, leider, sorry            nicht
## 5:                       leider            nicht
## 6:    leider, schade, vermissen      kein, nicht
## 7:                leider, sorry      kein, nicht
##                                          terms_amplification
## 1:                                 bißchen, echt, sehr, voll
## 2: bestimmt, bißchen, definitiv, echt, sehr, wenig, wirklich
## 3:                                          echt, sehr, voll
## 4:                                       bißchen, echt, voll
## 5:                                      echt, komplett, sehr
## 6:                  echt, unglaublich, voll, wirklich, würde
## 7:                                             bißchen, voll</code></pre>
<p>Für unseren Test müssen wir nun wieder Punkte verteilen. Dafür solltest du erst den ‘Positivitätswert’ in der Tabelle speichern und dann wie bei der Zeitanalyse Punkte vergeben. Hier muss du aber ein Minus vorschreiben, weil die höchste Zahl hier am besten ist, und nicht die niedrigste.</p>
<pre class="r"><code>tab$senti &lt;- senti$sentiment_polarity
tab$Punkte2 &lt;- rank(-senti$sentiment_polarity)</code></pre>
<p>Für das Ergebnis des Tests rechnest du einfach beide Punkte zusammen und lässt dir das Minimum ausgeben.</p>
<pre class="r"><code>tab$final &lt;- tab$Punkte + tab$Punkte2
tab$levels.whatsapp.author.[which.min(tab$final)]</code></pre>
<pre><code>## [1] &quot;Anna&quot;</code></pre>
<p>Wie du siehst, scheint hier Anna deine beste Freundin zu sein. Falls du noch die Ergebnisse der anderen vergleichen möchtest, hier die Gesamtübersicht der Werte und Punkte:</p>
<pre class="r"><code>tab</code></pre>
<pre><code>##           levels.whatsapp.author. zeit Punkte senti Punkte2 final
## Anna                         Anna  480      5  40.6       1     6
## Anne-Lisa               Anne-Lisa 1680      7   2.0       5    12
## Frank                       Frank  840      6  29.6       2     8
## Georg                       Georg  390      4  15.6       3     7
## Hans                         Hans  210      2  -3.0       7     9
## Marie                       Marie  360      3  14.2       4     7
## Petra                       Petra  180      1  -1.0       6     7</code></pre>
</details>
<hr />
<p>Herzlichen Glückwunsch! Wenn du es bis hierhin geschafft hast, hast du erfolgreich das Projekt zu den WhatsApp Chats abgeschlossen (oder einfach sehr viel Text und <code>R</code>-Code gelesen). Falls dieses Projekt dir Lust nach mehr Projekten gemacht hat, kannst du dich unter dem Reiter <code>Projekte</code> auf <code>pandaR</code> weiter austoben.</p>
</div>
</div>
