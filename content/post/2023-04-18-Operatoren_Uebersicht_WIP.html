---
title: "Operatoren in R - Übersicht"
date: '2023-03-24'
slug: Operatoren
categories:
  - extras
tags:
subtitle: ''
summary: ''
authors: [pommeranz]
lastmod: '2023-04-18'
featured: no
header:
  image: "/header/" #https://pxhere.com/de/photo/29 maybe this?
  caption: "[Courtesy of pxhere](https://pxhere.com/de/photo/29)"
projects: []
---



<!-- r blogdown::shortcode_open("detail_disclosure", "Kernfragen dieses Beitrags") -->
<!-- Die divs sind wichtig, damit die Liste funktioniert! Innerhalb dieses Shortcodes ist HTML erlaubt (safeHTML) -->
<div>
<ul>
<li>Wie funktionieren die <a href="#arithmetic">arithmetischen</a> Operatoren ?</li>
<li>Wie funktionieren die <a href="#relational">relationalen</a> Operatoren ?</li>
<li>Wie funktionieren die <a href="#logic">logischen</a> Operatoren ?</li>
<li>Wie funktionieren die <a href="#assign">Zuordnungsoperatoren</a>?</li>
<li>Wie funktionieren die <a href="#data">Datenselektionsoperatoren</a>?</li>
</ul>
</div>
<!-- r blogdown::shortcode_close("detail_disclosure") -->
<hr />
<div id="arithmetic" class="section level2 anchorheader">
<h2>Arithmetisch</h2>
<table>
<colgroup>
<col width="11%" />
<col width="24%" />
<col width="64%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Operator</th>
<th align="center">Beschreibung</th>
<th align="left">Beispiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">+</td>
<td align="center">Addition</td>
<td align="left"><code>1 + 2</code> = 3</td>
</tr>
<tr class="even">
<td align="center">-</td>
<td align="center">Substraktion</td>
<td align="left"><code>1 - 2</code> = -1</td>
</tr>
<tr class="odd">
<td align="center">*</td>
<td align="center">Multiplikation</td>
<td align="left"><code>3 * 3</code> = 9</td>
</tr>
<tr class="even">
<td align="center">/</td>
<td align="center">Division</td>
<td align="left"><code>10 / 9</code> = 1.1111111</td>
</tr>
<tr class="odd">
<td align="center">^</td>
<td align="center">Exponent</td>
<td align="left"><code>2 ^ 5</code> = 32</td>
</tr>
<tr class="even">
<td align="center">%%</td>
<td align="center">Modulo</td>
<td align="left"><code>10 %% 2</code> = 0</td>
</tr>
<tr class="odd">
<td align="center">%/%</td>
<td align="center">Integer Division</td>
<td align="left"><code>10 %/% 9</code> = 1</td>
</tr>
<tr class="even">
<td align="center">%*%</td>
<td align="center">Matrizenmultiplikation</td>
<td align="left"><code>matrix(1:4, nrow=2) %*% matrix(1:4, nrow=2)</code>=7, 10, 15, 22</td>
</tr>
<tr class="odd">
<td align="center">:</td>
<td align="center">Integer von x:(bis)y</td>
<td align="left"><code>1:9</code> = 1, 2, 3, 4, 5, 6, 7, 8, 9</td>
</tr>
</tbody>
</table>
</div>
<div id="relational" class="section level2 anchorheader">
<h2>Relational</h2>
<table style="width:82%;">
<colgroup>
<col width="15%" />
<col width="26%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Operator</th>
<th align="left">Beschreibung</th>
<th align="left">Beispiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">&lt;</td>
<td align="left">Kleiner als</td>
<td align="left"><code>1&lt;2</code> = TRUE</td>
</tr>
<tr class="even">
<td align="center">&gt;</td>
<td align="left">Größer als</td>
<td align="left"><code>1&gt;2</code> = FALSE</td>
</tr>
<tr class="odd">
<td align="center">&lt;=</td>
<td align="left">Kleinergleich</td>
<td align="left"><code>1&lt;=2</code> = TRUE</td>
</tr>
<tr class="even">
<td align="center">&gt;=</td>
<td align="left">Größergleich</td>
<td align="left"><code>1&gt;=2</code> = FALSE</td>
</tr>
<tr class="odd">
<td align="center">==</td>
<td align="left">Gleich</td>
<td align="left"><code>1==2</code> = FALSE</td>
</tr>
<tr class="even">
<td align="center">!=</td>
<td align="left">Ungleich</td>
<td align="left"><code>1!=2</code> = TRUE</td>
</tr>
</tbody>
</table>
<p>Operatoren, die einen entsprechenden Wahrheitswert in ihrer wertvergleichenden Aussage geben. <code>==</code> und <code>!=</code> lassen sich auch bei character anwenden, um sie direkt zu vergleichen. Sogar Größenvergleiche funktionieren, dabei wird die alphabetische Ordnung verglichen (weiter hinten im Alphabet ist also größer). Auc boolean können verglichen werden. <code>FALSE</code> ist dabei kleiner als <code>TRUE</code>, da <code>FALSE</code> mit einer 0 gleichgesetzt wird, während <code>TRUE</code> mit einer 1 gleichgesetzt wird.</p>
</div>
<div id="logic" class="section level2 anchorheader">
<h2>Logisch</h2>
<table style="width:89%;">
<colgroup>
<col width="16%" />
<col width="40%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Operator</th>
<th align="left">Beschreibung</th>
<th align="left">Beispiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">!</td>
<td align="left">Logisches NOT</td>
<td align="left"><code>!(TRUE)</code> = FALSE</td>
</tr>
<tr class="even">
<td align="center">&amp;</td>
<td align="left">Element-wise logisches AND</td>
<td align="left"><code>TRUE &amp; FALSE</code> = FALSE</td>
</tr>
<tr class="odd">
<td align="center">&amp;&amp;</td>
<td align="left">Logisches AND</td>
<td align="left"><code>TRUE &amp;&amp; c(TRUE,FALSE)</code> = TRUE</td>
</tr>
<tr class="even">
<td align="center">|</td>
<td align="left">Element-wise logisches OR</td>
<td align="left"><code>TRUE | FALSE</code> = TRUE</td>
</tr>
<tr class="odd">
<td align="center">||</td>
<td align="left">Logisches OR</td>
<td align="left"><code>TRUE || c(TRUE,FALSE)</code> = TRUE</td>
</tr>
<tr class="even">
<td align="center">%in%</td>
<td align="left">Ob Element in Vektor</td>
<td align="left"><code>1%in%1:5</code> = TRUE</td>
</tr>
</tbody>
</table>
<p>Unterschied zwischen <code>||</code> und <code>|</code>, sowie <code>&amp;&amp;</code> und <code>&amp;</code>:
<code>|</code> und <code>&amp;</code> evaluieren jedes Element einzeln,
<code>||</code> und <code>&amp;&amp;</code> evaluieren immer nur den ersten Wert, den sie erhalten</p>
<pre class="r"><code>x &lt;- c(TRUE,0,TRUE,FALSE)
y &lt;- c(FALSE,FALSE,1,TRUE)

x&amp;y</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>x&amp;&amp;y</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>x|y</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE  TRUE</code></pre>
<pre class="r"><code>x||y</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="assign" class="section level2 anchorheader">
<h2>Zuordnungsoperatoren</h2>
<table style="width:74%;">
<colgroup>
<col width="22%" />
<col width="40%" />
<col width="11%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Operator</th>
<th align="left">Beschreibung</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">&lt;-, &lt;&lt;-, =</td>
<td align="left">Linksgebundene Zuordnung</td>
<td><code>test &lt;- 1</code>, <code>test</code> = 1</td>
</tr>
<tr class="even">
<td align="left">-&gt;, -&gt;&gt;</td>
<td align="left">Rechtssgebundene Zuordnung</td>
<td><code>2 -&gt; test</code>, <code>test</code> = 2</td>
</tr>
</tbody>
</table>
<p>Zuordnungsoperatoren, standardmäßig benutzt man linksgebunden <code>&lt;-</code>, aber rechtsbündig oder ein <code>=</code> sind genauso valide Optionen. Innerhalb von Funktionen sind die normalen Zuordnungen nur lokal innerhalb der Funktion, mit <code>&lt;&lt;-</code>/<code>-&gt;&gt;</code> lassen sich hierbei auch globale Werte setzen, wie es üblich ist außerhalb von Funktionen.</p>
</div>
<div id="data" class="section level2 anchorheader">
<h2>Datenselektionsoperatoren</h2>
<pre class="r"><code>#Beispiel-Dataframe
example_df &lt;- data.frame(
  Farbe = c(&quot;Rot&quot;,&quot;Blau&quot;,&quot;Grün&quot;),
  Zahl = c(24, 25, 42)
)</code></pre>
<table>
<colgroup>
<col width="9%" />
<col width="51%" />
<col width="38%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Operator</th>
<th align="left">Beschreibung</th>
<th align="left">Beispiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">$string</td>
<td align="left">Wählt Spalte mit den Namen <code>string</code> (type)</td>
<td align="left"><code>example_df$Farbe</code> = Rot, Blau, Grün</td>
</tr>
<tr class="even">
<td align="center">[x,y]</td>
<td align="left">Element aus Reihe <code>x</code>, Spalte <code>y</code> (type)</td>
<td align="left"><code>example_df[1,1]</code> = Rot</td>
</tr>
<tr class="odd">
<td align="center">[,y]</td>
<td align="left">Alle Elemente der Spalte Nr. <code>y</code>(type/type-vector)</td>
<td align="left"><code>example_df[,1]</code> = Rot, Blau, Grün</td>
</tr>
<tr class="even">
<td align="center">[x,]</td>
<td align="left">Das Element an Stelle <code>x</code> jeder Spalte (lists (Länge 1))</td>
<td align="left"><code>example_df[1,]</code> = Rot, 24</td>
</tr>
<tr class="odd">
<td align="center">[z]</td>
<td align="left">Gibt Spalte <code>z</code> als Liste wieder (list)</td>
<td align="left"><code>example_df[[1]]</code> = Rot, Blau, Grün</td>
</tr>
<tr class="even">
<td align="center">[[z]]</td>
<td align="left">Gibt Spalte <code>z</code> als Listenelemente wieder (type/type-vector)</td>
<td align="left"><code>example_df[[1]]</code> = Rot, Blau, Grün</td>
</tr>
<tr class="odd">
<td align="center">[[z]][[z2]]</td>
<td align="left">Gibt Element <code>z2</code> aus Liste <code>z</code> wieder (type)</td>
<td align="left"><code>example_df[[1]][[1]]</code> = Rot</td>
</tr>
</tbody>
</table>
<p>x ist hierbei eine Zahl, die mit einer Reihenposition übereinstimm und y entweder ein character, der mit einem Spaltennamen übereinstimmt, oder eine Zahl, die mit einer Spaltenposition übereinstimmt. z muss ebenso als Zahl mit einem Listenindex übereinstimmen oder den selbe character wie das jeweilige Element haben, sofern z auch eine Liste ist.</p>
<p>df$String und [x] lassen sich auch kombinieren!
$string[x] wäre beispielsweise das x’te Element aus dem Vektor der Namensspalte des Dataframes, denn ist es äquivalent zu df[x,“String”]</p>
<p>Double Brackets [[]] sind ungewöhnlich im Dataframe, da wir über [x,y] / [,y] eine gleichwertige, einfacher spezifizierbare Indexierung vornehmen können. Sie werden aber verwendet, wenn man Elemente aus Listen nehmen möchte.</p>
<pre class="r"><code>example_list &lt;- list(1:5, LETTERS[6:10])
#statt dem hier, wo eine Liste aufgerufen wird ...
example_list[2]</code></pre>
<pre><code>## [[1]]
## [1] &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot;</code></pre>
<pre class="r"><code>typeof(example_list[2])</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<pre class="r"><code># ... werden hiermit die tatsächlichen Elemente aufgerufen
example_list[[2]]</code></pre>
<pre><code>## [1] &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot;</code></pre>
<pre class="r"><code>typeof(example_list[[2]])</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>Hier ist der Vorteil, dass der spezielle Typ des character-Vectors erhalten bleibt.</p>
<hr />
</div>
