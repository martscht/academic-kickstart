---
title: Netzwerkanalyse im Querschnitt
date: '2022-01-11'
slug: cross-sectional-networks
categories:
  - MSc5a
tags:
  - Querschnitt
  - Zusammenfassung
  - Netzwerkanalyse
subtitle: ''
summary: ''
authors: [nehler]
lastmod: '2022-01-10T15:21:58+02:00'
featured: no
header:
  image: "/header/Klipps_Meta-Analyse_MW.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/1075945)"
projects: []
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<div id="einführung" class="section level2">
<h2>Einführung</h2>
<p>Netzwerkanalyse kommt aus einem eher technischen Feld. Sie wurde dafür genutzt, Systeme darzustellen, bei denen verschiedene Einheiten miteinander verbunden sind. Beispielsweise wurden Computer als Knotenpunkte gesehen und dann über Kanten deren Verbindung (oder eben auch Nicht-Verbindung) dargestellt. Den ersten Einzug in die Psychologie hatten Netzwerke in Gruppenanalysen. Dabei sind nun nicht mehr Computer die Knotenpunkte, sondern eben Menschen aus einer spezifischen Gruppe. Bestimmte Arten der Beziehung werden dabei durch eine Verbindung zwischen zwei Personen abgebildet.</p>
<p><img src="/post/2021-12-22-Klipps_Netzwerkanalyse_Querschnitt_files/figure-html/unnamed-chunk-1-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>In der neueren Literatur werden Netzwerke aber auch zur Darstellung von Psychologischen Konstrukten genutzt. Beispielsweise können die einzelne Symptome der Depression die Knotenpunkte darstellen und die Kanten deren Zusammenhang. Dies hat gegenüber einem globalen Skalenwert den Vorteil, dass die Dynamik zwischen verschiedenen Symptomen aufgezeigt werden kann. Dadurch könnten zentrale Symptome und mögliche Ansatzpunkte für die Intervision aufgefunden werden. Bevor wir diese Punkte im Netzwerk identifizieren können, müssen wir uns mit grundlegenden Begriffen und der Berechnung der Netzwerkstruktur auseinandersetzen.</p>
<p>Psychologisches Netzwerk zur Veranschaulichung (aus Präsentation nehmen)</p>
</div>
<div id="begriffsklärung-und-netzwerktypen" class="section level2">
<h2>Begriffsklärung und Netzwerktypen</h2>
<p>Betrachten wir an dieser Stelle nochmal zwei grundlegende Begriffe der Netzwerkanalyse. Wie bereits angedeutet wurde, bestehen diese aus <strong>Knoten</strong> und <strong>Kanten</strong>. <strong>Knoten</strong> oder englisch <strong>nodes</strong> repräsentieren Unterschiedliche psychologische Variablen (z.B: Störungen Symptome oder Items), die über Messungen aus verschiedenen Skalen oder Subskalen werden können. <strong>Edges</strong> der englisch <strong>edges</strong> repräsentieren statistische Beziehungen zwischen den Nodes (z.B. zum Beispiel Korrelationen) die anhand der Daten geschätzt werden. Während Werte auf den Knoten also gemessen werden, muss deren Beziehung (also die Kanten) geschätzt werden.</p>
<p>Kanten können sowohl <strong>gerichtet</strong> als auch <strong>ungerichtet</strong> sein, wobei gerichtete Edges durch einen Pfeil gekennzeichnet werden, der einen einseitigen Effekt andeutet.</p>
<p>gerichetes und ungerichtetes Netzwerk nebeneinader darstellen</p>
<p>Ungerichtete Kanten werden durch eine einfache Linie zwischen zwei Knoten abgebildet werden. Ein Netzwerk, das nur gerichtete Kanten enthält, bezeichnet man als <strong>gerichtetes Netzwerk</strong>. Netzwerke aus ungerichteten Kanten nennt man hingegen <strong>ungerichtetes Netzwerk</strong>. Im Querschnitt sind keine zeitlichen Abfolgen bekannt, weshalb wir heute zunächst nur ungerichtete Netzwerke betrachten werden.</p>
<p>Eine weitere interessante Eigenschaft eines Netzwerkes besteht darin, ob die Kanten ein Gewicht inne haben. Die Unterscheidung besteht darin zwischen <strong>gewichteten</strong> und <strong>ungewichteten</strong> Netzwerken. Für beide Arten haben wir in diesem Tutorial bereits Beispiele gesehen. Das soziale Netzwerk der 10 Personen zeigte nur an, ob zwischen diesen eine Beziehung besteht oder nicht. Der Beziehung wird kein Gewicht zugegeben, weshalb es sich um ein ungewichtetes Netzwerk handelt. Das präsentierte psychologische Netzwerk hingegen hat unterschiedliche Kantenformen. Diese sind unterschiedlich dick, wodurch die unterschiedliche Stärke des Zusammenhangs zwischen den Symptomen demonstriert wird. Dabei wird auch durch die Farbe dargestellt, ob eine positive oder negative Beziehung vorliegt. Ursprünglich wurde dies durch grüne und rote Kanten demonstriert, wobei jetzt eine Wahl von blau für positive Beziehung eine höhere Differenzierbarkeit garantiert.</p>
<p>Nachdem nun die wichtigsten Basics über Netzwerke abgehandelt wurden, können wir uns mit den ersten kleinen Umsetzungen in <code>R</code> beschäftigen. Zunächst brauchen wir aber natürlich einen Datensatz.</p>
</div>
<div id="daten" class="section level2">
<h2>Daten</h2>
<p>In dieser Sitzung wollen wir einen Datensatz von Rubin (2020). verwenden. Dieser steht auf <a href="https://osf.io/awz3d/">OSF zum Download</a> zur Verfügung kann aber auch über den folgenden Befehl direkt ins Environment eingeladen werden.</p>
<pre class="r"><code>raw_data &lt;- readRDS(url(&quot;https://osf.io/awz3d/download&quot;))</code></pre>
<p>Mit <code>head</code> können wir uns wie gewohnt die ersten 6 Zeilen des Datensatzes anschauen.</p>
<pre class="r"><code>head(raw_data)</code></pre>
<pre><code>##       FFMQ.obs    FFMQ.des    FFMQ.aw    FFMQ.nj     FFMQ.nr     PHQ8_1
## 176  0.3067478  1.79571268 -1.7452668  0.4913721  0.83620916  0.9014022
## 177 -0.6750700 -1.68548010  0.2927406 -0.7290201 -0.17361531  1.9346512
## 178 -0.1328100 -0.81038081 -0.5246719 -0.2616628 -0.89540458  1.9346512
## 179  0.2398591  0.08341658 -0.1104417 -0.4186422 -0.08913244 -0.1318469
## 180  0.2398591  0.92071465  0.7069709  0.3343926  0.42022136 -0.1318469
## 181  0.4357006 -0.84818204  0.1020567 -1.1963775  0.20778590 -0.1318469
##          PHQ8_2     PHQ8_3     PHQ8_4     PHQ8_5      PHQ8_6     PHQ8_7
## 176  0.91147081  0.3521987 -0.4176933  0.6863475 -0.89672924  0.8543800
## 177 -0.09429008 -0.5805206  1.5147671 -1.1895061 -0.89672924 -1.0586341
## 178  1.91723170  1.2849181  1.5147671  1.6242743  1.05422843  1.8108870
## 179 -0.09429008 -0.5805206 -0.4176933 -0.2515793 -0.89672924 -1.0586341
## 180 -1.10005097  0.3521987  0.5485369  0.6863475 -0.89672924 -0.1021271
## 181 -0.09429008 -1.5132400  0.5485369  1.6242743  0.07874959 -1.0586341
##         PHQ8_8
## 176 -0.5906521
## 177  2.1922977
## 178  0.8008228
## 179 -0.5906521
## 180 -0.5906521
## 181  0.8008228</code></pre>
<p>Dabei ist auffällig, dass der Datensatz schon auf rein inhaltliche Items reduziert wurde. Allerdings ist die Benennung durch das Erhebungsinstrument und ein Kürzel bzw. die dazu gehörige Nummer für die Interpretation noch etwas unschön, weshalb wir die Bedeutung im folgenden Code als Spaltenname zuordnen. In Voraussicht auf spätere Zeichnungen kürzen wir manche längeren Namen etwas ab.</p>
<pre class="r"><code>names(raw_data) &lt;- c(&quot;observe&quot;, &quot;describe&quot;, &quot;awaren.&quot;, &quot;nonjudg.&quot;,
                     &quot;nonreact.&quot;, &quot;interest&quot;,  &quot;emotions&quot;,  &quot;sleep&quot;,
                     &quot;tired&quot;,  &quot;appetite&quot;, &quot;selfim.&quot;,
                     &quot;concentr.&quot;, &quot;speed&quot;)</code></pre>
<p>Die Variablen <em>observe</em>, <em>describe</em>, <em>awareness</em>, <em>nonjudging</em> und <em>nonreactivity</em> bezeichnen die <strong>fünf Facetten der Achtsamkeit</strong> von Baer et al. (2006), über die <a href="https://pubmed.ncbi.nlm.nih.gov/16443717/">in diesem Paper</a> mehr steht. Die 8 weiteren Variablen beschreiben eine dysfunktionale, meist negative Veränderung in dem bezeichneten Lebensaspekt im Zuge einer <strong>Depression</strong>; so steht <em>interest</em> beispielsweise für einen Interessensverlust, während <em>selfimage</em> ein negatives Selbstbild abbildet.</p>
</div>
<div id="netzwerkschätzung" class="section level2">
<h2>Netzwerkschätzung</h2>
<p>Es gibt in <code>R</code> einige Pakete, die sich mit der Netzwerkanalyse auseinandersetzen. In der Psychologie ist wohl das <code>bootnet</code>-Paket aktuell das meist verwendete. Dieses vereint einige vorher entwickelte Pakete und ist dadurch für verschiedene Fragestellungen einsetzbar. Vor der ersten Verwendung muss das Paket natürlich installiert werden - die vorher entwickelten Pakete werden als Dependencies automatisch mit installiert.</p>
<pre class="r"><code>install.packages(&quot;bootnet&quot;)</code></pre>
<p>Anschließend müssen wir das Paket zur Verwendung natürlich noch aktivieren.</p>
<pre class="r"><code>library(bootnet)</code></pre>
<pre><code>## Warning: Paket &#39;bootnet&#39; wurde unter R Version 4.1.1 erstellt</code></pre>
<pre><code>## Lade nötiges Paket: ggplot2</code></pre>
<pre><code>## Warning: Paket &#39;ggplot2&#39; wurde unter R Version 4.1.1 erstellt</code></pre>
<pre><code>## Registered S3 methods overwritten by &#39;BDgraph&#39;:
##   method    from
##   plot.sim  huge
##   print.sim huge</code></pre>
<pre><code>## This is bootnet 1.4.3</code></pre>
<pre><code>## For questions and issues, please see github.com/SachaEpskamp/bootnet.</code></pre>
<p>Die Schätzung von Netzwerken funktioniert in dem Paket fast ausschließlich durch die Sammelfunktion <code>estimateNetwork</code>. In ihr können durch Argumente verschiedene Netzwerkanalysen durchgeführt werden, wie wir im weiteren Verlauf sehen werden.</p>
<p>Starten wir zunächst mit der einfachsten Berechnung von Zusammenhänge, die wir für intervallskalierte Variablen kennen gelernt haben - die Produkt-Moment-Korrelation. Wenn wir eine Netzwerkstruktur erstellen wollen, indem das Gewicht der Kanten der Korrelation zwischen den zugehörigen Knoten entspricht, muss das Argument <code>default</code> mit <code>"cor"</code> gefüllt werden. Weiterhin muss natürlich der Datensatz mit aufgeführt werden, für den die Schätzung durchgeführt werden soll. Wir weisen dieses Netzerk dem Objekt <code>cor_net</code> zu und betrachten das <code>summary</code>.</p>
<pre class="r"><code>cor_net &lt;- estimateNetwork(raw_data, default = &quot;cor&quot;)</code></pre>
<pre><code>## Estimating Network. Using package::function:
##   - psych::corr.p for significance thresholding</code></pre>
<pre class="r"><code>summary(cor_net)</code></pre>
<pre><code>## 
## === Estimated network ===
## Number of nodes: 13 
## Number of non-zero edges: 78 / 78 
## Mean weight: 0.1274807 
## Network stored in object$graph 
##  
## Default set used: cor 
##  
## Use plot(object) to plot estimated network 
## Use bootnet(object) to bootstrap edge weights and centrality indices 
## 
## Relevant references:
## 
##      Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2016). Estimating psychological networks and their accuracy: a tutorial paper. arXiv preprint, arXiv:1604.08462.</code></pre>
<p>Bei der Schätzung erhalten wir zunächst eine Warning Message, die wir aber nicht weiter betrachten müssen. Im <code>summary</code> sind einige Informationen abgetraten. Über das Netzwerk wird dabei ausgesagt, dass es 13 Knoten gibt. Weiterhin wird angezeigt, dass alle Korrelationen (also die Gewichte der Kanten) nicht gleich 0 sind. Es wird das durchschnittliche Gewicht der Gewichte bestimmt. Wir erhalten zusätzliche einige Hinweise zum weiteren Vorgehen und der Zitation. Dabei konzentrieren wir uns jetzt zunächst erst einmal darauf, das Netzwerk zu zeichnen.</p>
<pre class="r"><code>plot(cor_net)</code></pre>
<p><img src="/post/2021-12-22-Klipps_Netzwerkanalyse_Querschnitt_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Das Paket zeichnet wie wir es bereits gesehen haben positive Beziehungen als blaue Striche. Je stärker das Gewicht einer Kante ist, desto dicker ist die zugehörige Linie . Die Erstellung der Struktur in der Grafik (also an welchem Ord, welcher Knoten passiert wird), wird durch einen Algorithmus berechnet. Das Ziel dabei ist es, Knoten mit starken Verbindungen möglichst eng zu platzieren, welche mit schwächeren Verbindungen weiter entfernt. Die dahinter liegende Mathematik werden wir an dieser Stelle nicht besprechen. Neben dieser Darstellung als Matrix mit Zahlen möglich (in diesem Fall also die Korrelationsmatrix). Diese wird im Objekt abgelegt und kann daher sehr simpel ausgegeben werden.</p>
<pre class="r"><code>cor_net$graph</code></pre>
<pre><code>##             obs         dsc         aw.       nnj.        nnr.        int
## obs   0.0000000  0.23346309 -0.25541487 -0.2222614  0.19805461  0.1969371
## dsc   0.2334631  0.00000000  0.06687903  0.1331660  0.27784544 -0.1011692
## aw.  -0.2554149  0.06687903  0.00000000  0.4450588 -0.05401572 -0.3248143
## nnj. -0.2222614  0.13316604  0.44505878  0.0000000  0.09581370 -0.3692725
## nnr.  0.1980546  0.27784544 -0.05401572  0.0958137  0.00000000 -0.1017167
## int   0.1969371 -0.10116925 -0.32481434 -0.3692725 -0.10171673  0.0000000
## emt   0.1934157 -0.13326343 -0.28714643 -0.4129465 -0.15351137  0.7174187
## slp   0.1731551 -0.09329764 -0.21099657 -0.2782807 -0.10744319  0.4843885
## trd   0.1925480 -0.09036251 -0.33511996 -0.3163092 -0.11603613  0.6694402
## app   0.1885348 -0.01217114 -0.30812835 -0.3289537 -0.14141308  0.5714895
## sl.   0.2188235 -0.11260390 -0.30566888 -0.4617085 -0.14576964  0.5683146
## cn.   0.2444282 -0.05065239 -0.34285231 -0.3092825 -0.10888137  0.6264498
## spd   0.1187273 -0.19014945 -0.31011608 -0.3056252 -0.03571703  0.4512196
##             emt         slp         trd         app        sl.         cn.
## obs   0.1934157  0.17315515  0.19254797  0.18853485  0.2188235  0.24442824
## dsc  -0.1332634 -0.09329764 -0.09036251 -0.01217114 -0.1126039 -0.05065239
## aw.  -0.2871464 -0.21099657 -0.33511996 -0.30812835 -0.3056689 -0.34285231
## nnj. -0.4129465 -0.27828074 -0.31630918 -0.32895373 -0.4617085 -0.30928247
## nnr. -0.1535114 -0.10744319 -0.11603613 -0.14141308 -0.1457696 -0.10888137
## int   0.7174187  0.48438851  0.66944023  0.57148955  0.5683146  0.62644975
## emt   0.0000000  0.47417461  0.63290470  0.55255929  0.6145474  0.56554626
## slp   0.4741746  0.00000000  0.58281105  0.51825404  0.3617876  0.43671632
## trd   0.6329047  0.58281105  0.00000000  0.64236068  0.5473139  0.57256379
## app   0.5525593  0.51825404  0.64236068  0.00000000  0.4617999  0.49424939
## sl.   0.6145474  0.36178756  0.54731393  0.46179987  0.0000000  0.50260557
## cn.   0.5655463  0.43671632  0.57256379  0.49424939  0.5026056  0.00000000
## spd   0.4447632  0.25262260  0.40557975  0.40985862  0.4258437  0.41213178
##              spd
## obs   0.11872732
## dsc  -0.19014945
## aw.  -0.31011608
## nnj. -0.30562521
## nnr. -0.03571703
## int   0.45121961
## emt   0.44476319
## slp   0.25262260
## trd   0.40557975
## app   0.40985862
## sl.   0.42584371
## cn.   0.41213178
## spd   0.00000000</code></pre>
<p>Die Koeffizienten liegen wie immer bei der Korrealtion zwischen -1 und 1. Wir können uns exemplarisch noch die Beziehung der ersten beiden Variablen in der Matrix und im Plot anschauen. Das Gewicht wird als 0.2334631 ausgegeben. Im Plot findet man beide Items am Rand rechts. Sie sind durch einen dünnen (weil kleinerer Wert), blauen (weil positiver Wert) Strich verbunden.</p>
<p>Aus einiger Arbeit mit Korrelationen in multivariaten Settings wissen wir, dass die Einzigartigkeit einer Beziehung durch einfache Korrelationen nicht abgebildet wird. Obwohl zwei Variablen in unserem Plot also verbunden sind, könnten sie eigentlich keinen eigenen Zusammenhang haben, sondern durch eine Drittvariable gesteuert sein. Deshalb betrachtet man für solche Darstellungen üblicherweise nicht Korrelationen. Stattdessen werden die Partialkorrelationen berechnet. Die Gewichte der Kanten sollen die Beziehungen zwischen den Knoten abbilden, nachdem auf alle anderen Informationen im Datensatz kontrolliert wurde.</p>
<p>Für das Vorgehen in <code>R</code> hat diese Verwendung eines anderen Maßes erstmal keine großen Konsequenzen. In <code>default</code> muss jetzt <code>"pcor"</code> angegeben werden. Wir nennen das resultierende Objekt <code>pcor_net</code> und lassen uns wieder das <code>summary</code> ausgeben.</p>
<pre class="r"><code>pcor_net &lt;- estimateNetwork(raw_data, default = &quot;pcor&quot;)</code></pre>
<pre><code>## Estimating Network. Using package::function:
##   - qgraph::qgraph(..., graph = &#39;pcor&#39;) for network computation
##   - psych::corr.p for significance thresholding</code></pre>
<pre class="r"><code>summary(pcor_net)</code></pre>
<pre><code>## 
## === Estimated network ===
## Number of nodes: 13 
## Number of non-zero edges: 78 / 78 
## Mean weight: 0.04296311 
## Network stored in object$graph 
##  
## Default set used: pcor 
##  
## Use plot(object) to plot estimated network 
## Use bootnet(object) to bootstrap edge weights and centrality indices 
## 
## Relevant references:
## 
##      Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2016). Estimating psychological networks and their accuracy: a tutorial paper. arXiv preprint, arXiv:1604.08462.</code></pre>
<p>Der Output verändert seine Struktur dabei nicht, nur die Werte werden für die neue Berechnung angepasst. Weiterhin sind jedoch keine Gewichte von Kanten 0, wozu wir gleich nochmal kommen werden. Zunächst wollen wir uns aber das Netzwerk nochmal zeichnen lassen.</p>
<pre class="r"><code>plot(pcor_net)</code></pre>
<p><img src="/post/2021-12-22-Klipps_Netzwerkanalyse_Querschnitt_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Zunächst sehen wir, dass sich die Struktur geändert hat. Da der Algorithmus nun andere Werte verwendet, platziert er auch die Knoten an anderen Orten.</p>
<div id="regularisierung-und-netzwerkauswahl" class="section level3">
<h3>Regularisierung und Netzwerkauswahl</h3>
<p>Ein Problem der Netzwerkanalyse ist es, dass durch die Fehlervarianz in der Messung eigentlich immer alle Knoten untereinander verbunden sind. Dies führt vor allem bei komplexen Netzwerken mit vielen Knoten dazu, dass die Visualisierung des Netzwerkes unübersichtlich wird und man sich mit Kanten beschäftigt, die keine relevante Beziehung zwischen zwei Knoten darstellen. Um dies zu vermeiden, wird für das Netzwerk der Partialkorrelation eine Regularisierung durchgeführ.</p>
<p>Ein regularisiertes Partialkorrelations-Netzwerk ist eine visualisierte gewichtete Netzwerkstruktur, das durch Regulations-Techniken aus dem Feld des Machine-Learnings geschätzt wird. Daraus resultiert eine sogenannte <strong>sparse network structure</strong> (also eine spärlich besetzte Netzwerkstruktur). Das bedeutet, dass viele der Parameter auf den Kanten exakt 0 sind. Die theoretische Reichweite der bestraften Partialkorrelationen ist dabei weiter zwischen 0 und 1.</p>
<p>Das aktuelle Mittel der Wahl ist die Lasso-Regulation. Diese hat wie beschrieben das Ziel, <strong>falsche</strong> Kanten in ihrer Anzahl zu verringern. Falsche Kanten bedeutet also, dass diese in der Population nicht existieren, aber in der Stichprobe trotzdem keine Partialkorrelationen von 0 vorliegen würden. Regularisierungsmethoden kommen zum Einsatz, da die übliche Signifikanztestung aufgrund der Vielzahl der Kanten problematisch wäre. Die Lasso-Regularisierung hat gegenüber anderen Regularisierungs-Techniken den Vorteil, dass Werte genau 0 sein können. Aufgrund der noch andauernden Entwicklung der Netzwerkanalyse für psychologische Konstrukte gibt es über die Anwendung noch Diskussionen. Jedoch ist das Verfahren mathematisch durchaus etabliert und wird großflächig eingesetzt, weshalb wir es an dieser Stelle präsentieren.</p>
<p>Lasso kommt ursprünglich aus der multiplen Regression / Selektion von Prädiktoren. Überleitung in die Analyse von Grafen (Netzwerke sind eigentlich auch nur Graphen) durch Friedman et al., 2008 - graphical lasso (glasso)</p>
<p><span class="math inline">\(K\)</span>: geschätztes Netzwerk
<span class="math inline">\(S\)</span>: Matrixstruktur des Samples</p>
<p><span class="math display">\[\log det(K) - trace(SK)  -\lambda \sum_{i,j}|k_{ij}|\]</span></p>
<p>Schätzung mit verschiedenen Bestrafungsparametern
meist 100 <span class="math inline">\(\lambda\)</span> in logarithmischer Verteilung</p>
<p>Auswahl der besten Schätzung mit Minimierung des Informationskriteriums EBIC (Foygel &amp; Drton, 2010)</p>
<p>Abschnitt mit Formeln zu Lasso bzw. glasso und der Auswahl durch EBIC</p>
<p><span class="math display">\[ EBIC = -2LL + E \cdot \log(n) + 4 \cdot \gamma \cdot E \cdot \log(p) \]</span></p>
<p><span class="math inline">\(E\)</span>: Anzahl der Elemente der Matrix, die nichtt null sind
<span class="math inline">\(\gamma\)</span>: Hyperparameter der Auswahl - üblicherweise auf 0.5 für moderate Bestrafung größerer Modell 0 wäre explorativer</p>
<p>Nachdem die beiden wichtigen Schritte (Regularisierung und Auswahl) nun theoretisch dargestellt wurden, können wir uns mit der praktischen Umsetzung befassen. <code>bootnet</code> bietet natürlich eine Möglichkeit, beide Schritte in einem durchzuführen. Die Kombination der Bestrafung anhand des grafischen lasso mit der Auswahl des besten Netzwerkes durch EBIC führt zu der Benennung als <code>"EBICglasso</code> in dem Argument <code>default</code> in der bereits bekannten Funktion. Wir legen das Objekt unter <code>reg_net</code> als Netzwerk mit regularisierten Werten ab. Die Anzahl der geschätzten Werte, die anhand ihres EBICs anschließend bewertet werden, kann mit <code>nlambda</code> festgelegt werden. Weiterhin interessant ist das Argument <code>tuning</code>, in dem <span class="math inline">\(\gamma\)</span> als Bestrafungsparameter für Netzwerke mit vielen Edges festgelegt werden kann. Die hier gewählten Werte sind dabei die Standardeinstellungen des Paketes, aber eine Variation ist (wie zum Teil auch beschrieben) durchaus situativ nötig.</p>
<pre class="r"><code>reg_net &lt;- estimateNetwork(raw_data, default = &quot;EBICglasso&quot;,
                           nlambda = 100, tuning = 0.5)</code></pre>
<pre><code>## Estimating Network. Using package::function:
##   - qgraph::EBICglasso for EBIC model selection
##     - using glasso::glasso</code></pre>
<pre><code>## Warning in EBICglassoCore(S = S, n = n, gamma = gamma, penalize.diagonal =
## penalize.diagonal, : A dense regularized network was selected (lambda &lt; 0.1 *
## lambda.max). Recent work indicates a possible drop in specificity. Interpret the
## presence of the smallest edges with care. Setting threshold = TRUE will enforce
## higher specificity, at the cost of sensitivity.</code></pre>
<pre class="r"><code>summary(reg_net)</code></pre>
<pre><code>## 
## === Estimated network ===
## Number of nodes: 13 
## Number of non-zero edges: 54 / 78 
## Mean weight: 0.03944097 
## Network stored in object$graph 
##  
## Default set used: EBICglasso 
##  
## Use plot(object) to plot estimated network 
## Use bootnet(object) to bootstrap edge weights and centrality indices 
## 
## Relevant references:
## 
##      Friedman, J. H., Hastie, T., &amp; Tibshirani, R. (2008). Sparse inverse covariance estimation with the graphical lasso. Biostatistics, 9 (3), 432-441.
##  Foygel, R., &amp; Drton, M. (2010). Extended Bayesian information criteria for Gaussian graphical models. 
##  Friedman, J. H., Hastie, T., &amp; Tibshirani, R. (2014). glasso: Graphical lasso estimation of gaussian graphical models. Retrieved from https://CRAN.R-project.org/package=glasso
##  Epskamp, S., Cramer, A., Waldorp, L., Schmittmann, V. D., &amp; Borsboom, D. (2012). qgraph: Network visualizations of relationships in psychometric data. Journal of Statistical Software, 48 (1), 1-18.
##  Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2016). Estimating psychological networks and their accuracy: a tutorial paper. arXiv preprint, arXiv:1604.08462.</code></pre>
<p>Der Aufbau des <code>summary</code> verändert sich auch im Fall der Regularisierung nicht. Wir sehen allerdings, dass nun nicht mehr alle Gewichte der Kanten ungleich null sind - nur 54 der ursrünglichen 78 haben noch ein solches. Anscheinend wurde ein Netzwerk ausgewählt, in dem manche Kanten als falsch identifiziert wurden. Im abgelegten Objekt <code>reg_net</code> kann man sich unter <code>results</code> diese auch noch genauer anschauen. Unter <code>optnet</code> sind die Gewichte der Kanten abgelegt, die später zum aufzeichnen der Struktur verwendet werden.</p>
<pre class="r"><code>reg_net$results$optnet</code></pre>
<pre><code>##               observe     describe      awaren.     nonjudg.    nonreact.
## observe    0.00000000  0.166635996 -0.112455981 -0.064210464  0.120279093
## describe   0.16663600  0.000000000  0.000000000  0.053792547  0.184887657
## awaren.   -0.11245598  0.000000000  0.000000000  0.274658761 -0.009476879
## nonjudg.  -0.06421046  0.053792547  0.274658761  0.000000000  0.000000000
## nonreact.  0.12027909  0.184887657 -0.009476879  0.000000000  0.000000000
## interest   0.00000000  0.000000000 -0.008306110 -0.007143912  0.000000000
## emotions   0.00000000 -0.009943722  0.000000000 -0.085549714 -0.034081467
## sleep      0.01645887  0.000000000  0.000000000 -0.016629399  0.000000000
## tired      0.00000000  0.000000000 -0.048598933  0.000000000  0.000000000
## appetite   0.01765258  0.000000000 -0.034685093 -0.022566660 -0.034701150
## selfim.    0.04827669  0.000000000  0.000000000 -0.204644007 -0.040229725
## concentr.  0.08130007  0.000000000 -0.080922301  0.000000000  0.000000000
## speed      0.00000000 -0.102393195 -0.095378108 -0.025354316  0.000000000
##               interest     emotions       sleep        tired    appetite
## observe    0.000000000  0.000000000  0.01645887  0.000000000  0.01765258
## describe   0.000000000 -0.009943722  0.00000000  0.000000000  0.00000000
## awaren.   -0.008306110  0.000000000  0.00000000 -0.048598933 -0.03468509
## nonjudg.  -0.007143912 -0.085549714 -0.01662940  0.000000000 -0.02256666
## nonreact.  0.000000000 -0.034081467  0.00000000  0.000000000 -0.03470115
## interest   0.000000000  0.328215474  0.04261040  0.201402370  0.09475036
## emotions   0.328215474  0.000000000  0.06213000  0.123247456  0.08407725
## sleep      0.042610403  0.062130003  0.00000000  0.243721052  0.17015695
## tired      0.201402370  0.123247456  0.24372105  0.000000000  0.25782853
## appetite   0.094750361  0.084077251  0.17015695  0.257828532  0.00000000
## selfim.    0.089100199  0.218062872  0.00000000  0.113293692  0.02334907
## concentr.  0.226661590  0.084354353  0.06402587  0.116453004  0.05843849
## speed      0.082618845  0.071390648  0.00000000  0.008733832  0.10041545
##               selfim.   concentr.        speed
## observe    0.04827669  0.08130007  0.000000000
## describe   0.00000000  0.00000000 -0.102393195
## awaren.    0.00000000 -0.08092230 -0.095378108
## nonjudg.  -0.20464401  0.00000000 -0.025354316
## nonreact. -0.04022973  0.00000000  0.000000000
## interest   0.08910020  0.22666159  0.082618845
## emotions   0.21806287  0.08435435  0.071390648
## sleep      0.00000000  0.06402587  0.000000000
## tired      0.11329369  0.11645300  0.008733832
## appetite   0.02334907  0.05843849  0.100415453
## selfim.    0.00000000  0.09135646  0.109372709
## concentr.  0.09135646  0.00000000  0.083957947
## speed      0.10937271  0.08395795  0.000000000</code></pre>
<p>Im Endeffekte ist das aber die selbe Information, die in <code>reg_net$graph</code> abgelegt wird. <code>results</code> ist als Unterpunkt besonders interessant, wenn man sich den Ablauf der Berechnung nochmal klar machen möchte.</p>
<p>Zunächst hat die Funktion 100 Bestrafungsparameter bestimmt. Diese sind unter <code>lambda</code> abgelegt.</p>
<pre class="r"><code>reg_net$results$lambda</code></pre>
<pre><code>##   [1] 0.007174187 0.007515791 0.007873661 0.008248572 0.008641334 0.009052797
##   [7] 0.009483853 0.009935434 0.010408517 0.010904126 0.011423335 0.011967265
##  [13] 0.012537096 0.013134059 0.013759447 0.014414613 0.015100976 0.015820020
##  [19] 0.016573303 0.017362453 0.018189179 0.019055271 0.019962602 0.020913136
##  [25] 0.021908931 0.022952141 0.024045024 0.025189946 0.026389384 0.027645935
##  [31] 0.028962317 0.030341379 0.031786107 0.033299626 0.034885213 0.036546299
##  [37] 0.038286478 0.040109518 0.042019363 0.044020146 0.046116199 0.048312056
##  [43] 0.050612471 0.053022422 0.055547125 0.058192043 0.060962901 0.063865695
##  [49] 0.066906708 0.070092522 0.073430030 0.076926456 0.080589367 0.084426691
##  [55] 0.088446731 0.092658189 0.097070178 0.101692248 0.106534401 0.111607116
##  [61] 0.116921373 0.122488672 0.128321063 0.134431167 0.140832208 0.147538039
##  [67] 0.154563174 0.161922816 0.169632893 0.177710091 0.186171891 0.195036605
##  [73] 0.204323420 0.214052434 0.224244701 0.234922282 0.246108283 0.257826914
##  [79] 0.270103537 0.282964720 0.296438298 0.310553431 0.325340666 0.340832007
##  [85] 0.357060979 0.374062707 0.391873984 0.410533359 0.430081214 0.450559855
##  [91] 0.472013601 0.494488884 0.518034345 0.542700940 0.568542054 0.595613612
##  [97] 0.623974202 0.653685203 0.684810916 0.717418704</code></pre>
<p>Der größte Bestrafungsparameter ist der letzte Eintrag in der Matrix. Für diesen sollten alle Gewichte der Kanten auf 0 herunter regularisiert worden sein.</p>
<p>Die Strukturen aller 100 bestraften Netzwerke sind unter <code>reg_net$results$results$wi</code>. Beispielsweise ist das komplett leere Netzwerke (also mit dem größten Bestrafungsparameter <span class="math inline">\(lambda\)</span>) als 100. Objekt abgelegt.</p>
<pre class="r"><code>reg_net$results$results$wi[,,100]</code></pre>
<pre><code>##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
##  [1,]    1    0    0    0    0    0    0    0    0     0     0     0     0
##  [2,]    0    1    0    0    0    0    0    0    0     0     0     0     0
##  [3,]    0    0    1    0    0    0    0    0    0     0     0     0     0
##  [4,]    0    0    0    1    0    0    0    0    0     0     0     0     0
##  [5,]    0    0    0    0    1    0    0    0    0     0     0     0     0
##  [6,]    0    0    0    0    0    1    0    0    0     0     0     0     0
##  [7,]    0    0    0    0    0    0    1    0    0     0     0     0     0
##  [8,]    0    0    0    0    0    0    0    1    0     0     0     0     0
##  [9,]    0    0    0    0    0    0    0    0    1     0     0     0     0
## [10,]    0    0    0    0    0    0    0    0    0     1     0     0     0
## [11,]    0    0    0    0    0    0    0    0    0     0     1     0     0
## [12,]    0    0    0    0    0    0    0    0    0     0     0     1     0
## [13,]    0    0    0    0    0    0    0    0    0     0     0     0     1</code></pre>
<p>Für jede dieser Strukturen hat die Funktion dann automatisch den EBIC mitbestimmt. Diese sind unter <code>ebic</code> abgelegt.</p>
<pre class="r"><code>reg_net$results$ebic</code></pre>
<pre><code>##   [1] 3848.108 3848.427 3848.777 3849.158 3838.489 3838.935 3839.423 3839.954
##   [9] 3840.534 3841.166 3841.855 3842.605 3843.423 3833.215 3823.006 3823.908
##  [17] 3813.751 3803.658 3782.561 3783.647 3773.731 3763.672 3764.778 3765.982
##  [25] 3756.104 3757.257 3758.513 3759.878 3761.364 3751.870 3753.366 3754.994
##  [33] 3756.763 3758.688 3760.778 3763.050 3765.516 3768.195 3737.815 3740.574
##  [41] 3743.572 3746.827 3750.361 3731.498 3723.963 3716.634 3709.605 3713.964
##  [49] 3718.702 3712.578 3717.820 3723.517 3729.707 3736.431 3743.737 3751.674
##  [57] 3749.210 3758.522 3768.637 3779.626 3791.566 3793.409 3796.310 3788.930
##  [65] 3804.667 3810.438 3828.706 3836.553 3846.066 3868.504 3893.019 3897.005
##  [73] 3912.586 3930.102 3961.161 3983.920 3996.667 4022.143 4049.351 4068.050
##  [81] 4100.386 4125.118 4176.429 4209.728 4256.744 4321.919 4384.476 4417.105
##  [89] 4488.278 4542.934 4574.671 4642.817 4718.780 4791.972 4839.630 4903.552
##  [97] 4964.138 4972.465 4985.504 4992.000</code></pre>
<p>Der niedrigste dieser Werte hat für die Funktion den Ausschlag gegeben, welche Matrix als Struktur für das optimale Netzwerk ausgewählt wurde.</p>
<p>Zur Veranschaulichung des Einfluss von <span class="math inline">\(\gamma\)</span> ziehen wir hier nochmal einen Verlgeich mit einem größeren Parameter in <code>tuning</code> von 2.</p>
<pre class="r"><code>reg_net2 &lt;- estimateNetwork(raw_data, default = &quot;EBICglasso&quot;,
                           nlambda = 100, tuning = 2)</code></pre>
<pre><code>## Estimating Network. Using package::function:
##   - qgraph::EBICglasso for EBIC model selection
##     - using glasso::glasso</code></pre>
<pre class="r"><code>summary(reg_net2)</code></pre>
<pre><code>## 
## === Estimated network ===
## Number of nodes: 13 
## Number of non-zero edges: 48 / 78 
## Mean weight: 0.03710894 
## Network stored in object$graph 
##  
## Default set used: EBICglasso 
##  
## Use plot(object) to plot estimated network 
## Use bootnet(object) to bootstrap edge weights and centrality indices 
## 
## Relevant references:
## 
##      Friedman, J. H., Hastie, T., &amp; Tibshirani, R. (2008). Sparse inverse covariance estimation with the graphical lasso. Biostatistics, 9 (3), 432-441.
##  Foygel, R., &amp; Drton, M. (2010). Extended Bayesian information criteria for Gaussian graphical models. 
##  Friedman, J. H., Hastie, T., &amp; Tibshirani, R. (2014). glasso: Graphical lasso estimation of gaussian graphical models. Retrieved from https://CRAN.R-project.org/package=glasso
##  Epskamp, S., Cramer, A., Waldorp, L., Schmittmann, V. D., &amp; Borsboom, D. (2012). qgraph: Network visualizations of relationships in psychometric data. Journal of Statistical Software, 48 (1), 1-18.
##  Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2016). Estimating psychological networks and their accuracy: a tutorial paper. arXiv preprint, arXiv:1604.08462.</code></pre>
<p>Das gewählte Netzwerk hätte jetzt noch 48 Kanten, die ein Gewicht ungleich 0 aufweisen würden. Natürlich ist <code>tuning = 2</code> ein unrealitisch hoher Wert, da dieser wie empfohlen stets zwischen 0 und 0.5 liegen sollte. Mathematisch macht dies jedoch keinen Unterschied und das Beispiel demonstriert seinen Zweck sehr gut: Ein höherer Bestrafungsparameter führt dazu, dass ein Netzwerk mit weniger Gewichten unterschiedlich von 0 ausgewählt wird. Bei anderen Netzwerkkonstellationen wird dort auch ein Unterschied zwischen der Wahl von 0 oder 0.5 vorliegen.</p>
<p>ZEICHNEN</p>
</div>
</div>
<div id="zentralitätsindizes" class="section level2">
<h2>Zentralitätsindizes</h2>
<p>Nachdem durch die eben durchgeführte Analyse ein Netzwerk für die Präsentation ausgewählt und auch gezeichnet wurde, stellt sich die Frage, welche weiteren Aussagen durch die Netzwerkanalyse durchführbar sind. In den technischen und sozialen Netzwerken wurde dafür die Zentralität der Knoten untersucht. Darin wird durch verschiedene Facetten aufgezeigt, welcher Knoten im Netzwerk am meisten Einfluss hat. Die Aktivierung dieser Knoten sollte zu einer (De-)Aktivierung anderer, verbundener Knoten im Netzwerk führen. Die Herangehensweise wurde mit kleinen Anpassungen für die Psychologischen Netzwerke übernommen. Die Anwendung steht aktuell in der Kritik aufgrund von instabiler Schätzung und der Frage der inhaltlichen Relevanz. Da diese Diskussion jedoch nicht abgeschlossen ist und die Indizes noch breitflächig zum Einsatz kommen, werden wir die wichtigen Werte auch an dieser Stelle besprechen und berechnen.</p>
<p>Die Zentralität eines Knoten ist hoch, wenn er starke oder viele Verbindungen hat, alle anderen Knoten schnell erreichbar sind oder durch ihn viele Verbindungen zwischen anderen Knoten gehen. Im Folgenden werden die <strong>Zentralitäts-Indices</strong> beschrieben und berechnet, die diese Eigenschaften repräsentieren. Während <code>bootnet</code> später wieder zum Einsatz kommt, ist es für die einfache Berechnung der Indizes nicht geeignet, weshalb wir das Paket <code>qgraph</code> aktivieren müssen. Dieses ist bei der Installation von <code>bootnet</code> mitinstalliert worden.</p>
<pre class="r"><code>library(qgraph)
centrality(graph = reg_net$graph)</code></pre>
<pre><code>## $OutDegree
##   observe  describe   awaren.  nonjudg. nonreact.  interest  emotions     sleep 
## 0.6272698 0.5176531 0.6644822 0.7545498 0.4236560 1.0808093 1.1010530 0.6157325 
##     tired  appetite   selfim. concentr.     speed 
## 1.1132789 0.8986216 0.9376854 0.8874701 0.6796151 
## 
## $InDegree
##   observe  describe   awaren.  nonjudg. nonreact.  interest  emotions     sleep 
## 0.6272698 0.5176531 0.6644822 0.7545498 0.4236560 1.0808093 1.1010530 0.6157325 
##     tired  appetite   selfim. concentr.     speed 
## 1.1132789 0.8986216 0.9376854 0.8874701 0.6796151 
## 
## $Closeness
##     observe    describe     awaren.    nonjudg.   nonreact.    interest 
## 0.005282556 0.004843930 0.006055483 0.006182980 0.003986181 0.006994537 
##    emotions       sleep       tired    appetite     selfim.   concentr. 
## 0.006430293 0.005165385 0.006366562 0.005770949 0.007073668 0.006762420 
##       speed 
## 0.006578120 
## 
## $Betweenness
##   observe  describe   awaren.  nonjudg. nonreact.  interest  emotions     sleep 
##        16        12         8        12         0        12         6         0 
##     tired  appetite   selfim. concentr.     speed 
##        26        12        26        14        22 
## 
## $InExpectedInfluence
##     observe    describe     awaren.    nonjudg.   nonreact.    interest 
##  0.27393686  0.29297928 -0.11516464 -0.09764716  0.18667753  1.04990922 
##    emotions       sleep       tired    appetite     selfim.   concentr. 
##  0.84190315  0.58247374  1.01608101  0.71471578  0.44793796  0.72562549 
##       speed 
##  0.23336382 
## 
## $OutExpectedInfluence
##     observe    describe     awaren.    nonjudg.   nonreact.    interest 
##  0.27393686  0.29297928 -0.11516464 -0.09764716  0.18667753  1.04990922 
##    emotions       sleep       tired    appetite     selfim.   concentr. 
##  0.84190315  0.58247374  1.01608101  0.71471578  0.44793796  0.72562549 
##       speed 
##  0.23336382 
## 
## $ShortestPathLengths
##             observe  describe   awaren.  nonjudg. nonreact.  interest  emotions
## observe    0.000000  6.001104  8.892368 12.533250  8.313997 16.711975 19.758754
## describe   6.001104  0.000000 14.893473 18.534354  5.408690 21.870050 23.495156
## awaren.    8.892368 14.893473  0.000000  3.640881 17.206365 16.160028 13.113249
## nonjudg.  12.533250 18.534354  3.640881  0.000000 20.847247 12.519147  9.472368
## nonreact.  8.313997  5.408690 17.206365 20.847247  0.000000 25.025972 28.072751
## interest  16.711975 21.870050 16.160028 12.519147 25.025972  0.000000  3.046779
## emotions  19.758754 23.495156 13.113249  9.472368 28.072751  3.046779  0.000000
## sleep     24.990318 25.601828 21.457084 17.816203 31.010518  9.068236 12.115015
## tired     20.887267 23.603447 17.354033 13.713151 29.012137  4.965185  8.011964
## appetite  24.765814 19.724901 20.443213 17.591698 25.133590  8.843732 11.890511
## selfim.   17.419784 18.909323  8.527416  4.886534 24.318013  7.632612  4.585833
## concentr. 12.300112 18.301216 12.357533 15.832668 20.614109  4.411864  7.458642
## speed     15.767378  9.766274 10.484586 14.029583 15.174964 12.103776 13.728882
##               sleep     tired  appetite   selfim. concentr.     speed
## observe   24.990318 20.887267 24.765814 17.419784 12.300112 15.767378
## describe  25.601828 23.603447 19.724901 18.909323 18.301216  9.766274
## awaren.   21.457084 17.354033 20.443213  8.527416 12.357533 10.484586
## nonjudg.  17.816203 13.713151 17.591698  4.886534 15.832668 14.029583
## nonreact. 31.010518 29.012137 25.133590 24.318013 20.614109 15.174964
## interest   9.068236  4.965185  8.843732  7.632612  4.411864 12.103776
## emotions  12.115015  8.011964 11.890511  4.585833  7.458642 13.728882
## sleep      0.000000  4.103051  5.876927 12.929668 12.690206 15.835554
## tired      4.103051  0.000000  3.878547  8.826617  8.587155 13.837173
## appetite   5.876927  3.878547  0.000000 12.705163 12.465702  9.958627
## selfim.   12.929668  8.826617 12.705163  0.000000 10.946133  9.143049
## concentr. 12.690206  8.587155 12.465702 10.946133  0.000000 11.910725
## speed     15.835554 13.837173  9.958627  9.143049 11.910725  0.000000
## 
## $ShortestPaths
##           observe describe awaren. nonjudg. nonreact. interest emotions sleep
## observe   NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## describe  NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## awaren.   NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## nonjudg.  NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## nonreact. NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## interest  NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## emotions  NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## sleep     NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## tired     NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## appetite  NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## selfim.   NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## concentr. NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
## speed     NULL    NULL     NULL    NULL     NULL      NULL     NULL     NULL 
##           tired appetite selfim. concentr. speed
## observe   NULL  NULL     NULL    NULL      NULL 
## describe  NULL  NULL     NULL    NULL      NULL 
## awaren.   NULL  NULL     NULL    NULL      NULL 
## nonjudg.  NULL  NULL     NULL    NULL      NULL 
## nonreact. NULL  NULL     NULL    NULL      NULL 
## interest  NULL  NULL     NULL    NULL      NULL 
## emotions  NULL  NULL     NULL    NULL      NULL 
## sleep     NULL  NULL     NULL    NULL      NULL 
## tired     NULL  NULL     NULL    NULL      NULL 
## appetite  NULL  NULL     NULL    NULL      NULL 
## selfim.   NULL  NULL     NULL    NULL      NULL 
## concentr. NULL  NULL     NULL    NULL      NULL 
## speed     NULL  NULL     NULL    NULL      NULL</code></pre>
<p><strong>Grad der Zentralität</strong> <em>(eng: degree)</em>: Die Anzahl von Verbindungen eines Knoten zu anderen Knoten im Netzwerk. Dieser Wert ist besonders in ungewichteten Netzwerken von Interesse. Wenn Gewichte mit im Spiel sind, wird häufig die <strong>Stärke</strong> des Knoten <em>(eng: strength)</em> betrachtet. Die aufsummierte und gewichteten Werte aller Kanten eines Knoten zu allen anderen im Netzwerk vorhandenen Knoten. Durch Kenntnis über die Stärke einer Node können weitere Informationen über die Zentralität der Node ausgesagt werden, zum Beispiel: Eine Node mit einem hohen Grad der Zentralität und einer niedrigen Stärke kann weniger zentral in einem Netzwerk sein als eine Node mit einem niedrigeren Grad der Zentralität und einer hohen Stärke.</p>
<p><strong>Verbundenheit</strong> <em>(eng: closeness)</em>: Die Verbundenheit einer Node quantifiziert ihre Beziehungen im Netzwerk anhand ihrer indirekten Verbindungen mit anderen Nodes. Hohe Verbundenheit, zum Beispiel, charakterisiert im Mittel eine kurze Distanz von einer Node zu anderen Nodes. Nodes mit hoher Verbundenheit sind leicht von Veränderungen in einem beliebigen Part des Netzwerks betroffen und beeinflussen im Gegenzug leicht andere Nodes</p>
<p><strong>Dazwischenheit</strong> <em>(eng: betweenness)</em>: Die Dazwischenheit einer Node gibt Informationen über die Wichtigkeit einer Node im Rahmen der durchschnittlich zurückgelegten Weges zwischen ihr und anderen Nodes im Netzwerk. Die Node mit dem kürzesten Weg zwischen zwei anderen Nodes, also einer hohen “Dazwischenheit”, hat beispielsweise besonderen Einfluss auf die Verbindung jener anderen Nodes.</p>
</div>
<div id="fazit" class="section level2">
<h2>Fazit</h2>
<p>Die Netzwerkanalyse für psychologisch Konstrukte ist ein sich noch entwickelndes Gebiet. Sie wird kein Ersatz der typischen latenten Modelle sein können, für die Visualisierung und spezifischere Betrachtung der Dynamik zwischen Symptomen aber in jedem Fall hilfreich sein. Die genaue Vorgehensweise der Schätzung und Interpretation sind aktuell ein Thema der methodischen Forschung. Im Paket <code>bootnet</code> sind dabei stets aktuelle Ansätze auffindbar. Es ist dabei auch sehr verständlich geschrieben und dient einem nutzerfreundlichen Einstieg.</p>
<hr />
</div>
<div id="literatur" class="section level2">
<h2>Literatur</h2>
<p><a href="https://hds.hebis.de/ubffm/Record/HEB36808809X">Döring, N., &amp; Bortz, J. (2016)</a>. Meta-Analyse. In <em>Forschungsmethoden und Evaluation in den Sozial- und Humanwissenschaften</em> (pp. 893-943). Springer, Berlin, Heidelberg.</p>
<p><a href="https://hds.hebis.de/ubffm/EBSCO/Record?id=edsbas.37032030%7Cedsbas">López-López, J. A., Davies, S. R., Caldwell, D. M., Churchill, R., Peters, T. J., Tallon, D., Dawson, S., Wu, Q., Li, J., Taylor, A., Lewis, G., Kessler, D. S., Wiles, N., &amp; Welton, N. J. (2019).</a> The process and delivery of CBT for depression in adults: A systematic review and network meta-analysis. <em>Psychological Medicine, 49</em>(12), 1937–1947. <a href="https://doi.org/10.1017/S003329171900120X">https://doi.org/10.1017/S003329171900120X</a></p>
<p><a href="https://hds.hebis.de/ubffm/EBSCO/Record?id=edsbas.B90C267A%7Cedsbas">Viechtbauer, W. (2010).</a> Conducting meta-analyses in R with the metafor package. <em>Journal of Statistical Software</em>, <em>36</em>(3), 1–48. <a href="https://www.jstatsoft.org/v036/i03" class="uri">https://www.jstatsoft.org/v036/i03</a>.</p>
<ul>
<li><small> <em>Blau hinterlegte Autorenangaben führen Sie direkt zur universitätsinternen Ressource.</em></li>
</ul>
</div>
