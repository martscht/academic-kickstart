---
title: SmartGit
date: '2021-08-01'
slug: smartgit
categories:
  - "gitintro"
tags: []
subtitle: ''
summary: ''
authors: [nehler, schloter, rouchi]
featured: no
header:
  image: "/header/smartgit.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/282666)"
projects: []
publishDate: '2021-08-12'
---

# Warum <span style="color: darkred;">**SmartGit**</span>?

Da das Terminal nicht die beste optische Repräsentation aller Möglichkeiten von <span style="color: darkred;">**Git**</span> bietet, wollen wir uns in diesem Tutorial mit <span style="color: darkred;">**SmartGit**</span> beschäftigen. Dieses bietet uns eine benutzerfreundlichere, anschaulichere  Oberfläche, mit der wir problemlos <span style="color: darkred;">**Git**</span>-Befehle ausführen können. Wir wollen uns hierbei zunächst anschauen, wie unsere bereits gelernten Befehle in <span style="color: darkred;">**SmartGit**</span> funktionieren. Anschließend werden wir noch weitere Möglichkeiten und Befehle kennen lernen.

## Einführung

<span style="color: darkred;">**SmartGit**</span> ist wie bereits geschildert eine grafische Oberfläche für die Verwendung von <span style="color: darkred;">**Git**</span> auf dem lokalen Rechner - aber auch in Verbindung mit **remote repositories** (also bspw. gehostet auf <span style="color: darkred;">**Github**</span>) . Das Programm existiert bereits seit 2009 und wurde stets weiterentwickelt, wodurch eine reibungslose Funktionsweise sichergestellt ist. Durch Ausführen von <span style="color: darkred;">**Git**</span>-Befehlen via Klick wird die Arbeit beschleunigt. Andere Befehle werden sogar automatisiert durchgeführt. Ein großer Vorteil von <span style="color: darkred;">**SmartGit**</span> ist dabei, dass es auch mit anderen Providern für **remote repositories** wie <span style="color: darkred;">**Bitbucket**</span> oder <span style="color: darkred;">**GitLab**</span> integrativ arbeiten kann, wobei wir uns im Tutorial weiterhin nur mit <span style="color: darkred;">**GitHub**</span> beschäftigen werden.

# Setup

Damit ihr <span style="color: darkred;">**SmartGit**</span> auf euren Rechnern verwenden könnt, müsst ihr zunächst das Programm herunterladen. Dies könnt ihr [hier](https://www.syntevo.com/smartgit/) für verschiedene Betriebssysteme machen. Auf der Website gibt es auch **Installation Instructions** für die verschiedenen Betriebssysteme. 


Bei den Einstellungen für <span style="color: darkred;">**SmartGit**</span> müsst ihr den Nutzungsbedingungen zustimmen und unter *License type* außerdem auswählen, dass ihr das Programm für "Non-commercial use only", also wissenschaftliche Zwecke verwendet, sodass ihr nicht für die Nutzung zahlen müsst. 

![](/post/smartgit_license.png)

Dies muss in einem zweiten Fenster noch einmal bestätigt werden. Als nächstes müsst ihr euch unter *User Information* einen Nutzernamen geben sowie eine E-Mail-Adresse angeben, über die ihr euer <span style="color: darkred;">**SmartGit**</span> konfiguriert. <span style="color: darkred;">**SmartGit**</span> sollte die Informationen aus eurer eigenen Konfiguration auf dem lokalen PC ziehen können und daher bereits anzeigen, welche E-Mail und welcher Name hinterlegt sind. Ansonsten gebt ihr am besten selbst Nutzernamen und die E-Mail-Adresse an, mit denen ihr <span style="color: darkred;">**Git**</span> auf dem Rechner konfiguriert habt! 

![](/post/smartgit_information.png)


Jetzt müsst ihr noch die Option *Use SmartGit as SSH client* auswählen. Dies ist für den Start der Arbeit mit <span style="color: darkred;">**SmartGit**</span> empfohlen. 

![](/post/smartgit_sshclient.png)

Anschließend werden wir nach dem bevorzugten Style der Oberfläche von <span style="color: darkred;">**SmartGit**</span> gefragt. Hier gibt es natürlich kein Richtig oder Falsch und es gibt auch nicht direkt eine Empfehlung für Anfänger:innen. Die Ansicht des **Working Tree** wird von uns allerdings als intuitiver eingeschätzt und deshalb verwendet. Wie im Fenster beschrieben, kann diese Einstellung später auch unter *Präferenz* geändert werden. 

![](/post/smartgit_style.png)

Unter **Privacy** kann man bestimmen, in welchen Fällen Daten an die Ersteller:innen gesendet werden, die diese zur Verbesserung des Programmes nutzen wollen. Hier möchten wir keine Empfehlung aussprechen - man kann nach persönlicher Präferenz auswählen. Außerdem sucht <span style="color: darkred;">**SmartGit**</span> auf dem Rechner nach initialisierten Repositories und gibt in diesem Fenster die Anzahl an.

![](/post/smartgit_privacy.png)

Sobald ihr <span style="color: darkred;">**SmartGit**</span> installiert habt und das Programm öffnet, werdet ihr gefragt, ob ihr ein lokales Repository öffnen oder neu erstellen wollt, oder aber ob ihr ein bereits bestehendes `clonen` möchtet. Wenn bereits Repositories auf dem Rechner bestehen, werden diese hier unter *Reopen previously used repository* angezeigt. Diesen Punkt wählen wir daher auch aus. Dabei wollen wir natürlich an unserem Ordner Praktikum arbeiten.


![](/post/smartgit_welcome.png)


Nun ist die Installation abgeschlossen und wir können uns die Oberfläche des Programms und die Nutzung genauer anschauen!


# Basics

Jetzt wo wir <span style="color: darkred;">**SmartGit**</span> erfolgreich installiert und unseren Praktikums-Ordner als Repository gefunden haben, stellt sich die Frage, wofür und wie wir <span style="color: darkred;">**SmartGit**</span> am besten verwenden. Hierzu betrachten wir, wo wir unsere bereits erlernten <span style="color: darkred;">**Git**</span>-Befehle umsetzen können.

### Benutzeroberfläche

Zur Orientierung schauen wir uns jedoch zunächst die Oberfläche von <span style="color: darkred;">**SmartGit**</span> genauer an. Diese haben wir durch die Auswahl eines bestimmten Styles hergestellt.

![](/post/smartgit_style_workingtree.png)

In der oberen Zeile befinden sich zunächst Symbole mit bekannten Begriffen wie `pull` und `commit`. Diese Werkzeuge werden wir gleich brauchen. Auf der linken Seite sehen wir unsere Repositories - theoretisch können wir hier alle reinladen, an denen wir uns beteiligen. Wenn ihr dem Tutorial Stück für Stück bis hierhin gefolgt seid, sollte einmal das "dummy"- und das "praktikum"-Repository hier erscheinen. Darunter sehen wir die verschiedenen **Branches** eines Projekts - mit diesen beschäftigen wir uns erst im nächsten Teil des Tutorials. 

In der Mitte des Bildschirms sehen wir die Kachel **Files**. Hierin werden alle Dateien angezeigt, die entweder noch nicht getracked werden, verändert, gelöscht oder umbenannt wurden. Für Praktikum ist hier die <span style="color: darkred;">**R**</span>-History zu sehen, die <span style="color: darkred;">**R**</span> automatisch erstellt, aber für uns keinen Wert hat. Diese ist im normalen Explorer und Terminal versteckt, wird aber hier angezeigt.

In der Kachel **Changes** werden die Veränderungen an einer Datei angezeigt, wenn Sie unter **Files** ausgewählt ist. Das demonstrieren wir gleich noch einmal mit einem Screenshot. In der Kachel **Journal** sind alle `commits` der Historie aufgeführt. 

Um die Arbeit mit <span style="color: darkred;">**SmartGit**</span> zu simulieren, müssen wir natürlich wieder Änderungen an den Dateien vornehmen. Dafür öffnen wir das Datenauswertungsskript aus unserem Ordner und ergänzen darin beispielsweise eine Häufigkeitstabelle für den Gesamtscore. Wichtig ist, dass die Änderung auch gespeichert werden muss.

![](/post/Dummy_gitAuswertung_fifth.png)

Durch die Änderung der Datei erscheint diese nun in <span style="color: darkred;">**SmartGit**</span> in der Kachel **Files**. Dabei wird sie in rot angezeigt und es steht daneben, dass sie modifiziert wurde. Wenn wir nun einmal auf sie mit Linksklick draufgehen, sehen wir auch nochmal besser, wofür die **Changes**-Kachel da ist. Durch die grüne Markierung der Zeilen 19 und 20 im Code sehen wir, dass diese neu hinzugefügt wurden.

![](/post/smartgit_files_changes.png)

### `Commit`

Nun, da wir eine Datei verändert haben, wollen wir diese Änderung natürlich auch committen. Im Terminal mussten wir dafür erst mit *git add* etwas zum **staging environment** hinzufügen. Das ist über <span style="color: darkred;">**SmartGit**</span> nicht mehr notwendig, bzw. wird durch Klick auf die interessierenden Dateien ersetzt. In der **Files**-Kachel wählen wir mit einem Linksklick alle Dateien aus, die im nächsten `commit` enthalten sein sollen (bei der Auswahl mehrere Dateien wie üblich *strg* gedrückt halten). Anschließend wählen wir in der Werkzeuge-Leiste `commit` aus. Es öffnet sich das `commit`-Fenster, in dem nochmal angezeigt wird, welche Dateien wir ausgewählt haben. Wir möchten nur die Änderung in der Datenauswertung in unserem `commit` haben. Weiterhin müssen wir, wie auch bei der Ausführung im Terminal, eine passende Message zu unserem `commit` hinzufügen.

![](/post/smartgit_commit.png)


Wenn die Nachricht verfasst ist, reicht ein Klick auf *Commit* und die Änderungen wurden angenommen. Lokal sind sie also getracked. Alternativ könnte man hier auch auf *Commit & Push* klicken, dann wird unser lokaler Ordner direkt auf <span style="color: darkred;">**GitHub**</span> gepushed. Dies kann man machen, wenn man sich seiner Änderungen sicher ist. Nur `commit` ist dabei empfehlenswert, wenn man sich unsicher ist und nochmal weiter an den Änderungen arbeiten will - oder für den Fall, dass wir noch weitere Änderungen an anderen Dateien unseres Projekts vornehmen wollen. Aus Demonstrationszwecken drücken wir auf *Commit*. Wenn ihr auf <span style="color: darkred;">**SmartGit**</span> die Kachel **Journal** betrachtet, ist dieser `commit` zwar im **master** enthalten, aber nicht im **origin**. Dies spricht dafür, dass die Änderung im **remote repository** noch angestoßen werden muss. Dies können wir mit einem `push` machen. 


### `Push` & `Pull`

Anstatt eine ganze Zeile in das Terminal eingeben zu müssen, um den Ordner auf <span style="color: darkred;">**GitHub**</span> auf den Stand des lokalen Ordners zu aktualisieren, reicht bei <span style="color: darkred;">**SmartGit**</span> ein einfacher Klick auf *Push*. Zunächst öffnet sich ein Fenster, in dem wir diese Aktion nochmals bestätigen. 

![](/post/smartgit_push.png)

Da wir <span style="color: darkred;">**SmartGit**</span> nun zum ersten Mal mit einem Server interagieren lassen, werden wir nach einem **Master Password** gefragt. Man kann dieses zwar auch überspringen, aber es ist wichtig für den Schutz von Passwörtern in der Interaktion mit Servern, weshalb wir eine Festlegung dringend empfehlen (außerdem gibt es eine Bewegung in die Richtung, dass normale Passwort-Interaktion mit <span style="color: darkred;">**GitHub**</span> in Zukunft nicht mehr möglich ist). Am besten verwendet ihr hier auch nicht das gleiche Passwort, welches ihr bei <span style="color: darkred;">**GitHub**</span> verwendet habt. 

![](/post/smartgit_master_password.png)

Einmal muss die Rechtmäßigkeit des Zugriffs auf den Server nun aber mit euren <span style="color: darkred;">**GitHub**</span>-Informationen bestätigt werden. Falls ihr 
euer Passwort richtig eingegeben habt, aber dennoch eine Fehlermeldung kommt, braucht
ihr ein Personal Access Token. Wie man das generieren kann, steht unter [Appendix A](#AppendixA). 

![](/post/smartgit_github_login.png)

Nun wurde der `push` durchgeführt. Um einen optischen Indikator dafür zu haben, könnt ihr euer Repository auf der <span style="color: darkred;">**GitHub**</span>-Website öffnen. Weiterhin sind man auch in der Kachel **Journal**, dass **_origin_** und **_main_** nun wieder auf derselben Höhe des neuen `commits` sind. 

Damit wir nicht jedes Mal die <span style="color: darkred;">**GitHub**</span>-Informationen eingeben müssen, aktivieren wir den Zugang über das **Master Password**. Dafür wählen wir in der obersten Zeile *Edit* aus und wählen darin *Preferences* aus.

![](/post/smartgit_preferences.png)

Hier gehen wir in der Auswahl auf *Hosting Providers* und drücken dann rechts auf *Add*.

![](/post/smartgit_preferences_hosting.png)

<span style="color: darkred;">**GitHub**</span> ist hier bereits auswählt. Wir wollen nun einen **Token** erstellen. Dafür müssen wir den Button *Generate* drücken. Der Browser sollte sich automatisch öffnen und einen Login zu <span style="color: darkred;">**GitHub**</span> erfordern. Sobald wir diese Informationen eingegeben haben, wird ein Token generiert. Diesen kopieren wir dann in das entsprechende Fenster in <span style="color: darkred;">**SmartGit**</span> und klicken auf *Authenticate*.

![](/post/smartgit_preferences_API.png)

Wir gelangen zurück in das Fenster, wo wir den Token erstellt haben, und klicken auf *Add*. Damit erscheint nun im Fenster der Hosting Providers unser <span style="color: darkred;">**GitHub**</span>-Account und wir können auf *OK* klicken.

![](/post/smartgit_preferences_hosting_two.png)

Beachtet, dass der Vorgang von `push` wirklich simpel über den Klick funktioniert hat. Die Umstellungen für das Passwort mussten wir jetzt nur einmal vornehmen. Ähnlich einfach ist der Vorgang, um unsere lokale Kopie des Repositoyrys auf die Version auf <span style="color: darkred;">**GitHub**</span> zu aktualisieren. Auch hier können wir den Button in der Werkzeug-Leiste nutzen. Nach dem Klick auf *Pull* geht ein Fenster auf, indem man zwischen `Rebase` und `Merge` wählen kann - diese Begriffe sind beide noch unbekannt und wir bleiben bei der Standardeinstellung. Anschließend erscheint das Fenster *Pull*. Hierin wird die URL vom <span style="color: darkred;">**GitHub**</span>- Repository angezeigt - diese müsste stimmen, könnt ihr aber gerne kontrollieren. Anschließend klicken wir auf den uns bekannten Befehl `pull`.

![](/post/smartgit_pull.png)

Es erscheint für eine kurze Zeit ein grüner Kasten, in dem steht, dass der `pull` erfolgreich war. Natürlich wurden gerade aber keine Änderungen an Dateien oder Ähnliches vorgenommen, da der Stand lokal und remote identisch war. Wir simulieren die Änderung einer anderen Person an einer Datei - wie im letzten Tutorial auch - durch eine Veränderung in der <span style="color: darkred;">**GitHub**</span> Version. Dafür öffnen wir das Repository auf <span style="color: darkred;">**GitHub**</span> und klicken auf den Stift, der rechts in der Zeile von **README.md** angezeigt wird. 

Wir wollen eine schnelle Änderung an diesem vornehmen und fügen daher noch eine Zeile ein, in der wir präzisieren, um welche Gruppe es sich bei uns imaginär handelt. In der `commit`-Nachricht beschreiben wir kurz die durchgeführte Änderung und lassen die anderen Optionen auf ihren Standardeinstellungen. Anschließend klicken wir *Commit Changes* und wechseln zurück auf unsere <span style="color: darkred;">**SmartGit**</span>- Anwendung. 

![](/post/smartgit_github_change.png)

In dieser wählen wir jetzt wieder *Pull* in unserem Repository "Praktikum" aus. Zunächst scheint nicht viel anderes zu passieren als bei dem vorherigen `pull`. Wenn man allerdings genau hinschaut, sieht man, dass der letzte `commit` nun am unteren Bildschirmrand im **Journal** angezeigt wird. Wenn man die Datei **README.md** lokal auf dem eigenen Rechner anschaut, werden die neuen Inhalte nun auch angezeigt. 

![](/post/smartgit_pull_change.png)

Bisher haben wir nur mit dem Repository gearbeitet, das automatisch von <span style="color: darkred;">**SmartGit**</span> gefunden wurde. Nun wollen wir noch Fälle betrachten, in dem das Repository nur online besteht oder in dem es noch komplett neu erstellt werden muss.

#### Bereits bestehendes <span style="color: darkred;">**GitHub**</span>-repository mit <span style="color: darkred;">**SmartGit**</span> `clonen`

Wie in den <span style="color: darkred;">**Git**</span>-Funktionen gelernt, kann man ein Repository, das online existiert, auch mit <span style="color: darkred;">**SmartGit**</span> lokal intialisieren. Um euren auf <span style="color: darkred;">**GitHub**</span> geladenen Praktikums-Ordner mit <span style="color: darkred;">**SmartGit**</span> zu verknüpfen, müsst ihr zunächst in der Menüleiste auf *Repository* klicken und dann auf *Clone*. In dem Fenster, was sich daraufhin öffnet, könnt ihr einfach die URL eures repositories (die ihr über <span style="color: darkred;">**GitHub**</span> anfordern könnt) in das entsprechende Feld kopieren. Die hier angegebene URL ist nur ein Platzhalter, um euch die nächste Felder zeigen zu können. Wir haben momentan kein Repository, das nur online und nicht lokal angelegt ist. Die Eingabe muss natürlich noch bestätigt werden. 

![](/post/smartgit_clone_url.png)

Beachtet an dieser Stelle, dass es auch möglich ist, ein lokales Repository nochmal lokal zu `clonen`. Ihr hättet dieses dann zwei Mal. Hierfür müsste man *local repository* auswählen und den Pfad dahin angeben. Dieses Vorgehen hat jedoch nicht viele Anwendungen und wird daher nicht genauer betrachtet. 

Zurück zur Verbindung mit einem Repository auf <span style="color: darkred;">**GitHub**</span>: Nach der Eingabe der URL erscheint ein Dialogfenster, in dem Details über den `clone` abgefragt werden. Diese sind vor allem interessant, wenn mehrere `Branches` in einem Repository existieren, womit wir uns noch nicht beschäftigt haben. Außerdem können größere Daten ausgeschlossen werden, um Speicherplatz zu sparen. Dies trifft uns auch eher selten.

![](/post/smartgit_clone_selection.png)

Nach der Bestätigung der Details könnt ihr einen Ordner auswählen, in den eure Daten von <span style="color: darkred;">**GitHub**</span> geladen werden sollen. Ihr könnt die Standardeinstellung verwenden oder über die Ordneransicht einen Ordner auf eurem Rechner erstellen. 

![](/post/smartgit_clone_place.png)

Nachdem das Cloning abgeschlossen ist, solltet ihr auf der linken Seite eurer <span style="color: darkred;">**SmartGit**</span>-Ansicht den Ordner unter **Repositories** sehen können. Jetzt könntet ihr über <span style="color: darkred;">**SmartGit**</span> mit <span style="color: darkred;">**GitHub**</span> kommunizieren und  Änderungen an den Dateien tracken. Da wir diese Funktionen jetzt nur mal betrachtet und nicht ausgeführt haben, ändert sich in unserer Ansicht natürlich nichts. 

#### Neues `repository` erstellen

Ein neues Repository mit <span style="color: darkred;">**SmartGit**</span> zu erstellen, ist sehr einfach! Dazu müsst ihr in der Menüleiste zunächst auf *Repository* klicken und dann auf *Add or create...*. In dem Fenster, was sich jetzt öffnet, könnt ihr entweder einen Ordner auswählen, den ihr bereits erstellt habt - beispielsweise unseren bekannten Praktikums-Ordner - oder über *Neuer Ordner* einen neuen erstellen. Das Einladen eines bereits existierenden Repositorys kann nötig sein, falls die automatische Erkennung fehlgeschlagen ist oder ihr das Hinzufügen zunächst abgelehnt habt. Dafür würdet ihr einfach den Pfad des Repositorys hier einstellen, was wir jetzt aber nicht betrachten werden. 

![](/post/smartgit_create_rep.png)

In diesem Beispiel erstellen wir in unserem Statistik-Ordner den neuen Ordner "dummy2" und initialisieren diesen als neues Repository. Hierfür wird nochmal eine Bestätigung in einem seperaten Dialogfenster benötigt.

![](/post/smartgit_create_init.png)

Kleine Anmerkung: Diese Initialiserung würde natürlich nicht erscheinen, wenn ihr der Ordner bereits ein <span style="color: darkred;">**Git**</span>-Ordner wäre und nur zur Anzeige in <span style="color: darkred;">**SmartGit**</span> eingeladen werden sollte. 

Nach einem Klick auf *OK* ist euer Repository erstellt und ihr könnt mit nun Dateien erstellen, hinzufügen und mit euren Veränderungen loslegen! Es wird nun auf der linken Seite in der Liste angezeigt. Das Tracking der Dateien wäre momentan natürlich nur lokal. Um eine Verbindung mit <span style="color: darkred;">**GitHub**</span> zu erstellen, muss zunächst äquivalent zu der Beschreibung im Tutorial zu <span style="color: darkred;">**GitHub**</span> ein Repository erstellt werden. Dort wurde bereits empfohlen, dass das neu erstellte Repository zunächst leer ist und denselben Namen wie die lokale Version trägt. Es wird dabei eine URL kreiert, unter der das `repository` zu finden ist. In diesem Fall würde diese so aussehen:

![](/post/smartgit_github_url.png)

Diese solltet ihr nun kopieren und wieder zurück auf <span style="color: darkred;">**SmartGit**</span> wechseln. Dort wählt ihr in der Übersichtsleiste zunächst *Remote* und dann *Add...*. Es erscheint eine Eingabe für die URL, die ihr eben kopiert habt.  

![](/post/smartgit_add_remote.png)

Um die Einrichtung abzuschließen, müsst ihr nun noch einen `push` durchführen. Nachdem dieser abgeschlossen ist, sollte das Repository auch auf <span style="color: darkred;">**GitHub**</span> den **initial commit** anzeigen. Ab diesem Moment werden alle euren lokalen Änderungen durch einen `Push` auf <span style="color: darkred;">**GitHub**</span> abgelegt. 

![](/post/smartgit_github_pushing.png)


#### Änderung des Styles der Oberfläche

Bei der Einrichtung von <span style="color: darkred;">**SmartGit**</span> haben wir uns für einen Style in der Anzeige unserer Repositories entschieden. Zum Abschluss der Basics des Tutorials wollen wir nun noch kurz betrachten, wie wir diese anfängliche Entscheidung ändern können. Dafür wählt ihr in der obersten Zeile zunächst *Edit* und dann *Preferences*. Es öffnet sich ein Fenster, indem wir zunächst *User Interface* in der Übersicht links anklicken. Im rechten Fenster gibt es die Auswahl *Prefer*, bei der momentan **Working Tree** angewählt sein sollte. Stattdessen klicken wir nun auf *Log Graph* und bestätigen die Auswahl (es können natürlich noch weitere Änderungen an der Oberfläche hier durchgeführt werden, aber diese werden wir nicht näher betrachten).

![](/post/smartgit_preferences_loggraph.png)

Beim Erstellen des Tutorials musste <span style="color: darkred;">**SmartGit**</span> nun einmal geschlossen und wieder geöffnet werden, damit die Änderungen sichtbar werden. Es ist eine neue Aufteilung in der Oberfläche zu sehen, wobei die Anzeige der *Repositories* und *Branches* auf der linken Seite bestehen bleibt. 

![](/post/smartgit_loggraph.png)

Im zentralen Fenster **Graph** wird der Workflow - also alle `commits`, die jemals an unserem Projekt durchgeführt wurden - angezeigt. Dabei stehen jeweils die Initialien der Person, die den `commit` durchgeführt hat sowie das Änderungsdatum. So können wir auf einen Blick nachvollziehen, wer wann was an unserem Projekt verändert hat. Beachtet auch, dass nun ganz oben der aktuelle Stand eures Repositorys als **Working Tree** angezeigt wird. In diesem wird eine Änderung angezeigt, da die Datei ".Rhistory" weiterhin im Repository existiert, aber noch nicht in einen `commit` einbezogen wurde.

Auf der rechten Seite des Bildschirms sehen wir mittig eine Übersicht über alle unsere Dateien, die wir seit dem letzten `commit` lokal verändert haben - in diesem Falle die `.Rhistory`. Oben rechts werden Informationen über den Account angegeben, der einen `commit` durchgeführt hat. Am unteren Bildschirmrand ist wieder die Übersicht über Änderungen in Dateien von einem `commit` zu einem anderen. Wem diese Übersicht nun besser gefällt, kann die Einstellung so lassen. Für das weitere Tutorial ändern wir die Einstellung wieder in den **Preferences** und starten <span style="color: darkred;">**SmartGit**</span> wieder neu. 


# Weitere Funktionen

Insgesamt bieten <span style="color: darkred;">**Git**</span> und <span style="color: darkred;">**SmartGit**</span> natürlich noch eine Fülle an anderen Funktionen, was schon die Benutzeroberfläche sehr deutlich macht. Die Besprechung aller Optionen würde den Rahmen sprengen und einige Erklärungen folgen auch noch in weiteren Tutorials. Trotzdem wollen wir hier nochmal einige weitere nützliche Funktionalitäten aufführen.

##### `Discard`

Über `discard`, können wir Änderungen, die wir an den Dateien vorgenommen haben, verwerfen. Wir würden dadurch wieder zu der Version der Datei zurückkehren, die im letzten `commit` enthalten ist. Wichtig ist, dass es somit hier um Änderungen an der Datei geht, die noch nicht in einem `commit` verarbeitet wurden. 

Um das Ganze zu testen, müssen wir zunächst eine Änderung an einer lokalen Datei vornehmen. Beispielsweise fügen wir in unsere Auswertungsdatei eine neue Zeile Code ein.

![](/post/smartgit_discard_filechange2.png)

Die Änderung wird nun in <span style="color: darkred;">**SmartGit**</span> angezeigt, indem die Datei als "Modified" bezeichnet wird. 

![](/post/smartgit_discard_modified.png)

Nun könnten wir die Änderungen in der Datei in einen `commit` packen und dann auch einen `push` durchführen. In diesem Fall gehen wir nun aber davon aus, dass wir bemerken, dass unsere Änderung nicht gut ist und wieder rückgängig gemacht werden sollte. Natürlich könnte man die Datei öffnen und die Zeile einfach wieder raus löschen. Das ist in diesem Fall recht simpel, kann aber bei komplexeren Änderungen sehr langwierig sein. Hier kann man über `discard` nun also sehr schnell zum Stand des letzten `commit` zurückkehren. Der Button für den `discard` ist auch in der Werkzeugsleiste enthalten. Am besten wählt ihr vor dem Klicken die betreffende/n Datei/en bereits aus.

![](/post/smartgit_discard_symbol.png)

Bei der Auswahl gibt es im Dialogfenster dann zwei Unteroptionen:

1. **Discard**: Wenn die Veränderungen nicht mehr benötigt werden, reicht diese Option aus. Hier werden alle Änderungen rückgängig gemacht und die Datei ist wieder auf dem alten Stand des letzten `commits`. 
2. **Discard to Stash**: Hierbei wird die veränderte Datei nicht unwiderruflich gelöscht, sondern dem `Stash` - quasi einem Papierkorb - hinzugefügt. Von hier aus können die veränderten Dateien wieder abgerufen werden, falls man sie doch noch benötigt.

![](/post/smartgit_discard_options.png)

Die bessere Option müsst ihr also von Fall zu Fall selbst wählen. Da es bei der Auswahl von `discard` keine weiteren Schritte geht, gibt es dazu auch keine weitere Aussage und wir wählen im Tutorial jetzt *Discard to Stash*. Es folgt eine kleine Änderung in der <span style="color: darkred;">**SmartGit**</span>-Ansicht und zwar im Fenster zu den **Branches**. Hier erscheint der neue Punkt **Stashes**. Wenn wir auf diesen draufklicken, werden Datum und Uhrzeit angezeigt.

![](/post/smartgit_discard_branches.png)

Mit einem Rechtsklick werden die Optionen zum Umgang mit dem `stash` angezeigt. Man kann sich den Inhalt nochmal mit *Show Content in Log* anschauen oder den Stash mittels *Rename Stash...* umbenennen. Anhand von *Apply Stash...* kann die verworfenen Änderung wieder vorgenommen werden.

![](/post/smartgit_discard_apply.png)

Hier wird nochmal darin unterschieden, ob der `stash` nach dem Wiedereinfügen bestehen bleibt (**Apply**) oder ob der Eintrag dann verworfen wird (**Apply & Drop**). Zum Testen klicken wir nun einmal auf *Apply & Drop*.

![](/post/smartgit_discard_overview.png)

Wir sehen nun, dass die Datei zur Datenauswertung wieder als "Modified" angezeigt wird. Weiterhin ist der `stash` aus der Anzeige der `Branches` verschwunden (dies wäre bei nur **Apply** nicht passiert). Da die Änderung an unserer Auswertungsdatei aber nicht wichtig ist, wollen wir sie jetzt endgültig rückgäng machen. Wir wählen also wieder *Discard* und als Option diesmal das reine `discard`. Damit ist die Datei wieder auf dem Stand des letzten `commit`. 

Das Alles kann man natürlich auch "Old-School" über das Terminal machen. Hierzu wechselt ihr im Terminal auf euer <span style="color: darkred;">**Git**</span>-Repository. 
Mit `git status` könnt ihr euch die Änderungen in eurem Repository anschauen. 

![](/post/smartgit_discard_modifiedTerminal.png)
Wie ihr auf dem Bild sehen könnt, zeigt uns das Terminal auch mit "modified" an, dass etwas an unserer Datei geändert wurde. 

Hier gibt es jetzt dieselben zwei Optionen, wie bei <span style="color: darkred;">**SmartGit**</span>. 

1. `git reset -hard` und dann `git clean -fxd`: ist genau dasselbe wie **Discard** in <span style="color: darkred;">**SmartGit**</span>. Eure Änderungen werden permanent gelöscht und ihr kehrt wieder auf den Stand des letzten `commit` zurück. 

2. `git stash`: entspricht **Discard to Stash**. Eure Veränderungen werden also erstmal einem "Papierkorb" hinzugefügt und nicht direkt gelöscht. 

##### `git revert`

Dieser Befehl ist eine sichere Methode, um einen `Commit` rückgängig zu machen. Was genau passiert, werden wir uns in einem Beispiel ansehen. Nehmen wir an, dass wir in unsere Datenauswertung etwas Falsches reingeschrieben haben:

![](/post/smartgit_revert.png)
Das ist uns aber erst aufgefallen, als wir die Änderung schon in einen `Commit`gepackt haben. Jetzt wollen wir diesen `Commit` rückgängig machen. 
Hierzu öffnen wir über das Terminal unser <span style="color: darkred;">**Git**</span>-Repository und führen den Befehl `git revert HEAD`aus. Wenn wir jetzt unser Log checken, steht da Folgendes: 

![](/post/smartgit_DoRevert.png)
<span style="color: darkred;">**Git**</span> hat also einen neuen `Commit` erstellt, der den Alten rückgängig gemacht hat. Das Projekt wurde also nicht auf seinen Status vor dem `Commit` zurückgesetzt, sondern nur der letzte `Commit`. Der "Revert"-`Commit` repräsentiert denselben Status unseres Projekts wie der `Commit` vor unserem ungewollten `Commit`. 

![](/post/smartgit_RevertFlowchart2.png)
Das gibt uns nun die Möglichkeit, doch noch mit dem ungewollten `Commit` arbeiten zu können, falls wir unsere Meinung ändern sollten. 

Wenn ihr das in <span style="color: darkred;">**SmartGit**</span> machen wollt, müsst ihr oben in der Toolleiste auf *Branch* und dann *Revert* gehen. Hier seht ihr nun ganz oben euren letzten `Commit`, den wir rückgängig machen wollen. Dafür müsst ihr dann nur noch auf "Revert&Commit" gehen. 
Schaut ihr euch  nun den `Commit`-Verlauf an, werdet ihr ganz oben den `Commit`sehen, der euren Alten rückgängig gemacht hat.

![](/post/smartgit_SmartGit_Revert.png)

##### `git reset`
Mit `$git reset --hard [Commit]` wird der Verlauf auf diesen ausgewählten `Commit` zurückgesetzt. Die ungewollten `Commits` kann man im Log nicht mehr sehen (wie es oben der Fall ist). Das Log könnt ihr euch mit `git log` anzeigen lassen, mit "q" (quit) könnt ihr es wieder verlassen. In die Klammer setzt ihr die "Nummer" des vorherigen `Commits` ein, der hier "Gewollte Änderung" heißt. Diese erfahrt ihr über das Log und sieht so aus: 3fb082aec25dacb664762cec505aba79528b55cf. Wenn ihr nach dem Ausführen des Befehls nun wieder in euer Log schaut, ist euer neuer `Commit` nicht mehr da.

![](/post/smartgit_git_reset.png)


![](/post/smartgit_git_reset_HEAD.png)

Wie kann man den letzten `Commit` auf <span style="color: darkred;">**SmartGit**</span> rückgängig machen? Indem ihr in <span style="color: darkred;">**SmartGit**</span> auf *Local*, oben in der Leiste geht und dann nur noch auf `Undo last Commit` klickt. Damit kehrt ihr wieder auf den Stand vor diesem `Commit` zurück. 

![](/post/smartgit_git_reset_Flowchart.png)

Den Unterschied zu `git revert` seht ihr in diesem Flowchart. Der Befehl `git revert` erstellt für euren gelöschten `Commit` einen Neuen, der den alten umkehrt (schaut euch dazu auch nochmal das Flowchart für `git revert` an). Der *HEAD*-Zeiger bewegt sich also vorwärts auf den neuen `Commit`, der den Zustand vor eurem ungewollten `Commit` wiederspiegelt. 
Bei `git reset` bewegt sich der *HEAD*-Zeiger rückwärts. Der ungewollte `Commit` wird vollständig gelöscht, auch aus dem Log. Ihr kehrt tatsächlich zu eurem alten `Commit` zurück und nicht nur auf eine "Kopie" davon. 

##### `Fetch`

`Fetch` ist euch vielleicht schon beim Befehl `pull` als Option aufgefallen. Dort konntet ihr euch zwischen **Pull** und **Fetch Only** entscheiden. 

![](/post/smartgit_pull.png)

Der Unterschied zwischen den beiden Optionen besteht darin, dass beim **Fetch** lediglich die Informationen darüber abgerufen werden, ob seit unserem letzten `push` Veränderungen an dem Projekt vorgenommen wurden und welche genau das sind. Bei `pull` hingegen werden, wie wir es gesehen haben, sowohl diese Information abgerufen als auch alle Veränderungen auf unseren lokalen Ordner übertragen. Somit arbeiten wir direkt mit den veränderten Dateien weiter, während wir bei `Fetch` noch auf unserem eigenen letzten Stand bleiben. 

<!-- Kann man diese Erklärung noch spezifizieren? __ Finde die Erklärung eigentlich soweit gut, in welche Richtung spezifizieren?-->

Mit `fetch` können wir also einen Überblick über die Veränderungen erhalten, die seit unserem letzten `pull` von den anderen Kollaborator:innen vorgenommen wurden und auf <span style="color: darkred;">**GitHub**</span> gepushed wurden. Wir können dann nach der Betrachtung überlegen, ob wir die Änderungen auch übernehmen möchten. Beachtet jedoch, dass es zu Konflikten kommen kann, wenn ihr eine Datei nicht aktualisiert, sie dann auf andere Weise selbst verändert und versucht, einen `push` durchzuführen. Dann muss in mühsamer Kleinarbeit der Konflikt gelöst werden. Daher ist der Einsatz von `fetch` eher beschränkt.

##### `gitignore`

Eine weitere nützliche Funktionalität ist die Verwendung von `gitignore`, die wir euch anhand der stets präsenten **.Rhistory** erläutern. Wie wir bereits beschrieben haben, ist die Datei **.Rhistory** eine eigene Historien-Dokumentation über durchgeführte Befehle in <span style="color: darkred;">**R**</span>, aber für die Arbeit unnötig. Trotzdem ist sie stets in der Anzeige `Files` in <span style="color: darkred;">**SmartGit**</span> enthalten, wo sie als "Untracked" angezeigt wird. Bisher haben wir sie stets manuell ignoriert, was aber keine zufriedenstellende Lösung ist. Weiterhin kann man Dateien mit Rechtsklick und `Delete` einfach löschen. Aber bei der nächsten Arbeit mit <span style="color: darkred;">**R**</span> würde sie wieder auftauchen. Wir müssen <span style="color: darkred;">**Git**</span> also berichten, dass dies eine unwichtige Datei ist, die in alle Aktionen nicht einbezogen werden soll, wofür `gitignore` gemacht ist.

In einer Datei mit dem Namen `.gitignore` können Benennungen von Dateien festgelegt werden, die von <span style="color: darkred;">**Git**</span> - wie es der Name sagt - ignoriert werden. Es ist im Endeffekt eine Liste mit vielen Einträgen. Man kann die `.gitignore`-Datei mit einem normalen Texteditor erstellen, wobei dabei manchmal Probleme auftauchen, da keine Zeichen vor dem `.` im Dateinamen sind oder die Datei als **.gitignore.txt** abgespeichert wird, wodurch sie nicht funktioniert. Auch <span style="color: darkred;">**GitHub**</span> bietet eine Option zum Erstellen dieser Datei. Wir wollen aber betrachten, wie <span style="color: darkred;">**SmartGit**</span> uns dabei behilflich sein kann. 

1. Wir machen einen Rechtsklick auf die Datei und wählen jetzt die Option *Ignore*.
2. In dem Fenster, was sich jetzt öffnet, haben wir zwei Optionen. Wir können entweder die Datei spezifisch zum Ignorieren auswählen (*Ignore explicitly (e.g. 'Makefile')*) oder alle Dateien mit ähnlichem Muster. Um die Muster kümmern wir uns später nochmal und wählen jetzt erstmal spezifisch die Datei. Wir lassen auch den Rest auf den Standardeinstellungen und bestätigen. 

![](/post/smartgit_ignore.png)
3. Im **Files**-Feld verschwindet nun die Datei **.Rhistory**. Die neue Datei wird uns aber nicht direkt angezeigt. Um sie zu betrachten, wählen wir erst *View* und dann *Show ignored Files*. In der `File` Übersicht werden nun sowohl **.gitignore** als auch **.Rhistory** angezeigt. Wenn wir die Datei **.gitignore** mit Linksklick anwählen, sehen wir in den **Changes** auch ihren Inhalt. Dort werden sowohl **.gitignore** als auch **.Rhistory** angezeigt. 

![](/post/smartgit_gitignore_files.png)
![](/post/smartgit_gitignore_changes.png)

4. Standardmäßig ignoriert sich die `.gitignore`-Datei also auch selbst. Das heißt, dass Änderungen nicht getracked werden und sie auch nicht in einem `push` auf <span style="color: darkred;">**GitHub**</span> enthalten sein kann. Jede:r Teilnehmende am Projekt hätte demnach entweder eine eigene Version der Datei oder auch gar keine, wenn er:sie keine erstellt hat. Wir möchten die Datei jedoch ins Tracking mit aufnehmen. Daher machen wir einen Rechtsklick auf die Datei und klicken *Open*, wodurch sie in einem Texteditor geöffnet wird. Dort entfernen wir dann die Zeile, in der `.gitignore` genannt ist und speichern. Der Status der Datei ist nun nicht mehr "Ignored", sondern "Untracked".

![](/post/smartgit_gitignore_editor.png)
![](/post/smartgit_gitignore_stage.png)

5. Im letzten Schritt können wir nun zunächst die ignorierten Dateien über die Auswahl in *View* wieder verstecken. Zusätzlich müssen wir die `.gitignore`-Datei in einen `commit` packen und diesen auch direkt über *Commit & Push* mit <span style="color: darkred;">**GitHub**</span> synchronisieren. Damit ist die Erstellung der Datei abgeschlossen.


![](/post/smartgit_gitignore_commit.png)

Die Liste von ignorierten Dateien kann stets geändert werden. Dabei beginnt jeder Name einer Datei in einer neuen Zeile. Wir haben schon angemerkt, dass man neben präzisen Dateinamen auch Muster ausschließen kann. Beispielsweise sind Datensätze teilweise sehr große Objekte oder enthalten Daten, die nicht online gestellt werden sollten. Trotzdem wollen wir sie meist am selben Ort wie die Auswertungsskripts haben. Eine Aufnahme in die Liste der ignorierten Dateien ist hierbei optimal. Nehmen wir an, die Daten heißen "a.RData" und "b.RData". Nun könnte man natürlich einfach beide Namen in die `.gitignore`-Datei eintragen. Man kann aber auch den Stern `*` als Platzhalter nutzen.

```
*.RData
```

Somit werden alle Dateien mit dieser Endung ignoriert. Nehmen wir an, dass wir eine weitere Datei "c.RData" haben, die keine persönlichen Informationen enthält und auch nicht zu groß ist. Diese würde nun auch ignoriert werden, obwohl sie es nicht soll. Ausnahmen in `.gitignore` können über ein Ausrufezeichen gesteuert werden `!`.

```
!c.RData
```

Nun wird nur die eine Daten-Datei getracked. Manchmal gibt es in einem Repository auch Unterordner, die alle Dateien erhalten, die für das Tracking nicht wichtig sind. Diese können dann gemeinsam über den zugehörigen Ordnernamen ausgeschlossen werden.

```
Ordnername/*
```

`.gitignore` ist also hilfreich zum Ordnung halten und kann gleichzeitig persönliche Daten vor einem Upload schützen.

##### `Conflict Solver`

Der Conflict Solver ist keine immer einsetzbare Funktion. Um diesen benutzen zu können, muss man erstmal einen Konflikt haben. Konflikte können bspw. entstehen, wenn zwei Personen diesselbe Zeile derselben Datei ändern oder eine Person die Datei löscht, während ein andere diese ändert. 

Für <span style="color: darkred;">**Git**</span> ist natürlich nicht direkt klar, welche der beiden Änderungen nun richtig ist. Dies wird durch das Anzeigen eines Konfliktes gelöst. Im Kontext der Arbeit mit <span style="color: darkred;">**GitHub**</span> muss die Person, die als zweites Änderungen an einer Datei pushen will, den Konflikt lösen. Dies ist generell erstmal logisch, da bei den ersten Änderungen natürlich kein Konflikt auftritt und <span style="color: darkred;">**Git**</span> nicht in die Zukunft schauen kann. Mit <span style="color: darkred;">**SmartGit**</span> wird das Lösen eines Konfliktes zum Glück erleichtert - wir wollen dies an einem Beispiel betrachten. 

**Konflikt erstellen**

Um einen Konflikt lösen zu können, muss man natürlich erstmal einen erstellen. Dafür braucht ihr ein lokales <span style="color: darkred;">**Git**</span>-Repository, das mit einem Remote-Repository auf <span style="color: darkred;">**GitHub**</span> verbunden ist. Wir werden jetzt einen Konflikt in der Datei "Datenauswertung" erzeugen. Das funktioniert wie folgt: 

1. Unsere Datei "Datenauswertung" existiert lokal und auf <span style="color: darkred;">**GitHub**</span>. Natürlich könntet ihr auch eine neue Datei erstellen, aber in diesem Fall bleiben wir bei unserem Beispiel. Wichtig ist nur, dass die Datei lokal und auf <span style="color: darkred;">**GitHub**</span> auf demselben Stand vorliegt.

2. Geht auf <span style="color: darkred;">**GitHub**</span> und ändert etwas an der Datei (hier in Zeile 20) und speichert diese Änderungen. Wir gehen jetzt gedanklich davon aus, dass eine andere Person in euerm Team, einen `shapiro.test()` machen möchte und diesen auch schon remote hinterlegt hat. 

![](/post/smartgit_GitHub_Änderungen.png)
3. Jetzt ändert ihr lokal etwas in der Datei (auch in Zeile 20). Ihr selbst wollt also einen `t.test()` mit den Daten durchführen. 

![](/post/smartgit_KonfliktLokal2.png)
4. Öffnet <span style="color: darkred;">**SmartGit**</span> und führt nur einen `Commit` durch, aber noch keinen `Push`. 


![](/post/smartgit_KonfliktCommit.png)
5. Versucht jetzt einen *Push* durchzuführen. Es müsste euch folgende Warnung angezeigt werden: 

![](/post/smartgit_PushFehlermeldung.png)
<span style="color: darkred;">**SmartGit**</span> sagt uns, dass wir zuerst einen *Pull* durchführen sollen (*hint: to the same ref. You may want to first integrate the remote changes*). 
Wenn ihr das jetzt macht, ist ein Konflikt entstanden. 

![](/post/smartgit_KonfliktEntstanden.png)

**Konflikt Lösen**

Nachdem <span style="color: darkred;">**SmartGit**</span> den Konflikt in der Datei erkannt hat, wird es euch rechts unten automatisch eine Leiste zur möglichen Konfliktlösung anzeigen. 

Die einfachsten zwei Optionen zwischen denen man wählen kann, um den Konflikt zu lösen sind: *Take Ours* oder *Take Theirs*. 
Dabei entscheidet man sich entweder komplett für seine eigene Version oder die der andere Person.

Das ist natürlich problematisch, wenn man sowohl die Eigenen als auch die des Anderen behalten will. Hier kommt jetzt der `Conflict Solver` ins Spiel. Den Button dazu findet ihr in dem Bereich unten rechts, dort wo ihr auch schon die Optionen *Take Ours* und *Take Theirs* aufgefunden habt.  

![](/post/smartgit_ConflictSolver.png)

<!-- Wie wird dieser gestartet? Automatisch, wenn Git Konflikt registriert, steht oben-->
Nachdem ihr den `Conflict Solver` gestartet habt, öffnet sich ein weiteres Fenster. Links sieht man unsere eigenen Veränderungen, rechts die der anderen Person und in der Mitte eine mögliche Lösung des Konflikts. 

![](/post/smartgit_ConflictSolver3.png)
Hier werden beide Veränderungen zusammen in der Datei angezeigt. Falls noch nicht genau ersichtlich ist, wer welche Veränderungen getätigt hat, geht man links oben auf *Base Changes*. Damit erhält man bei großen Veränderungen einen besseren Überblick. Bei unserem Beispiel ist das nicht nötig. 

Wir wollen jetzt die Version mit dem `shapiro.test()` nehmen. Dafür klicken wir auf den Pfeil neben der Zeile und "ziehen" sie in die Mitte. 

![](/post/smartgit_KonfliktLösung2.png)
Die Datei in der Mitte sieht jetzt so aus wie wir sie haben wollten. Also gehen wir auf *Save* und schließen dann den `Conflict Solver`. Dabei taucht folgende Meldung auf: 

![](/post/smartgit_StageCommit.png)
Hier klickt man auf *Stage*, um den Konflikt zu lösen. *Stage* bereitet die Datei für einen `Commit` vor, lädt sie also ins *Staging Environment* wie wir aus dem **Git-Intro** wissen. Würden wir auf *Don´t Stage* klicken, hätten wir zwar unsere Veränderungen in der Datei, aber sie würden beim nächsten `Commit` nicht auftauchen.  
Anschließend führt ihr einen `Commit` durch und einen `Push`, um die neue Datei auch auf <span style="color: darkred;">**GitHub**</span> zu haben. 



Der Konflikt wurde erfolgreich gelöst!


# Fazit und Ausblick

<span style="color: darkred;">**SmartGit**</span> erleichtert die Arbeit mit <span style="color: darkred;">**Git**</span> enorm und bietet eine gut ausgearbeitete Benutzeroberfläche. Wir haben einige weitere Befehle kennengelernt, mit denen wir einen guten Arbeitsablauf an gemeinsamen Projekten ermöglichen können. Jedoch bietet <span style="color: darkred;">**Git**</span> noch viele weitere Optionen, die in weiteren Tutorials in den nächsten Monaten besprochen werden sollen.

***

## Appendix A

<details><summary> **Erstellen eines Personal Access Tokens** </summary>

Wie bereits oben erwähnt, braucht man manchmal statt des Passworts ein Personal Access Token. Um eines zu erstellen, müsst ihr euch erstmal auf <span style="color: darkred;">**GitHub**</span> einloggen. Dann navigiert ihr zu **Settings** und klickt in der linken Spalte ganz unten **Developer Settings** an. Hier geht ihr dann auf **Personal Access Token** und generiert ein neues Token. 

![](/post/smartgit_PAT.png)
Diesem müsst ihr nun einen Namen geben, der am besten erklärt, wofür ihr dieses Token braucht. Außerdem kann man entscheiden, wie lange das Token gültig sein soll. 

Nun kommt ein wichtiger Part: Ihr wählt Scopes aus und bestimmt so für was euer Token alles benutzt werden kann. 

Für unsere Zwecke reicht es, wenn ihr *repo* auswählt.
Jetzt klickt ihr auf **Generate new Token**. Nun seht ihr euer Token und speichert es ab. Dieser Schritt ist wichtig, da ihr das Token nicht mehr auf <span style="color: darkred;">**GitHub**</span> ansehen könnt, wenn ihr einmal die Seite geschlossen habt. Dieses könnt ihr jetzt anstatt eures Passworts verwenden. 

<!-- Folgende Kommentare sind erstmal nicht an dich -->
<!-- Unterschied zwische Rebase und Revert -->
<!-- bei einem wird alles was neuer war, als der Zeitpunkt zu dem man zurück geht, gelöscht und ist nicht zugreifbar -->
<!-- bei dem anderen wird der Rückgang zu dem alten Punkt als neuer Punkt im Working Tree angelegt. -->

