---
title: SmartGit
date: '2021-08-01'
slug: smartgit
categories:
  - "gitintro"
tags: []
subtitle: ''
summary: ''
authors: [nehler, rouchi]
featured: no
header:
  image: ""
  caption: ""
projects: []
publishDate: '2021-08-12'
---

# Warum SmartGit?

Da das Terminal nicht die beste optische Repräsentation aller Möglichkeiten von `git` bietet, wollen wir uns in diesem Tutorial mit `SmartGit` beschäftigen. Dieses bietet uns eine benutzerfreundlichere, anschaulichere  Oberfläche, mit der wir problemlos `git`-Befehle ausführen können. Wir wollen uns hierbei zunächst anschauen, wie unsere bereits gelernten Befehle in `SmartGit` funktionieren. Anschließend werden wir noch weitere Möglichkeiten und Befehle kennen lernen.

## Einführung

`SmartGit` ist wie bereits erwähnt eine grafische Oberfläche für die Verwendung von `git` auf dem lokalen Rechner - aber auch in der Verbindung mit `remote repositories`. Das Programm existiert bereits seit 2009 und wurde stets weiterentwickelt, wodurch eine reibungslose Funktionsweise sichergestellt ist. Durch Ausführen von `git`-Befehlen via Klick wird die Arbeit beschleunigt. Andere Befehle werden sogar automatisiert durchgeführt. Ein großer Vorteil von `SmartGit` ist dabei, dass es mit mehreren Orten für `remote repositories` wie `GitHub`, `BitBucket` oder `GitLab` integrativ arbeiten kann, wobei wir uns im Tutorial weiterhin nur mit `GitHub` beschäftigen werden.

# Setup

Damit ihr `SmartGit` auf euren Rechnern verwenden könnt, müsst ihr zunächst das Programm herunterladen. Dies könnt ihr [hier](https://www.syntevo.com/smartgit/) für verschiedene Betriebssysteme machen. Auf der Website gibt es auch **Installation Instructions** für die verschiedenen Betriebssystem. 


Bei den Einstellungen für `SmartGit` müsst ihr den Nutzungsbedingungen zustimmen und unter `License type` außerdem auswählen, dass ihr das Programm für "Non-commercial use only", also wissenschaftliche Zwecke verwendet, sodass ihr nicht für die Nutzung zahlen müsst. 

![](/post/smartgit_license.png)

Dies muss in einem zweiten Fenster noch einmal bestätigt werden. Als nächstes müsst ihr euch unter `User Information` einen Nutzernamen geben sowie eine E-Mail-Adresse angeben, über die ihr euer `SmartGit` konfiguriert. `SmartGit` sollte die Informationen aus eurer eigenen Konfiguration auf dem lokalen PC ziehen können und daher bereits anzeigen, welche E-Mail und welcher Name hinterlegt sind. Ansonsten gebt ihr am besten selbst Nutzernamen und die E-Mail-Adresse an, mit denen ihr `Git` auf dem Rechner konfiguriert habt! 

![](/post/smartgit_information.png)


Jetzt müsst ihr noch die Option **Use SmartGit as SSH client** auswählen. Dies ist für den Start der Arbeit mit `SmartGit` empfohlen. 

![](/post/smartgit_sshclient.png)

Anschließend werden wir nach dem bevorzugten Style der Oberfläche von `SmartGit` gefragt. Hier gibt es natürlich kein richtig oder falsch und es gibt auch nicht direkt eine Empfehlung für Anfänger:innen. Die Ansicht des **Working Tree** wird von uns allerdings als intuitiver eingeschätzt und deshalb verwendet. Wie im Fenster beschrieben, kann diese Einstellung später auch unter Präferenz geändert werden. 

![](/post/smartgit_style.png)

Unter **Privacy** kann man bestimmen, in welchen Fällen Daten an die Ersteller:innen gesendet werden, die diese zur Verbesserung des Programmes nutzen wollen. Hier möchten wir keine Empfehlung aussprechen - man kann nach persönlicher Präferenz auswählen. Außerdem sucht `SmartGit` auf dem Rechner nach initialisierten `repositories` und gibt in diesem Fenster die Anzahl an.

![](/post/smartgit_privacy.png)

Sobald ihr `SmartGit` installiert habt und das Programm öffnet, werdet ihr gefragt, ob ihr ein lokales `repository` öffnen oder neu erstellen wollt, oder aber ob ihr ein bereits bestehendes `clonen` möchtet. Wenn bereits `repositories` auf dem Rechner bestehen, werden diese hier unter **Reopen previously used repository** angezeigt. Diesen Punkt wählen wir daher auch aus. Dabei wollen wir natürlich an unserem Ordner Praktikum arbeiten.


![](/post/smartgit_welcome.png)


Nun ist die Installation abgeschlossen und wir können uns die Oberfläche des Programms und die Nutzung genauer anschauen!


# Basics

Jetzt wo wir `SmartGit` erfolgreich installiert und mit unserem Praktikums-Ordner verknüpft haben, stellt sich die Frage, wofür und wie wir `SmartGit` am besten verwenden. Hierzu betrachten wir zunächst, wo wir unsere bereits erlernten `Git`-Befehle umsetzen können

### Benutzeroberfläche

Zur Orientierung schauen wir uns jedoch zunächst die Oberfläche von `SmartGit` genauer an. Diese haben wir durch die Auswahl eines bestimmten Styles hergestellt.

![](/post/smartgit_style_workingtree.png)

In der oberen Zeile befinden sich zunächst Symbole mit bekannten Begriffen wie `Pull` und `Commit`. Diese Werkzeuge werden wir gleich brauchen. Auf der linken Seite sehen wir unsere `Repositories` - theoretisch können wir hier alle reinladen, an denen wir uns beteiligen. Wenn ihr dem Tutorial Stück für Stück bis hierhin gefolgt seid, sollte einmal das Dummy und das Praktikum-Repository hier erscheinen. Darunter sehen wir die verschiedenen `Branches` eines Projekts - mit diesen beschäftigen wir uns erst im nächsten Teil des Tutoriums. 

In der Mitte des Bildschirms sehen wir die Kachel `Files`. Hierin werden alle Dateien angezeigt, die entweder noch nicht getracked werden, verändert, gelöscht oder umbenannt wurden. Für Praktikum ist hier die `R`-History zu sehen, die `R` automatisch erstellt, aber für uns keinen Wert hat. Diese ist im normalen Explorer und Terminal versteckt, wird aber hier angezeigt.

In der Kachel `Changes` werden die Veränderungen an einer Datei angezeigt, wenn Sie unter `Files` ausgewählt ist. Das demonstrieren wir gleich noch einmal mit einem Screenshot. In der Kachel Journal sind alle `Commits` der Historie aufgeführt. 

Um die Arbeit mit `SmartGit` zu simulieren, müssen wir natürlich wieder Änderungen an den Dateien vornehmen. Dafür öffnen wir das Datenauswertungsskript aus unserem Ordner und ergänzen darin beispielsweise eine Häufigkeitstabelle für den Gesamtscore. Wichtig ist, dass die Änderung auch gespeichert werden muss.

![](/post/Dummy_gitAuswertung_fifth.png)

Durch die Änderung der Datei erscheint diese nun in `SmartGit` in der Kachel `Files`. Dabei wird sie in rot angezeigt und es steht daneben, dass sie modifiziert wurde. Wenn wir nun einmal auf sie mit Linksklick draufgehen, sehen wir auch nochmal besser, wofür die `Changes` Kachel da ist. Durch die grüne Markierung der Zeilen 19 und 20 im Code sehen wir, dass diese neu hinzugefügt wurden.

![](/post/smartgit_files_changes.png)

### `Commit`

Nun, da wir eine Datei verändert haben, wollen wir diese Änderung natürlich auch committen. Im Terminal mussten wir dafür erst mit `git add` etwas zur `staging environment` hinzufügen. Das ist über `SmartGit` nicht mehr notwendig, bzw. wird durch Klick auf die interessierenden Dateien ersetzt. In der `Files`-Kachel wählen wir mit einem Linksklick alle Dateien aus, die im nächsten `Commit` enthalten sein sollen (bei der Auswahl mehrere Dateien wie üblich `strg` gedrückt halten). Anschließend wählen wir in der Werkzeuge-Leiste `Commit` aus. Es öffnet sich das `Commit`-Fenster, in dem nochmal angezeigt wird, welche Dateien wir ausgewählt haben. Wir möchten nur die Änderung in der Datenauswertung in unserem `Commit` haben. Weiterhin müssen wir, wie auch bei der Ausführung im Terminal, eine passende Message zu unserem `Commit` hinzufügen.

![](/post/smartgit_commit.png)


Wenn die Nachricht verfasst ist, reicht ein Klick auf `Commit` und die Änderungen wurden angenommen. Lokal sind sie also getracked. Alternativ könnte man hier auch auf `Commit & Push` klicken, dann wird unser lokaler Ordner direkt auf `GitHub` gepusht. Dies kann man machen, wenn man sich seiner Änderungen sicher ist. Nur `Commit` ist dabei empfehlenswert, wenn man sich unsicher ist und nochmal weiter an den Änderungen arbeiten will - oder für den Fall, dass wir noch weitere Änderungen an anderen Dateien unseres Projekts vornehmen wollen. Aus Demonstrationszwecken drücken wir auf `Commit`. Wenn ihr auf `SmartGit` die Kachel `Journal` betrachtet, ist dieser `Commit` zwar im `master` enthalten, aber nicht im `origin`. Dies spricht dafür, dass die Änderung im `remote repository` noch angestoßen werden muss. Dies können wir mit einem `Push` machen. 


### `Push` & `Pull`

Anstatt eine ganze Zeile in das Terminal eingeben zu müssen, um den Ordner auf `GitHub` auf den Stand des lokalen Ordners zu aktualisieren, reicht bei `SmartGit` ein einfacher Klick auf `Push`. Zunächst öffnet sich ein Fenster, in dem wir diese Aktion nochmals bestätigen. 

![](/post/smartgit_push.png)

Da wir `SmartGit` nun zum ersten Mal mit einem Server interagieren lassen, werden wir nach einem **Master Password** gefragt. Man kann dieses zwar auch überspringen, aber es ist wichtig für den Schutz von Passwörtern in der Interaktion mit Servern, weshalb wir eine Festlegung dringend empfehlen (außerdem gibt es eine Bewegung in die Richtung, dass normale Passwort-Interaktion mit `GitHub` in Zukunft nicht mehr möglich ist). Am besten verwendet ihr hier auch nicht das gleiche Passwort, welches ihr bei `GitHub` verwendet habt. 

![](/post/smartgit_master_password.png)

Einmal muss die Rechtmäßigkeit des Zugriffs auf den Server nun aber mit euren `GitHub`-Informationen bestätigt werden.

![](/post/smartgit_github_login.png)

Nun wurde der `Push` durchgeführt. Um einen optischen Indikator dafür zu haben, könnt ihr euer `repository` auf der `GitHub`-Website öffnen. Weiterhin sind man auch in der Kachel `Journal`, dass `origin` und `main` nun wieder auf derselben Höhe des neuen `Commits` sind. 

Damit wir nicht jedes Mal die `GitHub`-Informationen eingeben müssen, aktivieren wir den Zugang über das **Master Password**. Dafür wählen wir in der obersten Zeile `Edit` aus und wählen darin `Preferences` aus.

![](/post/smartgit_preferences.png)

Hier gehen wir in der Auswahl auf **Hosting Providers** und drücken dann rechts auf **Add**.

![](/post/smartgit_preferences_hosting.png)

`GitHub` ist hier bereits auswählt. Wir wollen nun einen **Token** erstellen. Dafür müssen wir den Button **Generate** drücken. Der Browser sollte sich automatisch öffnen und einen Login zu `GitHub` erfordern. Sobald wir diese Informationen eingegeben haben, wird ein Token generiert. Diesen kopieren wir dann in das entsprechende Fenster in `SmartGit` und klicken auf **Authenticate**.

![](/post/smartgit_preferences_API.png)

Wir gelangen zurück in das Fenster, wo wir den Token erstellt haben, und klicken auf **Add**. Damit erscheint nun im Fenster der Hosting Providers unser `GitHub`-Account und wir können auf **OK** klicken.

![](/post/smartgit_preferences_hosting_two.png)

Beachtet, dass der Vorgang von `Push` wirklich simpel über den Klick funktioniert hat. Die Umstellungen für das Passwort mussten wir jetzt nur einmal vornehmen. Ähnlich einfach ist der Vorgang, um unsere lokale Kopie des repositories auf die Version auf `GitHub` zu aktualisieren. Auch hier können wir den Button in der Werkzeug-Leiste nutzen. Nach dem Klick auf `Pull` geht ein Fenster auf, indem man zwischen `Rebase` und `Merge` wählen kann - diese Begriffe sind beide noch unbekannt und wir bleiben bei der Standardeinstellung. Anschließend erscheint das Fenster `Pull`. Hierin wird die URL vom `GitHub repository` angezeigt - diese müsste stimmen, könnt ihr aber gerne kontrollieren. Anschließend klicken wir auf den uns bekannten Befehl `Pull`.

![](/post/smartgit_pull.png)

Es erscheint für eine kurze Zeit ein grüner Kasten, in dem steht, dass der `Pull` erfolgreich war. Natürlich wurden gerade aber keine Änderungen an Dateien oder Ähnliches vorgenommen, da der Stand lokal und remote identisch war. Wir simulieren die Änderung einer anderen Person an einer Datei - wie im letzten Tutorial auch - durch eine Veränderung in der `GitHub` Version. Dafür öffnen wir das `repository` auf `GitHub` und klicken auf den Stift, der rechts in der Zeile von **README.md** angezeigt wird. 

Wir wollen eine schnelle Änderung an diesem Vornehmen und fügen daher noch in der wir präzisieren, um welche Gruppe es sich bei uns imaginär handelt. In der `commit`-Nachricht beschreiben wir kurz die durchgeführte Änderung und lassen die anderen Optionen auf ihren Standardeinstellungen. Anschließend klicken wir **Commit Changes** und wechseln zurück auf unsere `SmartGit` Anwendung. 

![](/post/smartgit_github_change.png)

In dieser wählen wir jetzt wieder **Pull** in unserem `repository` Praktikum aus. Zunächst scheint nicht viel anderes zu passieren als bei dem vorherigen **Pull**, wenn man allerdings genau hinschaut, sieht man, dass der letzte `commit` nun am unteren Bildschirmrand im **Journal** angezeigt wird. Wenn man die Datei **README.md** lokal auf dem eigenen Rechner anschaut, werden die neuen Inhalte nun auch angezeigt. 

![](/post/smartgit_pull_change.png)

Bisher haben wir nur mit dem `repository` gearbeitet, das automatisch von `SmartGit` gefunden wurde. Nun wollen wir noch Fälle betrachten, in dem das `repository` nur online besteht oder in dem es noch komplett neu erstellt werden muss.

#### Bereits bestehendes `GitHub`-repository mit `SmartGit` clonen

Wie in den `git`-Funktionen gelernt, kann man ein `repository`, das online existiert, auch mit `SmartGit` lokal intialisieren.Um euren auf `GitHub` geladenen Praktikums-Ordner mit `SmartGit` zu verknüpfen, müsst ihr zunächst in der Menüleiste auf `Repository` klicken und dann auf `Clone`. In dem Fenster, was sich daraufhin öffnet, könnt ihr einfach die URL eures repositories (die ihr über `GitHub` anfordern könnt) in das entsprechende Feld kopieren. Die hier angegebene URL ist nur ein Platzhalter, um euch die nächste Felder zeigen zu können. Wir haben momentan kein `repository`, das nur online und nicht lokal angelegt ist. Die Eingabe muss natürlich noch bestätigt werden. 

![](/post/smartgit_clone_url.png)

Beachtet an dieser Stelle, dass es auch möglich ist, ein lokales `repository` nochmal lokal `clonen`. Ihr hättet dieses dann zwei Mal. Hierfür müsste man **local repository** auswählen und den Pfad dahin angeben. Dieses Vorgehen hat jedoch nicht viele Anwendungen und wird daher nicht genauer betrachtet. 

Zurück zur Verbindung mit einem `repository` auf `GitHub`: Nach der Eingabe der URL erscheint ein Dialogfenster, in dem Details über den `clone` abgefragt werden. Diese sind vor allem interessant, wenn mehrere Branches in einem `repository` existieren, womit wir uns noch nicht beschäftigt haben. Außerdem können größere Daten ausgeschlossen werden, um Speicherplatz zu sparen. Dies trifft uns auch eher selten.

![](/post/smartgit_clone_selection.png)

Nach der Bestätigung der Details könnt ihr einen Ordner auswählen, in den eure Daten von `GitHub` geladen werden sollen. Ihr könnt die Standardeinstellung verwenden oder über die Ordneransicht einen Ordner auf eurem Rechner erstellen. 

![](/post/smartgit_clone_place.png)

Nachdem das Cloning abgeschlossen ist, solltet ihr auf der linken Seite eurer `SmartGit`-Ansicht den Ordner unter `Repositories` sehen können. Jetzt könntet ihr über `SmartGit` mit `GitHub` kommunizieren und  Änderungen an den Dateien tracken. Da wir diese Funktionen jetzt nur mal betrachtet und nicht ausgeführt haben, ändert sich in unserer Ansicht natürlich nichts. 

#### Neues `repository` erstellen

Ein neues `repository` mit `SmartGit` zu erstellen, ist sehr einfach! Dazu müsst ihr in der Menüleiste zunächst auf `Repository` klicken und dann auf **Add or create...**. In dem Fenster, was sich jetzt öffnet, könnt ihr entweder einen Ordner auswählen, den ihr bereits erstellt habt - beispielsweise unseren bekannten Praktikums-Ordner - oder über "Neuer Ordner" einen neuen erstellen. Das Einladen eines bereits existierenden `repositories` kann nötig sein, falls die automatische Erkennung fehlgeschlagen ist oder ihr das Hinzufügen zunächst abgelehnt habt. Dafür würdet ihr einfach den Pfad des `repositories` hier einstellen, was wir jetzt aber nicht betrachten werden. 

![](/post/smartgit_create_rep.png)

In diesem Beispiel erstellen wir in unserem Statistik-Ordner den neuen Ordner **dummy2** und initialisieren diesen als neues `repository`. Hierfür wird nochmal eine Bestätigung in einem seperaten Dialogfenster benötigt.

![](/post/smartgit_create_init.png)

Kleine Anmerkung: Diese Initialiserung würde natürlich nicht erscheinen, wenn ihr der Ordner bereits ein `git`-Ordner wäre und nur zur Anzeige in `SmarGit` eingeladen werden sollte. 

Nach einem Klick auf `OK` ist euer `repository` erstellt und ihr könnt mit nun Dateien erstellen, hinzufügen und mit euren Veränderungen loslegen! Es wird nun auf der linken Seite in der Liste angezeigt. Das Tracking der Dateien wäre momentan natürlich nur lokal. Um eine Verbindung mit `GitHub` zu erstellen, muss zunächst äquivalent zu der Beschreibung im Tutorial zu `GitHub` ein `repository` erstellt habt. Dort wurde bereits empfohlen, dass das neu erstellte `repository` zunächst leer ist und denselben Namen wie die lokale Version trägt. Es wird dabei eine URL kreiert, unter der das `repository` zu finden ist. In diesem Fall würde diese so aussehen:

![](/post/smartgit_github_url.png)

Diese solltet ihr nun kopieren und wieder zurück auf `SmartGit` wechseln. Dort wählte ihr in der Übersichtsleiste zunächst **Remote** und dann **Add...**. Es erscheint eine Eingabe für die URL, die ihr eben kopiert habt.  

![](/post/smartgit_add_remote.png)

Um die Einrichtung abzuschließen, müsst ihr nun noch einen `Push` durchführen. Nachdem dieser abgeschlossen ist, sollte das `repository` auch auf `GitHub` den `initial commit` anzeigen. Ab diesem Moment werden alle euren lokalen Änderungen durch einen `Push` auf `GitHub` abgelegt. 

![](/post/smartgit_github_pushing.png)


#### Änderung des Styles der Oberfläche

Bei der Einrichtung von `SmartGit` haben wir uns für einen Style in der Anzeige unserer `repositories` entschieden. Zum Abschluss der Basics des Tutorials wollen wir nun noch kurz betrachten, wie wir diese anfängliche Entscheidung ändern können. Dafür wählt ihr in der obersten Zeile zunächst **Edit** und dann **Preferences**. Es öffnet sich ein Fenster, indem wir zunächst **User Interface** in der Übersicht links anklicken. Im rechten Fenster gibt es die Auswahl **Prefer**, bei der momentan **Working Tree** angewählt sein sollte. Stattdessen klicken wir nun auf **Log Graph** und bestätigen die Auswahl (es können natürlich noch weitere Änderungen an der Oberfläche hier durchgeführt werden, aber diese werden wir nicht näher betrachten).

![](/post/smartgit_preferences_loggraph.png)

Beim Erstellen des Tutorials musste `SmartGit` nun einmal geschlossen und wieder geöffnet werden, damit die Änderungen sichtbar werden. Es ist eine neue Aufteilung in der Oberfläche zu sehen, wobei die Anzeige der `Repositories` und `Branches` auf der linken Seite bestehen bleibt. 

![](/post/smartgit_loggraph.png)

Im zentralen Fenster `Graph` wird der Workflow - also alle `commits`, die jemals an unserem Projekt durchgeführt wurden - angezeigt. Dabei stehen jeweils die Initialien der Person, die den commit durchgeführt hat sowie das Änderungsdatum. So können wir auf einen Blick nachvollziehen, wer wann was an unserem Projekt verändert hat. Beachtet auch, dass nun ganz oben der aktuelle Stand eures `repositories` als **Working Tree** angezeigt wird. In diesem wird eine Änderung angezeigt, da die Datei `.Rhistory` weiterhin im `repository` existiert, aber noch nicht in einen `commit` einbezogen wurde.

Auf der rechten Seite des Bildschirms sehen wir mittig eine Übersicht über alle unsere Dateien, die wir seit dem letzten `Commit` lokal verändert haben - in diesem Falle die `.Rhistory`. Oben rechts werden Informationen über den Account angegeben, der einen `Commit` durchgeführt hat. Am unteren Bildschirmrand ist wieder die Übersicht über Änderungen in Dateien von einem `commit` zu einem anderen. Wem diese Übersicht nun besser gefällt, kann die Einstellung so lassen. Für das weitere Tutorial ändern wir die Einstellung wieder in den **Preferences** und starten `SmartGit` wieder neu. 


# Weitere Funktionen

Insgesamt bieten `git` und `Smartgit` natürlich noch eine Fülle an anderen Funktionen, was schon die Benutzeroberfläche sehr deutlich macht. Die Besprechung aller Optionen würde den Rahmen sprengen und einige Erklärungen folgen auch noch im Teil zu der Advanced Nutzung. Trotzdem wollen wir hier nochmal einige weitere nützliche Funktionalitäten aufführen.

##### `Discard`

Über `Discard`, können wir Änderungen, die wir an den Dateien vorgenommen haben, verwerfen. Wir würden dadurch wieder zu der Version der Datei zurückkehren, die im letzten `commit` enthalten ist. Wichtig ist, dass es somit hier um Änderungen an der Datei geht, die noch nicht in einem `commit` verarbeitet wurden. 

Um das ganze zu testen, müssen wir zunächst eine Änderung an einer lokalen Datei vornehmen. Beispielsweise fügen wir in unsere Auswertungsdatei eine neue Zeile Code ein. 

![](/post/smartgit_discard_filechange.png)

Die Änderung wird nun in `SmartGit` angezeigt, indem die Datei als `Modified` bezeichnet wird. 

![](/post/smartgit_discard_modified.png)

Nun könnten wir die Änderungen in der Datei in einen `Commit` packen und dann auch einen `push` durchführen. Gehen wir nun aber davon aus, dass wir bemerken, dass unsere Änderung nicht gut ist und wieder rückgängig gemacht werden sollte. Natürlich könnte man die Datei öffnen und die Zeile einfach wieder raus löschen. Das ist in diesem Fall recht simpel, kann aber bei komplexeren Änderungen sehr langwierig sein. Hier kann man über `Discard` nun also sehr schnell zum Stand des letzten `Commit` zurückkehren. Der Button für den `Discard` ist auch in der Werkzeugsleiste enthalten. Am besten wählt ihr vor dem Klicken die betreffende/n Datei/en bereits aus.

![](/post/smartgit_discard_symbol.png)

Bei der Auswahl gibt es im Dialogfenster dann zwei Unteroptionen:

1. `Discard`: Wenn die Veränderungen nicht mehr benötigt werden, reicht diese Option aus. Hier werden alle Änderungen rückgängig gemacht und die Datei ist wieder auf dem alten Stand des letzten `Commits`. 
2. `Discard to Stash`: Hierbei wird die veränderte Datei nicht unwiderruflich gelöscht, sondern dem `Stash` - quasi einem Papierkorb - hinzugefügt. Von hier aus können die veränderten Dateien wieder abgerufen werden, falls man sie doch noch benötigt.

![](/post/smartgit_discard_options.png)

Die bessere Option müsst ihr also von Fall zu Fall selbst wählen. Da es bei der Auswahl von `Discard` keine weiteren Schritte geht, gibt es dazu auch keine weitere Aussage und wir wählen im Tutorial jetzt `Discard to Stash`. Es folgt eine kleine Änderung in der `SmartGit`-Ansicht und zwar im Fenster zu den `Branches`. Hier erscheint der neue Punkt `Stashes`. Wenn wir auf diesen drauf klicken, werden Datum und Uhrzeit angezeigt.

![](/post/smartgit_discard_branches.png)

Mit einem Rechtsklick werden die Optionen zum Umgang mit dem Stash angezeigt. Man kann sich den Inhalt nochmal mit **Show Content in Log** anschauen oder den Stash mittels **Rename Stash...** umbenennen. Anhand von **Apply Stash...** kann die verworfenen Änderung wieder vorgenommen werden.

![](/post/smartgit_discard_apply.png)

Hier wird nochmal darin unterschieden, ob der Stash nach dem Wiedereinfügen bestehen bleibt (**Apply**) oder ob der Eintrag dann verworfen wird (**Apply & Drop**). Zum Testen klicken wir nun einmal auf **Apply & Drop**.

![](/post/smartgit_discard_overview.png)

Wir sehen nun, dass die Datei zur Datenauswertung wieder als `Modified` angezeigt wird. Weiterhin ist der Stash aus der Anzeige der Branches verschwunden (dies wäre bei nur **Apply** nicht passiert). Da die Änderung an unserer Auswertungsdatei aber nicht wichtig ist, wollen wir sie jetzt endgültig rückgäng machen. Wir wählen also wieder `Discard` und als Option diesmal das reine `Discard`. Damit ist die Datei wieder auf dem Stand des letzten `Commit` und wir können einen weiteren interessanten Befehl betrachten.



##### `Fetch`

`Fetch` ist euch vielleicht schon beim Befehl `Pull` als Option aufgefallen. Dort konntet ihr euch zwischen `Pull` und `Fetch Only` entscheiden. 

![](/post/smartgit_pull.png)

Der Unterschied zwischen den beiden Optionen besteht darin, dass beim `Fetch` lediglich die Informationen darüber abgerufen werden, ob seit unserem letzten `Push` Veränderungen an dem Projekt vorgenommen wurden und welche genau das sind. Bei `Pull` hingegen werden, wie wir es gesehen haben, sowohl diese Information abgerufen als auch alle Veränderungen auf unseren lokalen Ordner übertragen. Somit arbeiten wir direkt mit den veränderten Dateien weiter, während wir bei `Fetch` noch auf unserem eigenen letzten Stand bleiben.

Mit `Fetch` können wir also einen Überblick über die Veränderungen erhalten, die seit unserem letzten `Pull` von den anderen Kollaborator:innen vorgenommen wurden und auf `GitHub` gepushed wurden. Wir können dann nach der Betrachtung überlegen, ob wir die Änderungen auch übernehmen möchten. Beachtet jedoch, dass es zu Konflikten kommen kann, wenn ihr eine Datei nicht aktualisiert, sie dann auf andere Weise selbst verändert und versucht, einen `push` durchzuführen. Dann muss in mühsamer Kleinarbeit der Konflikt gelöst werden. Daher ist der Einsatz von `Fetch` eher beschränkt.

##### `gitignore`

Zum Abschluss des Tutorials wollen wir uns um die Datei `.Rhistory` kümmern und anhand von ihr das Prinzip von `gitignore` erläutern. Wie wir bereits beschrieben haben, ist die Datei `Rhistory` eine eigene Historien-Dokumentation über durchgeführte Befehle in `R`, aber für die Arbeit unnötig. Trotzdem ist sie stets in der Anzeige `Files` in `SmartGit` enthalten, wo sie als `Untracked` angezeigt wird. Bisher haben wir sie stets manuell ignoriert, was aber keine zufriedenstellende Lösung ist. Weiterhin kann man Dateien mit Rechtsklick und `Delete` einfach löschen. Aber bei der nächsten Arbeit mit `R` würde sie wieder auftauchen. Wir müssen `git` also berichten, dass dies eine unwichtige Datei ist, die in alle Aktionen nicht einbezogen werden soll, wofür `gitignore` gemacht ist.

In einer Datei mit dem Namen `.gitignore` können Benennungen von Dateien festgelegt werden, die von `git` - wie es der Name sagt - ignoriert werden. Es ist im Endeffekt eine Liste mit vielen Einträgen. Man kann die `.gitignore`-Datei mit einem normalen Texteditor erstellen, wobei dabei manchmal Probleme auftauchen, da keine Zeichen vor dem `.` im Dateinamen sind oder die Datei als `.gitignore.txt` abgespeichert wird, wodurch sie nicht funktioniert. Auch `GitHub` bietet eine Option zum Erstellen dieser Datei. Wir wollen aber betrachten, wie `SmartGit` uns dabei behilflich sein kann. 

1. Wir machen einen Rechtsklick auf die Datei und wählen jetzt die Option `Ignore`.
2. In dem Fenster, was sich jetzt öffnet, haben wir zwei Optionen. Wir können entweder die Datei spezifisch zum Ignorieren auswählen **Ignore explicitly (e.g. 'Makefile')** oder alle Dateien mit ähnlichem Muster. Um die Muster kümmern wir uns später nochmal und wählen jetzt erstmal spezifisch die Datei. Wir lassen auch den Rest auf den Standardeinstellungen und bestätigen. 

![](/post/smartgit_ignore.png)
3. Im `Files`-Feld verschwindet nun die Datei `.Rhistory`. Die neue Datei wird uns aber nicht direkt angezeigt. Um sie zu betrachten, wählen wir erst **View** und dann **Show ignored Files**. In der `File` Übersicht werden nun sowohl `.gitignore` als auch `.Rhistory` angezeigt. Wenn wir die Datei `.gitignore` mit Linksklick anwählen, sehen wir in den `Changes` auch ihren Inhalt. Dort werden sowohl `.gitignore` als auch `.Rhistory` angezeigt. 

![](/post/smartgit_gitignore_files.png)
![](/post/smartgit_gitignore_changes.png)

4. Standardmäßig ignoriert sich die `.gitignore`-Datei also auch selbst. Das heißt, dass Änderungen nicht getracked werden und sie auch nicht in einem `Push` auf `GitHub` enthalten sein kann. Jede:r Teilnehmende am Projekt hätte demnach entweder eine eigene Version der Datei oder auch gar keine, wenn er keine erstellt hat. Wir möchten die Datei jedoch ins Tracking mit aufnehmen. Daher machen wir einen Rechtsklick auf die Datei und klicken **Open**, wodurch sie in einem Texteditor geöffnet wird. Dort entfernen wir dann die Zeile, in der `.gitignore` genannt ist und speichern. Der Status der Datei ist nun nicht mehr `Ignored` sondern `Untracked`.

![](/post/smartgit_gitignore_editor.png)
![](/post/smartgit_gitignore_stage.png)

5. Im letzten Schritt können wir nun zunächst die ignorierten Dateien über die Auswahl in **View** wieder verstecken. Zusätzlich müssen wir die `.gitignore`-Datei in einen `Commit` packen und diesen auch direkt über **Commit & Push** mit `GitHub` synchronisieren. Damit ist die Erstellung der Datei abgeschlossen.


![](/post/smartgit_gitignore_commit.png)

Die Liste von ignorierten Dateien kann stets geändert werden. Dabei beginnt jeder Name einer Datei in einer neuen Zeile. Wir haben schon angemerkt, dass man neben präzisen Dateinamen auch Muster ausschließen kann. Beispielsweise sind Datensätze teilweise sehr große Objekte oder enthalten Daten, die nicht online gestellt werden sollten. Trotzdem wollen wir sie meist am selben Ort wie die Auswertungsskripts haben. Eine Aufnahme in die Liste der ignorierten Dateien ist hierbei optimal. Nehmen wir an, die Daten heißen `a.RData` und `b.RData`. Nun könnte man natürlich einfach beide Namen in die `.gitignore`-Datei eintragen. Man kann aber auch den Stern `*` als Platzhalter nutzen.

```
*.RData
```

Somit werden alle Dateien mit dieser Endung ignoriert. Nehmen wir an, dass wir eine weitere Datei `c.RData` haben, die keine persönlichen Informationen enthält und auch nicht zu groß ist. Diese würde nun auch ignoriert werden, obwohl sie es nicht soll. Ausnahmen in `.gitignore` können über ein Ausrufezeichen gesteuert werden `!`.

```
!c.RData
```

Nun wird nur die eine Daten-Datei getracked. Manchmal gibt es in einem `repository` auch Unterordner, die alle Dateien erhalten, die für das Tracking nicht wichtig sind. Diese können dann gemeinsam über den zugehörigen Ordnernamen ausgeschlossen werden.

```
Ordnername/*
```

`.gitignore` ist also hilreich zum Ordnung halten und kann gleichzeitig persönliche Daten vor einem Upload schützen.




# Fazit und Ausblick

`SmartGit` erleichtert die Arbeit mit `git` enorm und bietet eine gut ausgearbeitete Benutzeroberfläche. Wir haben einige weitere Befehle kennen gelernt, mit denen wir einen guten Arbeitsablauf an gemeinsamen Projekten ermöglichen können. Jedoch bietet `git` noch viele weitere Optionen, die in weiteren Tutorials in den nächsten Monaten besprochen werden sollen.


<!-- ## Befehle -->

<!-- Unterschied zwische Rebase und Revert -->
<!-- bei einem wird alles was neuer war, als der Zeitpunkt zu dem man zurück geht, gelöscht und ist nicht zugreifbar -->
<!-- bei dem anderen wird der Rückgang zu dem alten Punkt als neuer Punkt im Working Tree angelegt. -->
