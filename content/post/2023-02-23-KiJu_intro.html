---
title: Einführung in R und R-Studio
date: '2023-02-23'
slug: kiju-r-intro
categories: ["KiJu"]
tags: ["Intro"]
subtitle: ''
summary: ''
authors: [nehler, schreiner]
lastmod: '2023-02-28T16:20:00+01:00'
featured: no
header:
  image: "/header/kiju_rintro.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/de/photo/113795)"
projects: []
---



<div id="einordnung-der-begriffe" class="section level2">
<h2>Einordnung der Begriffe</h2>
<p><code>R</code> und RStudio werden meist Synonym verwendet. Dabei gibt es eigentlich einen Unterschied. Während <code>R</code> eine Sprache ist, auf der also unsere ganze Syntax basieren wird, bietet RStudio eine benutzerfreundlichere Oberfläche. Weitere Infos zu den beiden Bestandteilen finden sich <a href="/post/r-crash-kurs/#R">hier</a>. Eine Beschreibung der Oberfläche kann man <a href="/post/r-crash-kurs/#RStudio">hier</a> finden. Dort wird auch die Funktionalität der einzelnen Fenster beschrieben und die Wichtigkeit eines Skripts erläutert.</p>
</div>
<div id="überschriften-und-kommentare" class="section level2">
<h2>Überschriften und Kommentare</h2>
<p>Reiner Code als Skript ist aus mehreren Gründen nicht gut. Andere Personen haben es ohne Kommentare in einem Skript viel schwerer, die dargestellten Schritte nachzuvollziehen. Darüber hinaus weiß man häufig selbst später nicht mehr genau, was man an spezifischen Stellen versucht hat zu erreichen. <code>R</code> bietet daher Möglichkeiten zur Gliederung anhand von Überschriften und Kommentaren - beide involvieren die Nutzung von <code>#</code>.</p>
<pre class="r"><code>#### Überschrift ----
# Kommetar</code></pre>
</div>
<div id="einfache-rechenoperationen-und-logik" class="section level2">
<h2>Einfache Rechenoperationen und Logik</h2>
<p>Natürlich bietet <code>R</code> erstmal ganz klassisch die Möglichkeit, Operationen eines Taschenrechners durchzuführen. Neben Addition und Subtraktion mit offensichtlicher Zeichenbelegung werden folgende Zeichen genutzt:</p>
<pre class="r"><code>2 * 3 # Multiplikation</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>2 / 3 # Division</code></pre>
<pre><code>## [1] 0.6666667</code></pre>
<pre class="r"><code>2 ^ 3 # Potenz</code></pre>
<pre><code>## [1] 8</code></pre>
<p>Eine wichtige Grundlage ist außerdem die Nutzung von logischen Abfragen. Dabei kann <code>R</code> für uns überprüfen, ob zwei Einträge bspw. gleich sind oder sich voneinander unterscheiden. Folgende Abfragen wären bspw. möglich:</p>
<pre class="r"><code>2 == 3 # ist gleich?</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>2 != 3 # ist ungleich?</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>2 &lt; 3  # ist kleiner?</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Weitere Informationen finden sich <a href="/post/r-crash-kurs/#Taschenrechner">hier</a>.</p>
</div>
<div id="funktionen" class="section level2">
<h2>Funktionen</h2>
<p>In <code>R</code> können wir auf Funktionen zurückgreifen, um nicht alles, was ausgeführt werden soll, selbst schreiben zu müssen. Funktionen in R haben folgende generelle Struktur:</p>
<pre class="r"><code>funktion(argument1, argument2, ...)</code></pre>
<p>Wir schauen uns zunächst ein simples Beispiel einer Funktion an:</p>
<pre class="r"><code>log(x = 2, base = 3)</code></pre>
<pre><code>## [1] 0.6309298</code></pre>
<pre class="r"><code>log(3, 2)</code></pre>
<pre><code>## [1] 1.584963</code></pre>
<pre class="r"><code>log(base = 3, x = 2)</code></pre>
<pre><code>## [1] 0.6309298</code></pre>
<p>Offenbar muss man entweder die Reihenfolge der Argumente kennen, dann kann man es sich sparen, die Namen der Argumente zu benennen. Wenn man die Reihenfolge jedoch nicht kennnt, ist es erforderlich, die Namen anzugeben.
Weil man beides nicht unbedingt kennt und einem auch die Bedeutung der Argumente unter Umständen nicht klar ist, gibt es die Möglichkeit <code>R</code> nach Hilfe zu fragen.</p>
<pre class="r"><code>help(log)</code></pre>
<p>Hier könnt ihr klicken, um mehr zu <a href="/post/r-crash-kurs/#Funktionen">Funktionen</a> und zur <a href="/post/r-crash-kurs/#Hilfe">Hilfe</a> zu erfahren.</p>
</div>
<div id="objekte-und-das-environment" class="section level2">
<h2>Objekte und das Environment</h2>
<p>Nicht immer ist es notwendig, dass uns Ergebnisse direkt in der Konsole ausgedruckt werden. Mitunter wollen wir Ergebnisse eigentlich nur zwischenspeichern, um sie dann weiter zu verwenden.
Dafür bietet <code>R</code> die Möglichkeit, Ergebnisse in sogenannten Objekten abzulegen. Die Zuweisung eines Ergebnisses zu einem Objekt erfolgt über den Zuweisungspfeil <code>&lt;-</code>.
Diese Zuweisung bewirkt, dass Ergebnisse nicht in der Konsolte angezeigt, sondern im Environment abgelegt werden.</p>
<pre class="r"><code>num &lt;- log(x = 2, base = 3)</code></pre>
<p>Objekte können dann auch in anderen Funktionen genutzt werden. In diesem Crash-Kurs sind Objekte nur Zahlen, aber wir werden später sehen, dass auch andere Sachen Objekte sein können.</p>
<pre class="r"><code>num_sqrt &lt;- sqrt(num)
num_sqrt</code></pre>
<pre><code>## [1] 0.7943109</code></pre>
<p>Eine detaillierte Aufbereitung zu Objekten und dem Environment ist an diesem <a href="/post/r-crash-kurs/#Environment">Ort</a> zu finden.</p>
</div>
<div id="pakete" class="section level2">
<h2>Pakete</h2>
<p>Nicht alle Funktionen, die wir in <code>R</code> verwenden können, sind in der Basisinstallation enthalten. Es gibt sogenannte Pakete, die zusätzlich installiert werden müssen, bevor wir die darin implementierten Funktionen nutzen können.
Beispielsweise die Funktion, die wir benötigen, um einen SPSS Datensatz einzulesen, können wir erst verwenden, wenn wir das entsprechende Paket <code>haven</code> installiert haben. Dies tun wir mittels der Funktion <code>install.packages()</code>.</p>
<pre class="r"><code># Installation Für Einladen SPSS Datensätze 
install.packages(&#39;haven&#39;, dependencies = TRUE)</code></pre>
<p>Mit der Installation eines Pakets sind die darin implementierten Funktionen noch nicht direkt nutzbar. Das Paket muss jetzt nämlich noch mit der Funktion <code>library</code> in die aktuelle Session geladen werden.</p>
<pre class="r"><code>library(haven)</code></pre>
<p>Das Prinzip vom Installieren und Laden von Paketen wird <a href="/post/tests-und-konfidenzintervalle/">hier</a> ausführlicher beschrieben.</p>
</div>
<div id="datensatz-einladen" class="section level2">
<h2>Datensatz einladen</h2>
<p>Der Datensatz, mit dem wir im Folgenden arbeiten werden, ist unter <a href="https://pandar.netlify.app/post/fb22_mod.sav">diesem Link</a> auffindbar. Um den Datensatz nun in <code>R</code> zu laden, müssen wir das sogenannte <em>Working Directory</em> unter Umständen verschieben. Bei dem <em>Working Directory</em> handelt es sich um den Ordner, in dem <code>R</code> in unserem lokalen System nach Dateien schaut. Um einen Ordner als <em>Working Directoy</em> zu bestimmen, müssen wir <code>R</code> den Pfad zu diesem Ordner mit dem Befehl <code>setwd()</code> mitteilen. Mit <code>getwd()</code> erfahren wir den Ordnerpfad des aktuellen <em>Working Directorys</em>.</p>
<pre class="r"><code>getwd()
setwd(&quot;~/Pfad/zu/Ordner&quot;)</code></pre>
<p>Wie im Workshop besprochen, kann es hilfreich sein, dass <em>Working Directory</em> automatisch auf den Ort zu setzen, wo das <code>R</code>-Skript abgespeichert ist. (Natürlich muss dafür das Skript auch tatsächlich abgespeichert sein.) Der Code, um ebendas umzusetzen, ist etwas kompliziert und deshalb hier nicht genauer erklärt. Es funktioniert aber ganz einfach, indem ihr Folgendes kopiert:</p>
<pre class="r"><code>rstudioapi::getActiveDocumentContext()$path |&gt;
  dirname() |&gt;
  setwd()</code></pre>
<p>Grundsätzlich funktioniert das Einladen eines Datensatzes verschieden je nach Format, in dem der Datensatz vorliegt. Wir konzentrieren uns erst einmal auf ein gängiges SPSS Format, das SAV Format. Dateien im SAV Format können mit einer Funktion eingelesen werden, die sich in dem eben aktivierten Paket <code>haven</code> befindet:</p>
<pre class="r"><code>data &lt;- read_sav(file = &quot;fb22_mod.sav&quot;)</code></pre>
</div>
<div id="arbeit-mit-datensatz" class="section level2">
<h2>Arbeit mit Datensatz</h2>
<p>Zunächst wollen wir uns in unserem Datensatz etwas orientieren. Dazu lassen wir die Anzahl an Messungen und Variablen ausgeben, sowie die Variablennamen.</p>
<pre class="r"><code>dim(data)</code></pre>
<pre><code>## [1] 153  36</code></pre>
<pre class="r"><code>names(data)</code></pre>
<pre><code>##  [1] &quot;prok1&quot;   &quot;prok2&quot;   &quot;prok3&quot;   &quot;prok4&quot;   &quot;prok5&quot;   &quot;prok6&quot;   &quot;prok7&quot;  
##  [8] &quot;prok8&quot;   &quot;prok9&quot;   &quot;prok10&quot;  &quot;nr1&quot;     &quot;nr2&quot;     &quot;nr3&quot;     &quot;nr4&quot;    
## [15] &quot;nr5&quot;     &quot;nr6&quot;     &quot;lz&quot;      &quot;extra&quot;   &quot;vertr&quot;   &quot;gewis&quot;   &quot;neuro&quot;  
## [22] &quot;intel&quot;   &quot;nerd&quot;    &quot;grund&quot;   &quot;fach&quot;    &quot;ziel&quot;    &quot;lerntyp&quot; &quot;geschl&quot; 
## [29] &quot;job&quot;     &quot;ort&quot;     &quot;ort12&quot;   &quot;wohnen&quot;  &quot;uni1&quot;    &quot;uni2&quot;    &quot;uni3&quot;   
## [36] &quot;uni4&quot;</code></pre>
<p>Häufig benötigt man Befehle zur Datensatzreduktion häufig, um Analysen für einen bestimmten Teil der Daten durchzuführen.
Die Auswahl einer einzelnen Variable funktioniert mit dem <code>$</code> Zeichen.</p>
<pre class="r"><code>data$extra</code></pre>
<pre><code>##   [1] 2.75 3.75 4.25 2.50 3.00 2.75 4.75 5.00 2.00 2.25 4.00 3.00 2.75 2.75 4.00
##  [16] 3.00 3.50 4.25 2.00 3.75 3.25 4.25 3.25 3.50 3.50 4.50 3.75 4.25 3.75 4.25
##  [31] 3.25 3.00 3.25 2.75 3.25 3.25 2.75 2.50 3.00 2.00 4.50 3.00 3.75 1.75 3.00
##  [46] 4.00 3.75 3.50 3.00 4.00 4.00 5.00 2.00 2.25 2.75 3.75 4.75 4.00 4.25 5.00
##  [61] 2.75 3.25 3.50 3.25 3.50 4.50 4.75 3.75 3.00 3.25 3.25 4.25 3.50 3.75 2.75
##  [76] 4.00 3.50 1.50 3.50 3.75 2.25 3.25 3.00 3.25 3.50 2.75 3.25 2.75 4.25 4.50
##  [91] 3.25 3.00 3.25 3.25 3.50 4.00 3.75 3.25 3.75 3.25 3.75 3.00 2.50 4.00 4.00
## [106] 3.75 2.25 2.75 3.25 2.25 3.50 2.75 3.25 2.50 2.25 2.75 3.50 4.00 4.00 2.25
## [121] 2.25 4.25 3.25 3.25 3.00 3.75 3.75 2.25 3.50 3.25 3.25 4.00 2.25 3.75 3.50
## [136] 4.00 3.75 2.75 2.75 3.25 4.50 3.00 2.75 3.75 3.25 4.25 4.25 3.00 3.50 3.00
## [151] 3.00 3.50 4.50
## attr(,&quot;format.spss&quot;)
## [1] &quot;F4.2&quot;</code></pre>
<p>Die Variable <code>extra</code> enthält die Ausprägungen in der Extraversion der Studierenden. Hierbei handelt es sich offenbar um Skalenwerte. Wie man selbst aus mehreren Items einen Skalenwert erstellt, schauen wir uns später auch noch an.</p>
<p>Daten sind jeweils in einer spezifischen Format abgelegt, das man mit <code>class</code> erfragen kann.</p>
<pre class="r"><code>class(data$extra)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>Die Skalenwerte sind in diesem Fall also numerisch. Betrachten wir nun einmal Daten, die in Textform vorliegen. Die Variable <code>grund</code> enthält die von den Studierenden genannten Gründe für die Aufnahme des Psychologie-Studiums.<br />
(Wenn ihr das ausführt, sollte mehr in der Konsole erscheinen, wir haben hier zur Übersichtlichkeit weniger anzeigen lassen.)</p>
<pre class="r"><code>data$grund
class(data$grund)</code></pre>
<pre><code>##  [1] &quot;Interesse&quot;                                                                                                                                 
##  [2] &quot;Allgemeines Interesse schon seit der Kindheit&quot;                                                                                             
##  [3] &quot;menschliche Kognition wichtig und rätselhaft; Interesse für Psychoanalyse; Schnittstelle zur Linguistik&quot;                                   
##  [4] &quot;Ich kann viel in Psychologie über mich und meine Mitmenschen lernen.&quot;                                                                      
##  [5] &quot;Interesse an dem Beruf des Therapeuten sowie an der Forschung&quot;                                                                             
##  [6] &quot;Einer von einigen Interessensbereichen mit dem man etwas beruflich anfangen kann; mit Philosophie oder Geschichte wird man halt arbeitslos&quot;
##  [7] &quot;durch den Orientierungstest&quot;                                                                                                               
##  [8] &quot;Interesse und eigene Erfahrung&quot;                                                                                                            
##  [9] &quot;interessant und anspruchsvoll&quot;                                                                                                             
## [10] &quot;Zentrum meiner Interessen: Politik, Philosophie&quot;</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>Das Format, in dem diese Daten gespeichert sind, wird als <code>character</code> bezeichnet.
Die Ausprägung jeder Person in der Variable <code>grund</code> ist individuell, weil jede Person ihren eigenen Text verfasst hat.
Es gibt aber auch Variablen mit text-Ausprägungen, die sich wiederholen. Ein Beispiel hierfür wäre das Geschlecht, bei dem jeder Person eine der drei Ausprägungen “männlich”, “weiblich” oder “divers” zugeordnet wird.</p>
<pre class="r"><code>data$geschl</code></pre>
<pre><code>##   [1]  1  2  2  1 NA  2  1  1  1  2  1  1  1  1  1  1  1  1  2  1 NA  1  1  1  1
##  [26]  2  1  1  1  1  1  1  1  2  1  1  1  1  1  1  1  1  1  1  1  1  1 NA  1  2
##  [51]  1  2  1  1  1  2  1 NA NA  1  3  1  1  1  1  1  1  1  1  1  1  1  2  2  2
##  [76]  1  2  2  1  1  1  1  1  1  1  1  1  1 NA  1  1  1  1  1  1 NA  2  1  1  1
## [101]  1 NA  1 NA  1  1  2  1  1  1  1  1  1  1  1  1  1  1  1  2  1  1 NA  2  1
## [126]  2  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
## [151]  2  1  1
## attr(,&quot;format.spss&quot;)
## [1] &quot;F8.2&quot;</code></pre>
<pre class="r"><code>class(data$geschl)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>Wir stellen fest, dass das Geschlecht beim Einlesen erstmal numerisch vorliegt. (Die NAs ignorieren wir zunächst und kommen später nochmal darauf zu sprechen.)
Die Bedeutung der Zahlen sollte aber zugeordnet werden; zum einen aus optischen Gründen bei der Auswertung, aber auch im Sinne der Funktionalität, wie wir im zweiten Abschnitt des Workshops noch sehen werden.
Eine solche Art von Variable wird als Faktor-Variable bezeichnet. Die Übertragung der numerisch vorliegenden Variable Geschlecht in eine Faktor-Variable lässt sich einfach mit dem Befehl <code>factor()</code> umsetzen. Im Datensatz speichern wir die erstellte Faktor-Variable in einer neuen Spalte ab.
<br>
Anmerkung: Die Funktion <code>c()</code> öffnet einen Vektor, also eine Datenreihe.</p>
<pre class="r"><code>data$geschl_faktor &lt;- factor(data$geschl,                                   # Ausgangsvariable
                             levels = c(1, 2, 3),                           # Faktorstufen
                             labels = c(&quot;weiblich&quot;, &quot;männlich&quot;, &quot;anderes&quot;)) # Label für Faktorstufen</code></pre>
<p>Die soeben transformierte Variable können wir jetzt nochmal betrachten, indem wir sie uns in der Konsole ausgeben lassen und den <code>class()</code>-Befehl auf sie anwenden.</p>
<pre class="r"><code>data$geschl_faktor</code></pre>
<pre><code>##   [1] weiblich männlich männlich weiblich &lt;NA&gt;     männlich weiblich weiblich
##   [9] weiblich männlich weiblich weiblich weiblich weiblich weiblich weiblich
##  [17] weiblich weiblich männlich weiblich &lt;NA&gt;     weiblich weiblich weiblich
##  [25] weiblich männlich weiblich weiblich weiblich weiblich weiblich weiblich
##  [33] weiblich männlich weiblich weiblich weiblich weiblich weiblich weiblich
##  [41] weiblich weiblich weiblich weiblich weiblich weiblich weiblich &lt;NA&gt;    
##  [49] weiblich männlich weiblich männlich weiblich weiblich weiblich männlich
##  [57] weiblich &lt;NA&gt;     &lt;NA&gt;     weiblich anderes  weiblich weiblich weiblich
##  [65] weiblich weiblich weiblich weiblich weiblich weiblich weiblich weiblich
##  [73] männlich männlich männlich weiblich männlich männlich weiblich weiblich
##  [81] weiblich weiblich weiblich weiblich weiblich weiblich weiblich weiblich
##  [89] &lt;NA&gt;     weiblich weiblich weiblich weiblich weiblich weiblich &lt;NA&gt;    
##  [97] männlich weiblich weiblich weiblich weiblich &lt;NA&gt;     weiblich &lt;NA&gt;    
## [105] weiblich weiblich männlich weiblich weiblich weiblich weiblich weiblich
## [113] weiblich weiblich weiblich weiblich weiblich weiblich weiblich männlich
## [121] weiblich weiblich &lt;NA&gt;     männlich weiblich männlich weiblich weiblich
## [129] weiblich weiblich weiblich weiblich weiblich weiblich weiblich weiblich
## [137] weiblich weiblich weiblich weiblich weiblich weiblich weiblich weiblich
## [145] weiblich weiblich weiblich weiblich weiblich weiblich männlich weiblich
## [153] weiblich
## Levels: weiblich männlich anderes</code></pre>
<pre class="r"><code>class(data$geschl_faktor)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<p>Wir kommen jetzt noch einmal kurz auf die NA zu sprechen: Sie repräsentieren in <code>R</code> fehlende Werte. Einige Befehle zu fehlenden Werten finden sich <a href="/post/deskriptiv-nominal/#Fehlend">hier</a>.</p>
<p>Bisher haben wir gesehen, wie einzelne Variablen ausgewählt werden können und wie man deren Typ überprüfen kann.
Es ist aber auch möglich, mehrere Variablen (also Spalten) auszuwählen, ebenso wie mehrere Zeilen. Mit dem Doppelpunkt <code>:</code> lässt sich ein Vektor erstellen, der alle Zahlen enthält, die sich zwischen den angegebene Grenzen (vor und nach dem Doppelpunkt) befinden.</p>
<pre class="r"><code>data[1:5,]</code></pre>
<pre><code>## # A tibble: 5 × 37
##   prok1 prok2 prok3 prok4 prok5 prok6 prok7 prok8 prok9 prok10   nr1   nr2   nr3
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     3     4     2     3     4     3     3     1      3     1     3     5
## 2     4     3     2     4     1     4     2     4     4      4     1     2     1
## 3     3     3     2     4     2     4     2     3     4      3     4     5     5
## 4     2     1     4     3     2     1     2     4     1      1     1     5     1
## 5     2     4     2     2     3     2     3     2     1      3     1     4     3
## # … with 24 more variables: nr4 &lt;dbl&gt;, nr5 &lt;dbl&gt;, nr6 &lt;dbl&gt;, lz &lt;dbl&gt;,
## #   extra &lt;dbl&gt;, vertr &lt;dbl&gt;, gewis &lt;dbl&gt;, neuro &lt;dbl&gt;, intel &lt;dbl&gt;,
## #   nerd &lt;dbl&gt;, grund &lt;chr&gt;, fach &lt;chr&gt;, ziel &lt;chr&gt;, lerntyp &lt;chr&gt;,
## #   geschl &lt;dbl&gt;, job &lt;dbl&gt;, ort &lt;dbl&gt;, ort12 &lt;chr&gt;, wohnen &lt;dbl&gt;, uni1 &lt;dbl&gt;,
## #   uni2 &lt;dbl&gt;, uni3 &lt;dbl&gt;, uni4 &lt;dbl&gt;, geschl_faktor &lt;fct&gt;
## # ℹ Use `colnames()` to see all variable names</code></pre>
<pre class="r"><code>data[,1:3]</code></pre>
<pre><code>## # A tibble: 153 × 3
##    prok1 prok2 prok3
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     1     3     4
##  2     4     3     2
##  3     3     3     2
##  4     2     1     4
##  5     2     4     2
##  6     2     2     3
##  7     2     3     2
##  8     4     3     2
##  9     2     3     3
## 10     3     1     2
## # … with 143 more rows
## # ℹ Use `print(n = ...)` to see more rows</code></pre>
<pre class="r"><code>data[,c(&quot;prok1&quot;, &quot;prok2&quot;, &quot;prok3&quot;)]</code></pre>
<pre><code>## # A tibble: 153 × 3
##    prok1 prok2 prok3
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     1     3     4
##  2     4     3     2
##  3     3     3     2
##  4     2     1     4
##  5     2     4     2
##  6     2     2     3
##  7     2     3     2
##  8     4     3     2
##  9     2     3     3
## 10     3     1     2
## # … with 143 more rows
## # ℹ Use `print(n = ...)` to see more rows</code></pre>
<p>Diese Möglichkeit der Auswahl von Zeilen oder Spalten lässt sich auch mit der bereits gelernten Logik verknüpfen. Wir können beispielsweise alle Zeilen auswählen, für die die Ausprägung einer Variable einer bestimmten Bedingung entspricht:</p>
<pre class="r"><code>data[data$geschl_faktor == &quot;weiblich&quot; | data$geschl_faktor == &quot;männlich&quot;,]</code></pre>
<pre><code>## # A tibble: 152 × 37
##    prok1 prok2 prok3 prok4 prok5 prok6 prok7 prok8 prok9 prok10   nr1   nr2
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     1     3     4     2     3     4     3     3     1      3     1     3
##  2     4     3     2     4     1     4     2     4     4      4     1     2
##  3     3     3     2     4     2     4     2     3     4      3     4     5
##  4     2     1     4     3     2     1     2     4     1      1     1     5
##  5    NA    NA    NA    NA    NA    NA    NA    NA    NA     NA    NA    NA
##  6     2     2     3     2     3     2     3     3     2      1     1     3
##  7     2     3     2     3     4     2     3     4     3      1     2     4
##  8     4     3     2     4     2     4     3     2     4      4     1     4
##  9     2     3     3     1     3     2     3     4     2      1     3     4
## 10     3     1     2     2     3     2     3     4     3      4     5     4
## # … with 142 more rows, and 25 more variables: nr3 &lt;dbl&gt;, nr4 &lt;dbl&gt;, nr5 &lt;dbl&gt;,
## #   nr6 &lt;dbl&gt;, lz &lt;dbl&gt;, extra &lt;dbl&gt;, vertr &lt;dbl&gt;, gewis &lt;dbl&gt;, neuro &lt;dbl&gt;,
## #   intel &lt;dbl&gt;, nerd &lt;dbl&gt;, grund &lt;chr&gt;, fach &lt;chr&gt;, ziel &lt;chr&gt;,
## #   lerntyp &lt;chr&gt;, geschl &lt;dbl&gt;, job &lt;dbl&gt;, ort &lt;dbl&gt;, ort12 &lt;chr&gt;,
## #   wohnen &lt;dbl&gt;, uni1 &lt;dbl&gt;, uni2 &lt;dbl&gt;, uni3 &lt;dbl&gt;, uni4 &lt;dbl&gt;,
## #   geschl_faktor &lt;fct&gt;
## # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names</code></pre>
</div>
<div id="einfache-deskriptivstatistik" class="section level2">
<h2>Einfache Deskriptivstatistik</h2>
<p>Viele Befehle für die einfache Deskriptivstatistik gehören direkt zu den Basisfunktionen von <code>R</code>.</p>
<pre class="r"><code>table(data$geschl_faktor)   # Häufigkeiten</code></pre>
<pre><code>## 
## weiblich männlich  anderes 
##      121       21        1</code></pre>
<pre class="r"><code>mean(data$extra)            # Mittelwert</code></pre>
<pre><code>## [1] 3.370915</code></pre>
<pre class="r"><code>cor(data$prok1, data$prok2) # Korrelation</code></pre>
<pre><code>## [1] -0.2479138</code></pre>
<p>Weitere deskriptive Operationen sind in vielen anderen Tutorials zu finden - hauptsächlich in <a href="/lehre/#bsc7">PsyBSc1</a>.</p>
<p>Schauen wir uns jetzt noch an, wie sich die Erstellung von Skalenwerten als Kombination der Datensatzauswahl und einfachen deskriptiven Funktionen umsetzen lässt.
Wir wollen dafür beispielhaft für die Variable Naturverbundenheit einen Skalenwert erstellen, der sich als der Mittelwert aus den ensprechenden 6 Items ergibt. Jede Person (also jede Reihe) erhält ihren Mittelwert.</p>
<pre class="r"><code>data$nr_ges &lt;- rowMeans(data[,c(&quot;nr1&quot;, &quot;nr2&quot;, &quot;nr3&quot;, &quot;nr4&quot;, &quot;nr5&quot;, &quot;nr6&quot;)])</code></pre>
<p>Mehr zu der Erstellung von Skalenwerten und dem in diesem Zusammenhang unter Umständen erforderliche Rekodieren von Items findet sich <a href="/post/deskriptiv-intervall/#Rekodieren">hier</a>.</p>
</div>
<div id="fazit" class="section level2">
<h2>Fazit</h2>
<p>Wir haben nun erste Befehle kennengelernt, uns aber besonders mit der Art der Datenverarbeitung beschäftigt. Das nächste Tutorial beginnt dann mit der linearen Modellierung. Im Folgenden finden sich noch Anwendungen des gelernten Codes.</p>
</div>
<div id="anwendungen" class="section level2">
<h2>Anwendungen</h2>
<ol style="list-style-type: decimal">
<li>Erstelle einen Faktor aus der Variable “wohnen”, die folgendermaßen kodiert ist: 1 - WG, 2 - bei Eltern, 3 - alleine, 4 - sonstiges.</li>
</ol>
<details>
<summary>
Lösung
</summary>
<pre class="r"><code>class(data$wohnen)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>data$wohnen_faktor &lt;- factor(data$wohnen,                                   
                             levels = c(1, 2, 3, 4),                                
                             labels = c(&quot;WG&quot;, &quot;bei Eltern&quot;, &quot;alleine&quot;, &quot;sonstiges&quot;)) 

str(data$wohnen_faktor)</code></pre>
<pre><code>##  Factor w/ 4 levels &quot;WG&quot;,&quot;bei Eltern&quot;,..: 2 2 3 2 NA 2 1 3 2 1 ...</code></pre>
</details>
<ol start="2" style="list-style-type: decimal">
<li>Reduziere den Datensatz mittels der <code>subset()</code>-Funktion auf diejenigen, die in einer WG leben und lege die Reduktion in einem neuen Objekt ab. Nutze dafür die interne Hilfe.</li>
</ol>
<details>
<summary>
Lösung
</summary>
<pre class="r"><code>data_WG &lt;- subset(data, 
                  subset = wohnen_faktor == &quot;WG&quot;
                  )</code></pre>
</details>
<ol start="3" style="list-style-type: decimal">
<li>Erstelle im gesamten Datensatz einen Skalenwert für alle positiv formulierten Perfektionismus-Items (1, 4, 6, 9 und 10).</li>
</ol>
<details>
<summary>
Lösung
</summary>
<pre class="r"><code>data$prok &lt;- rowMeans(data[,c(&quot;prok1&quot;, &quot;prok4&quot;, &quot;prok6&quot;, &quot;prok9&quot;, &quot;prok10&quot;)])</code></pre>
</details>
<ol start="4" style="list-style-type: decimal">
<li>Bestimme den Mittelwert, das Minimum und das Maximum für die eben bestimmten Werte.</li>
</ol>
<details>
<summary>
Lösung
</summary>
<pre class="r"><code>mean(data$prok)</code></pre>
<pre><code>## [1] 2.688889</code></pre>
<pre class="r"><code>min(data$prok)</code></pre>
<pre><code>## [1] 1.2</code></pre>
<pre class="r"><code>max(data$prok)</code></pre>
<pre><code>## [1] 4</code></pre>
</details>
</div>
