---
title: "Deskriptivstatistik für Intervallskalen"
categories: [BSc2]
date: '2020-09-24'
featured: no
header:
  caption: '[Courtesy of pxhere](https://pxhere.com/en/photo/1227907)'
  image: /header/descriptive_post.jpg
lastmod: '2020-09-24T20:54:18+02:00'
projects: []
slug: deskriptiv-intervall
subtitle: ''
summary: ''
tags: 
  - R 
  - Deskriprivstatistik
authors: [nehler, buchholz]
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<details>
<summary>
Kernfragen dieser Lehreinheit
</summary>
<ul>
<li>Was ist der Befehl um den <strong>Mittelwert</strong> zu bestimmen?</li>
<li>Wie kann die <strong>empirische Varianz</strong> bestimmt werden? Wie unterscheidet sich diese von der mit <code>var()</code> bestimmten Varianz?</li>
<li>Wie können Variablen <strong>zentriert und standardisiert</strong> werden?</li>
<li>Welche Möglichkeiten gibt es, negativ formulierte Items zu <strong>rekodieren</strong>?</li>
<li>Mit welchen Befehlen können in R <strong>Skalenwerte</strong> für Fragebögenitems erstellt werden?</li>
</ul>
</details>
<hr />
<div id="wiederholung-aus-der-vorlesung-skalenniveaus" class="section level2">
<h2>Wiederholung aus der Vorlesung: Skalenniveaus</h2>
<table>
<colgroup>
<col width="6%" />
<col width="24%" />
<col width="16%" />
<col width="20%" />
<col width="34%" />
</colgroup>
<thead>
<tr class="header">
<th>Skala</th>
<th>Aussage</th>
<th>Transformation</th>
<th>Zentrale Lage</th>
<th>Dispersion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nominal</td>
<td>Äquivalenz</td>
<td>eineindeutig</td>
<td>Modus</td>
<td>Relativer Informationsgehalt</td>
</tr>
<tr class="even">
<td>Ordinal</td>
<td>Ordnung</td>
<td>monoton</td>
<td>Median</td>
<td>Interquartilsbereich</td>
</tr>
<tr class="odd">
<td>Intervall</td>
<td>Verhältnis von Differenzen</td>
<td>positiv linear</td>
<td>Mittelwert</td>
<td>Standardabweichung, Varianz</td>
</tr>
<tr class="even">
<td>Verhältnis</td>
<td>Verhältnisse</td>
<td>Ähnlichkeit</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="odd">
<td>Absolut</td>
<td>absoluter Wert</td>
<td>Identität</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<hr />
</div>
<div id="vorbereitende-schritte" class="section level2">
<h2>Vorbereitende Schritte</h2>
<p>Den Datensatz haben wir bereits über diesen <a href="/post/fb21.rda"><i class="fas fa-download"></i> Link heruntergeladen</a> und können ihn über den lokalen Speicherort einladen oder Sie können Ihn direkt mittels des folgenden Befehls aus dem Internet in das Environment bekommen:</p>
<pre class="r"><code>load(url(&#39;https://pandar.netlify.app/post/fb21.rda&#39;))  # Daten laden
names(fb21)        # Namen der Variablen</code></pre>
<pre><code>##  [1] &quot;prok1&quot;   &quot;prok2&quot;   &quot;prok3&quot;   &quot;prok4&quot;   &quot;prok5&quot;   &quot;prok6&quot;   &quot;prok7&quot;  
##  [8] &quot;prok8&quot;   &quot;prok9&quot;   &quot;prok10&quot;  &quot;nr1&quot;     &quot;nr2&quot;     &quot;nr3&quot;     &quot;nr4&quot;    
## [15] &quot;nr5&quot;     &quot;nr6&quot;     &quot;lz&quot;      &quot;extra&quot;   &quot;vertr&quot;   &quot;gewis&quot;   &quot;neuro&quot;  
## [22] &quot;intel&quot;   &quot;nerd&quot;    &quot;grund&quot;   &quot;fach&quot;    &quot;ziel&quot;    &quot;lerntyp&quot; &quot;geschl&quot; 
## [29] &quot;job&quot;     &quot;ort&quot;     &quot;ort12&quot;   &quot;wohnen&quot;  &quot;uni1&quot;    &quot;uni2&quot;    &quot;uni3&quot;   
## [36] &quot;uni4&quot;</code></pre>
<pre class="r"><code>dim(fb21)          # Anzahl Zeile und Spalten</code></pre>
<pre><code>## [1] 114  36</code></pre>
<hr />
</div>
<div id="mindestens-intervallskalierte-variablen" class="section level2">
<h2>Mindestens intervallskalierte Variablen</h2>
<div id="klassische-mindestens-intervallskalierte-variablen" class="section level3">
<h3>Klassische mindestens intervallskalierte Variablen</h3>
<ul>
<li>Behaviorale Maße: Reaktionszeiten, Bearbeitungsdauer, Anzahl von Fehlern, …</li>
<li>Biologische Maße: Hautleitfähigkeit, Stimmhöhe, Anzahl der Sakkaden, …</li>
<li>Neurophysiologische Maße: EEG-Daten, Durchblutung von Hirnregionen, …</li>
</ul>
</div>
<div id="konstruierte-mindestens-intervallskalierte-variablen" class="section level3">
<h3>Konstruierte mindestens intervallskalierte Variablen</h3>
<ul>
<li>Fragebogendaten werden meist ordinalskaliert erhoben (einzelne Items)</li>
<li>Um Intervallskalenniveau zu erreichen, werden Items zu Skalenwerten verrechnet (Summe oder Mittelwert)</li>
<li>Erzeugt viele mögliche Ausprägungen und wird als intervallskaliert behandelt</li>
</ul>
<p><strong>Beispiel: Lebenszufriedenheit</strong></p>
<p><img src="/post/fb_swls.png" /></p>
<p>Der Mittelwert pro Person über alle 5 Items ist in der Spalte <code>lz</code> zu finden. Dies ist also der Skalenwert für die Lebenszufriedenheit jeder einzelnen Person.</p>
<pre class="r"><code>fb21$lz</code></pre>
<pre><code>##   [1] 3.0 5.2 7.0 4.8 6.0 3.6 5.6  NA 4.0 5.8 6.6 4.0 5.4 4.8 4.4 7.0 4.4 5.0
##  [19] 5.2 4.6 6.0 6.8 5.8 4.4 5.0 3.8  NA 3.6 4.4 4.2 5.8 5.4 6.8 5.0 4.6 4.6
##  [37] 4.0 5.6 5.2 3.4 2.4 5.6 2.0 5.6 6.2 5.6 5.0 5.8 4.8 5.2 5.4 5.0 6.0 5.6
##  [55] 4.2 6.4 4.8 2.8 4.4 3.4 4.8 5.0 5.6 6.4 6.0 4.6 4.8 4.0 6.0 5.2 5.2 5.6
##  [73] 5.6 4.8 5.6 4.8 5.8 5.0 4.8 3.2 6.8 5.2 6.2 2.6 4.6 3.4 3.6 6.4 5.8 1.6
##  [91] 3.0 4.0 5.2 6.4 6.6 5.4 3.4 4.8 4.8 4.8 5.4 5.6 3.4 6.8 5.8 5.8 5.8 7.0
## [109] 5.2 3.6 3.2 5.0 5.8 6.2</code></pre>
</div>
</div>
<div id="deskriptivstatistik-für-mindestens-intervallskalierte-variablen" class="section level2">
<h2>Deskriptivstatistik für mindestens intervallskalierte Variablen</h2>
<ul>
<li>Verfahren sind “rückwärtskompatibel”, d.h. alle Berechnungen, die auf nominalskalierte und ordinalskalierte Variablen anwendbar sind, lassen sich auch auf mindestens intervallskalierte Variablen anwenden</li>
<li>Quantile, IQA und Median können weiterhin bestimmt werden</li>
</ul>
<pre class="r"><code># Minimum &amp; Maximum
range(fb21$lz, na.rm=T)</code></pre>
<pre><code>## [1] 1.6 7.0</code></pre>
<pre class="r"><code># Quartile
quantile(fb21$lz, c(.25, .5, .75), na.rm=T)</code></pre>
<pre><code>## 25% 50% 75% 
## 4.4 5.1 5.8</code></pre>
<pre class="r"><code>#Box-Whisker Plot
boxplot(fb21$lz)</code></pre>
<p><img src="/post/2021-09-21-deskriptivstatistik-fuer-intervallskalen_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="histogramme" class="section level2">
<h2>Histogramme</h2>
<ul>
<li>Zusammenfassung von Werten in Klassen (Kategorien, Intervalle)<br />
</li>
<li>Häufigkeitsverteilung für die kategorisierten Daten erstellen (sekundäre Häufigkeitsverteilung)<br />
</li>
<li>Achtung! Die Anzahl der Kategorien kann den Eindruck der Daten beeinflussen:</li>
</ul>
<pre class="r"><code># Histogramm
hist(fb21$lz)</code></pre>
<p><img src="/post/2021-09-21-deskriptivstatistik-fuer-intervallskalen_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code># Histogramm (20 Kategorien)
hist(fb21$lz,
     breaks = 20)</code></pre>
<p><img src="/post/2021-09-21-deskriptivstatistik-fuer-intervallskalen_files/figure-html/unnamed-chunk-4-2.png" width="672" /></p>
<pre class="r"><code># Histogramm (ungleiche Kategorien)
hist(fb21$lz,
     breaks = c(1, 3, 3.3, 3.6, 3.9, 4.5, 5, 7))</code></pre>
<p><img src="/post/2021-09-21-deskriptivstatistik-fuer-intervallskalen_files/figure-html/unnamed-chunk-4-3.png" width="672" /></p>
</div>
<div id="mittelwert" class="section level2">
<h2>Mittelwert</h2>
<p><strong>Formel:</strong> <span class="math inline">\({x} = \frac{\sum_{m = 1}^n x_m}{n} = \frac{1}{n} \sum_{m = 1}^n x_m\)</span></p>
<pre class="r"><code># Arithmetisches Mittel
mean(fb21$lz, na.rm = TRUE)</code></pre>
<pre><code>## [1] 4.991071</code></pre>
</div>
<div id="varianz" class="section level2">
<h2>Varianz</h2>
<p><strong>Formel:</strong> <span class="math inline">\(s^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n}\)</span></p>
<pre class="r"><code># Händische Varianzberechnung
sum((fb21$lz - mean(fb21$lz, na.rm = TRUE))^2, na.rm = TRUE) / (nrow(fb21)-2)</code></pre>
<pre><code>## [1] 1.273135</code></pre>
<p>Achtung! Wir benötigen für die Varianzberechnung <code>n</code> (s. Formel)! Wir nutzen hier <code>nrow(fb21)-2</code>, weil <code>nrow(fb21)</code> nicht das richtige n anzeigt (zwei Personen haben einen fehlenden Wert, daher die Anzahl an Zeilen minus der zwei fehlenden Werte = n)</p>
<p><strong>Kleiner Diskurs zu fehlenden Werten:</strong></p>
<p><img src="/post/2021-09-21-deskriptivstatistik-fuer-intervallskalen_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Um zu prüfen, ob und wie viele fehlende Werte eine Variable hat, lässt sich z. B. folgende Syntax verwenden:</p>
<pre class="r"><code>is.na(fb21$lz) |&gt; sum()</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Um die Länge einer Variablen ohne fehlende Werte (also die Anzahl an Beobachtungen auf einer Variablen) zu bestimmen, lässt sich z. B. folgende Syntax verwenden:</p>
<pre class="r"><code>na.omit(fb21$lz) |&gt; length() # mit Pipe</code></pre>
<pre><code>## [1] 112</code></pre>
<pre class="r"><code>length(na.omit(fb21$lz))     # ohne Pipe</code></pre>
<pre><code>## [1] 112</code></pre>
<p>Zur händischen Varianzberechnung können wir daher auch folgende Syntax verwenden:</p>
<pre class="r"><code># Händische Varianzberechnung
sum((fb21$lz - mean(fb21$lz, na.rm = TRUE))^2, na.rm = TRUE) / (length(na.omit(fb21$lz)))</code></pre>
<pre><code>## [1] 1.273135</code></pre>
</div>
<div id="verschiedene-varianzschätzer" class="section level2">
<h2>Verschiedene Varianzschätzer</h2>
<p>Folgendes Ergebnis liefert R, wenn wir die R-Funktion <code>var()</code> zur Berechnung der Varianz verwenden:</p>
<pre class="r"><code># R-interne Varianzberechnung
var(fb21$lz, na.rm = TRUE)</code></pre>
<pre><code>## [1] 1.284604</code></pre>
<p>Warum erhalten wir hier einen abweichenden Wert im Vergleich zu unserer händischen Varianzberechnung?</p>
<p>Die meisten Programme berechnen nicht die empirische Varianz, sondern einen Schätzer der Populationsvarianz:</p>
<p><strong>Empirische Varianz</strong></p>
<p><span class="math inline">\(s^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n}\)</span></p>
<p><strong>Schätzer der Populationsvarianz</strong></p>
<p><span class="math inline">\(\hat{\sigma}^2_{X} = \frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n - 1}\)</span></p>
<p>Ein enger Zusammenhang zwischen Populationsvarianz und empirischer Varianz ist bereits nur durch Ansicht der Formeln erkenntlich. Eine Erklärung über diesen wird es erst im weiteren Verlauf der Vorlesung geben. Wir wollen uns nun darauf konzentrieren, wie wir technisch den Wert, den wir durch <code>var()</code> erhalten, für unsere Zwecke nutzen können.</p>
<p>Um in R die empirische Varianz mithilfe der <code>var()</code>-Funktion zu berechnen, kann man die Populationsvarianz nutzen. Multipliziert man sie mit <span class="math inline">\(\frac{n - 1}{n}\)</span>, erhält man die empirische Varianz.</p>
<pre class="r"><code># Umrechnung der Varianzen
var(fb21$lz, na.rm = TRUE) * (nrow(fb21) - 1) / nrow(fb21)</code></pre>
<pre><code>## [1] 1.273336</code></pre>
<p>Achtung! Dies funktioniert in unserem Fall wieder nicht, da die Verwendung von <code>nrow(fb21)</code> - wie oben bereits angemerkt - nicht sinnvoll ist: <code>nrow(fb21)</code> ist nicht gleich n (es kommt <code>NA</code> 2 Mal vor), daher besser:</p>
<pre class="r"><code># Umrechnung der Varianzen
var(fb21$lz, na.rm = TRUE) * (length(na.omit(fb21$lz)) - 1) / (length(na.omit(fb21$lz)))</code></pre>
<pre><code>## [1] 1.273135</code></pre>
<p>Alternativ, wenn man die fehlenden Werte händisch abzieht:</p>
<pre class="r"><code># Umrechnung der Varianzen
var(fb21$lz, na.rm = TRUE) * (112 - 1) / 112</code></pre>
<pre><code>## [1] 1.273135</code></pre>
</div>
<div id="standardabweichung" class="section level2">
<h2>Standardabweichung</h2>
<p>Auch bei der Standardabweichung bestimmt R den Populationsschätzer <span class="math inline">\(\hat{\sigma}_{X}\)</span>.</p>
<p><span class="math inline">\(\hat{\sigma}_{X} = \sqrt{\hat{\sigma}^2_{X}} = \sqrt{\frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n - 1}}\)</span></p>
<pre class="r"><code># Standardabweichung in R
sd(fb21$lz, na.rm = TRUE) # Populationsschaetzer</code></pre>
<pre><code>## [1] 1.133404</code></pre>
<p>In der Vorlesung hingegen haben Sie die empirische Standardabweichung kennen gelernt.</p>
<p><span class="math inline">\(s_{X} = \sqrt{s^2_{X}} = \sqrt{\frac{\sum_{m=1}^n (x_m - \bar{x})^2}{n}}\)</span></p>
<p>Wir müssten das Ergebnis also wieder mit einem Faktor (<span class="math inline">\(\sqrt{\frac{n - 1}{n}}\)</span>) multiplizieren, um die emprische Standardabweichung zu erhalten. Alternativ kann diese natürlich auch komplett händisch berechnet werden. Dafür können wir einfach den bereits geschriebenen Code für die empirische Varianz nehmen und aus dem Ergebnis die Wurzel ziehen.</p>
<pre class="r"><code># Händische Berechnung der empirischen Standardabweichung
(sum((fb21$lz - mean(fb21$lz, na.rm = TRUE))^2,
    na.rm = TRUE) / (length(na.omit(fb21$lz)))) |&gt; sqrt()</code></pre>
<pre><code>## [1] 1.128333</code></pre>
<hr />
</div>
<div id="zentrierung-und-standardisierung" class="section level2">
<h2>Zentrierung und Standardisierung</h2>
<p>In der Vorlesung haben Sie gelernt, dass eine Variable zentriert oder standardisiert werden kann. Die Zentrierung sorgt für einen Mittelwert von 0, während die Standardisierung zusätzlich die Varianz auf 1 setzt. Die Variablenzentrierung und -standardisierung lässt sich in R per Hand berechnen…</p>
<pre class="r"><code># Zentrierung
lz_c &lt;- fb21$lz - mean(fb21$lz, na.rm = TRUE)
head(lz_c)    # erste 6 zentrierte Werte</code></pre>
<pre><code>## [1] -1.9910714  0.2089286  2.0089286 -0.1910714  1.0089286 -1.3910714</code></pre>
<pre class="r"><code># Standardisierung
lz_z &lt;- lz_c / sd(fb21$lz, na.rm = TRUE)
head(lz_z)    # erste 6 standardisierte Werte</code></pre>
<pre><code>## [1] -1.7567185  0.1843373  1.7724738 -0.1685820  0.8901757 -1.2273396</code></pre>
<p>…oder mit Hilfe bereits existierender Funktionen:</p>
<pre class="r"><code>## Befehl zum Standardisieren
lz_z &lt;- scale(fb21$lz)
## Befehl zum Zentrieren (ohne Standardisierung)
lz_c &lt;- scale(fb21$lz,
              scale = FALSE) # unterbindet Standardisierung</code></pre>
<hr />
</div>
<div id="skalenwerte" class="section level2">
<h2>Skalenwerte</h2>
<div id="wiederholung-konstruierte-mindestens-intervallskalierte-variablen" class="section level3">
<h3>Wiederholung: Konstruierte mindestens intervallskalierte Variablen</h3>
<ul>
<li>Fragebogendaten werden meist ordinalskaliert erhoben (einzelne Items)</li>
<li>Um Intervallskalenniveau zu erreichen werden Items zu Skalenwerten verrechnet (Summe oder Mittelwert)</li>
<li>Erzeugt viele mögliche Ausprägungen und wird als intervallskaliert behandelt</li>
</ul>
</div>
<div id="positive-negative-items" class="section level3">
<h3>Positive &amp; Negative Items</h3>
<p>Viele Fragebögen enthalten sowohl positiv als auch negativ formulierte Items,</p>
<ul>
<li>…um die Befragung abwechslungsreich zu gestalten</li>
<li>…um das psychologische Konstrukt umfassender zu erheben</li>
<li>…um Antworttendenzen leichter identifizieren zu können</li>
</ul>
<p>Vor der Skalenbildung müssen alle Items in eine Richtung gebracht werden: Das wird auch als <strong>Rekodierung</strong> bezeichnet.</p>
<p><strong>Beispiel: Fragebogen zur Prokrastionationstendenz</strong></p>
<ul>
<li>Skala soll bei hohen Werten höhere Prokrastinationstendenz darstellen<br />
</li>
<li>Negativ formulierte Items müssen invertiert werden<br />
</li>
<li>Invertierte Items sind 2, 3, 5, 7 und 8</li>
<li>Mögliche Werte von 1 bis 4<br />
</li>
<li>Hierzu kennen Sie bereits zwei Möglichkeiten (mit den Befehlen und R-Kenntnissen aus den bisherigen Sitzungen…)</li>
</ul>
</div>
</div>
<div id="rekodierung" class="section level2">
<h2>Rekodierung</h2>
<p><strong>Variante 1: Lineare Transformation</strong></p>
<pre class="r"><code>fb21$prok2_r &lt;- -1 * (fb21$prok2 - 5)
head(fb21$prok2)     # erste 6 Werte ohne Transformation</code></pre>
<pre><code>## [1] 3 2 3 2 4 3</code></pre>
<pre class="r"><code>head(fb21$prok2_r)   # erste 6 Werte mit Transformation</code></pre>
<pre><code>## [1] 2 3 2 3 1 2</code></pre>
<ul>
<li>Allgemeine Form: <span class="math inline">\(-1 \cdot (x_m - x_{\max} - 1)\)</span><br />
</li>
<li>Vorteil: schnell und einfach umsetzbar<br />
</li>
<li>Nachteil: nur für Invertierung sinnvoll, nicht allgemeiner anwendbar</li>
</ul>
<p><em>Quizfrage</em>: Ist dies eine zulässige Transformation für ordinalskalierte Variablen (wie Items)?<br />
<em>Antwort</em>: Ja, denn die Ordnungsrelation bleibt hierbei erhalten!</p>
<p><strong>Variante 2: Logische Filter</strong></p>
<pre class="r"><code>fb21$prok3_r[fb21$prok3 == 1] &lt;- 4
fb21$prok3_r[fb21$prok3 == 2] &lt;- 3
fb21$prok3_r[fb21$prok3 == 3] &lt;- 2
fb21$prok3_r[fb21$prok3 == 4] &lt;- 1

head(fb21$prok3)</code></pre>
<pre><code>## [1] 3 3 4 3 3 4</code></pre>
<pre class="r"><code>head(fb21$prok3_r)</code></pre>
<pre><code>## [1] 2 2 1 2 2 1</code></pre>
<ul>
<li>Durch logische Filter Personen auswählen, die auf Originalvariable den relevanten Wert haben<br />
</li>
<li>Auf rekodierter Variable neuen Wert zuweisen<br />
</li>
<li>Vorteil: extrem flexibel, jede Transformation möglich<br />
</li>
<li>Nachteil: umständlich zu schreiben</li>
</ul>
<p>Um Code zu sparen, invertieren wir also die restlichen Items mittels der linearen Transformation.</p>
<pre class="r"><code>fb21$prok5_r &lt;- -1 * (fb21$prok5 - 5)
fb21$prok7_r &lt;- -1 * (fb21$prok7 - 5)
fb21$prok8_r &lt;- -1 * (fb21$prok8 - 5)</code></pre>
</div>
<div id="skalenwerte-erstellen" class="section level2">
<h2>Skalenwerte erstellen</h2>
<p>Skalenwerte werden zumeist als Summen oder Mittelwerte der Items erstellt</p>
<p><strong>Skalenwert Prokrastinationstendenz</strong></p>
<pre class="r"><code># Datensatz der relevanten Variablen
prokrastination &lt;- fb21[, c(&#39;prok1&#39;, &#39;prok2_r&#39;, &#39;prok3_r&#39;, &#39;prok4&#39;, &#39;prok5_r&#39;, &#39;prok6&#39;, &#39;prok7_r&#39;, &#39;prok8_r&#39;, &#39;prok9&#39;, &#39;prok10&#39;)]
# Skalenwert in Originaldatensatz erstellen
fb21$prok_ges &lt;- rowMeans(prokrastination)
head(fb21$prok_ges)</code></pre>
<pre><code>## [1] 2.5 2.1 1.7  NA 1.6 2.0</code></pre>
</div>
<div id="nützliche-funktionen-in-diesem-zusammenhang" class="section level2">
<h2>Nützliche Funktionen in diesem Zusammenhang:</h2>
<ul>
<li><code>rowMeans()</code> Mittelwert für jede Zeile (über Variablen)<br />
</li>
<li><code>colMeans()</code> Mittelwert für jede Spalte (über Personen)<br />
</li>
<li><code>rowSums()</code> Summe für jede Zeile (über Variablen)<br />
</li>
<li><code>colSums()</code> Summe für jede Spalte (über Personen)</li>
</ul>
<hr />
</div>
