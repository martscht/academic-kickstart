---
title: "Regression V: nichtlineare Regression - exponentielles Wachstum"
date: '2021-03-30'
slug: nichtlineare-regression
categories:
  - BSc7
tags:
  - nichtlinear
  - exponentiell
  - Regression
subtitle: 'nichtlineare Regression'
summary: ''
authors: [irmer]
lastmod: '2021-04-14T08:32:21+02:00'
featured: no
header:
  image: "/header/PsyBSc7_Reg5.jpg"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/940564)"
projects: []
---



<p>Bisher hatten wir mittels Regressionsanalysen lineare Beziehungen modelliert. In der Sitzung zur <a href="/post/quadratische-und-moderierte-regression">quadratischen und moderierte Regresssion</a> kamen dann im Grunde quadratische Effekte mit hinzu. Wir können unser Wissen über Regressionen allerdings auch nutzen um nichtlineare Effekte zu modellieren. Wie das geht und was zu beachten ist, schauen wir uns im Folgenden an. Dazu laden wir zunächst altbekannte Pakete:</p>
<pre class="r"><code>library(ggplot2) # Grafiken
library(car)     # Residuenplots
library(MASS)    # studres</code></pre>
<div id="einführung-exponentielles-wachstum" class="section level2">
<h2>Einführung: Exponentielles Wachstum</h2>
<p>Ein sehr wichtiges Vorhersagemodell zu Zeiten der Corona-Pandemie oder in Anbetracht von starkem weltweitem Bevölkerungswachstum ist das exponentielle Wachstum. Genauso könnten wir auch die Zahl der Kaiserpinguine der Antarktis modellieren (siehe Foto oben). Um dieses genauer zu verstehen, werden einige Grundlagen im Umgang mit Exponenten benötigt. Zum Beispiel müssen wir uns überlegen, welche Rate und welche Basis ein exponentieller Verlauf hat. Beispielsweise wächst <span class="math inline">\(10^x\)</span> deutlich schneller als <span class="math inline">\(2^x\)</span> (für gleiches wachsendes <span class="math inline">\(x\)</span>).</p>
<details>
<p><summary><strong>Wie gut kennen Sie sich noch mit Exponenten und Logarithmen aus?</strong></summary></p>
<ul>
<li>Die Gleichung <span class="math inline">\(10^x = 100\)</span> können wir bspw. mit dem 10er-Logarithmus <span class="math inline">\(log_{10}(100)\)</span> berechnen. Die Antwort ist 2.</li>
<li>Die Gleichung <span class="math inline">\(10^x = 100\)</span> können wir bspw. mit dem 10er-Logarithmus <span class="math inline">\(log_{10}(100)\)</span> berechnen. Die Antwort ist 3.</li>
<li>Logarithmen können NICHT in einander umgerechnet werden.</li>
<li>Es gilt: <span class="math inline">\(log(a+b)=log(a)log(b)\)</span>.</li>
<li>Es gilt: <span class="math inline">\(log(ab)=log(a)+log(b)\)</span>.</li>
<li><span class="math inline">\(log_a(x)\)</span> ist die Umkehrfunktion zu <span class="math inline">\(a^x\)</span>. Dies bedeutet, dass <span class="math inline">\(log_a(a^x)=x.\)</span></li>
<li>Es gilt: <span class="math inline">\(a^{c+d}=a^c+a^d\)</span>.</li>
<li>Es gilt: <span class="math inline">\(a^{c+d}=a^ca^d\)</span>.</li>
<li>Es gilt immer <span class="math inline">\(a^x &lt; b^x\)</span> für a &lt; b und alle x.</li>
<li>Es gilt immer <span class="math inline">\(a^x &lt; b^x\)</span> für 1 &lt; a &lt; b und alle x.</li>
<li>Es gilt immer <span class="math inline">\(a^x &gt; b^x\)</span> für 0 &lt; a &lt; b &lt; 1 und alle x.</li>
<li>Es gilt immer <span class="math inline">\(a^x &lt; b^x\)</span> für 0 &lt; a &lt; b &lt; 1 und alle x.</li>
</ul>
</details>
<p>Im folgenden Exkurs haben Sie die Möglichkeit Ihr Wissen nochmal aufzufrischen und zu erweitern. Ihnen werden Quellen genannt, in welchen Sie weitere Inhalte nachlesen können. Dieser Exkurs stellt eine Wiederholung dar. Sie können ihn auch überspringen.</p>
<div id="exkurs" class="section level3">
<h3>Exkurs</h3>
<details>
<p><summary><strong>Exponenten und Logarithmen: ein paar Rechenregeln zur Wiederholung</strong></summary></p>
<p>Um eine exponentielle Gleichung nach <span class="math inline">\(x\)</span> aufzulösen wird der Logarithmus verwendet, denn er ist die Umkehrfunktion zum Exponentiellen (siehe beispielsweise hier für eine Wiederholung zum <a href="http://www.mathsisfun.com/algebra/exponents-logarithms.html">Logarithmus und Logarithmusrechenregeln; Pierce (2018)</a>, <a href="http://www.mathsisfun.com/exponent.html">Exponenten; Pierce (2019)</a> oder <a href="http://www.mathsisfun.com/algebra/exponent-laws.html">Exponentenrechenregeln; Pierce (2018)</a>). In der Schule wird zunächst der Logarithmus zur Basis <em>10</em> gelehrt. So kann man die Gleichung <span class="math inline">\(10^x = 100\)</span> leicht auflösen: Dazu müssen beide Seiten (zur Basis <em>10</em>) logarithmiert werden: <span class="math inline">\(\log_{10}(10^x) = \log_{10}(100)\)</span>, denn es gilt im Allgemeinen:</p>
<p><strong>Für Exponenten:</strong></p>
<p><span class="math display">\[a^{b+c}=a^ba^c\]</span>
<span class="math display">\[a^b&lt;a^c \Longrightarrow b&lt;c, \text{ falls }b,c&gt;0\]</span></p>
<p><span class="math display">\[a^{-b}=\frac{1}{a^b}\]</span>
<span class="math display">\[(a^b)^c=a^{bc}=(a^c)^b\]</span>
<span class="math display">\[a^0=1\]</span></p>
<p>Und folglich auch <strong>für Logarithmen:</strong>
<span class="math display">\[\log_a(a)=1\]</span></p>
<p><span class="math display">\[\log_a(bc)=\log_a(b)+\log_a(c)\]</span>
<span class="math display">\[\log_a(\frac{b}{c})=\log_a(b)-\log_a(c)\]</span></p>
<p><span class="math display">\[\log_a(b^c)=c\log_a(b)\]</span></p>
<p><span class="math display">\[x=\log_a(a^x)=a^{\log_a(x)}\]</span>
(hier ist <span class="math inline">\(\log_a\)</span> der Logarithmus zur Basis <span class="math inline">\(a\)</span> und <span class="math inline">\(a, b\)</span> und <span class="math inline">\(c\)</span> sind Zahlen, wobei der Einfachheit halber <span class="math inline">\(a,b,c&gt;0\)</span> gelten soll)</p>
<p>Also rechnen wir: <span class="math inline">\(\log_{10}(10^x) = x\log_{10}(10)=x*1=x\)</span> auf der linken Seite und <span class="math inline">\(\log_{10}(100)=2\)</span> auf der rechten Seite. So erhalten wir <span class="math inline">\(x=2\)</span> als Lösung. Natürlich wussten wir schon vorher, dass <span class="math inline">\(10^2=100\)</span> ergibt; es ist aber eine schöne Veranschaulichung, wofür Logarithmen unter anderem gebraucht werden.</p>
<p>Es muss allerdings nicht immer der richtige Logarithmus zur jeweiligen Basis sein. Eine wichtige Logarithmusrechenregel besagt, dass der Logarithmus zur Basis <span class="math inline">\(a\)</span> leicht mit Hilfe des Logarithmus zur Basis <span class="math inline">\(b\)</span> berechnet werden kann:</p>
<p><span class="math display">\[\log_{a}(x) = \frac{\log_{b}(x)}{\log_{b}(a)},\]</span> siehe bspw. <a href="http://www.mathsisfun.com/algebra/exponents-logarithms.html">Logarithmus und Logarithmusrechenregeln; Pierce (2018)</a>. Da diese Gesetzmäßigkeit gilt, wird in der Mathematik und auch in der Statistik meist nur der natürliche Logarithmus (<em>ln; logarithmus naturalis</em>) verwendet. Die Basis ist hierbei <span class="math inline">\(e\)</span> (<span class="math inline">\(\approx 2.718\dots\)</span>). Mit den obigen Rechenregeln sowie der Rechenregeln für Exponenten können wir jedes exponentielles Wachstum als Wachstum zur Basis <em>e</em> darstellen, denn</p>
<p><span class="math display">\[a^x = e^{\text{ln}(a^x)}=e^{x\text{ln}(a)}\]</span>
z.B ist
<span class="math display">\[10^3=e^{\text{ln}(10^3)}=e^{3\text{ln}(10)}=1000\]</span></p>
<p>Da sich durch <em>e</em> und <em>ln</em> alle exponentiellen Verläufe darstellen lassen, wird in der Mathematik häufig <em>log</em> als das Symbol für den natürlich Logarithmus verwendet; so ist es auch in <code>R</code>: ohne weitere Einstellungen ist <code>log</code> der natürliche Logarithmus und <code>exp</code> ist die Exponentialfunktion. Mit Hilfe von <code>log(..., base = 10)</code> erhalten sie beispielsweise den 10er-Logarithmus. Probieren Sie die obige Gleichung selbst aus:</p>
<pre class="r"><code># gleiches Ergebnis:
10^3</code></pre>
<pre><code>## [1] 1000</code></pre>
<pre class="r"><code>exp(3*log(10))</code></pre>
<pre><code>## [1] 1000</code></pre>
<pre class="r"><code># gleiches Ergebnis:
log(10^3, base = 10) # Logarithmus von 1000 zur Basis 10</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>log(10^3)/log(10) # mit ln</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code># gleiches Ergebnis:
log(9, base = 3) # Logarithmus von 9 zur Basis 3</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>log(9)/log(3) # mit ln</code></pre>
<pre><code>## [1] 2</code></pre>
</details>
</div>
</div>
<div id="das-modellieren-von-exponentiellem-wachstum" class="section level2">
<h2>Das Modellieren von exponentiellem Wachstum</h2>
<p>Wir betrachten nun eine allgemeine exponentielle Wachstumsfunktion <span class="math display">\[f(x) = a\ b^{c\ x}\]</span> (hierbei ist <span class="math inline">\(a\)</span> ein Vorfaktor, der die Ausprägung an der Stelle <span class="math inline">\(x=0\)</span> beschreibt, <span class="math inline">\(b\)</span> ist die Basis des exponentiellen Wachstums und <span class="math inline">\(c\)</span> ist ein <em>eigentlich redundanter</em> Ratenparameter). Wegen der Beliebigkeit der Basis ist dies gleich <span class="math display">\[f(x) = e^{\text{ln}(a\ b^{c\ x})}=e^{\text{ln}(a) + \text{ln}(b)cx}.\]</span> Nun sind <span class="math inline">\(\text{ln}(a)\)</span> und <span class="math inline">\(\text{ln}(b)c\)</span> zwei Konstanten, die wir einfach umbenennen dürfen. Wir können sie beispielsweise <span class="math inline">\(\beta_0\)</span> und <span class="math inline">\(\beta_1\)</span> nennen; also <span class="math inline">\(\beta_0 := \text{ln}(a)\)</span> und <span class="math inline">\(\beta_1:=\text{ln}(b)c\)</span>. Folglich steht <span class="math display">\[f(x) = e^{\beta_0 + \beta_1x}\]</span> für beliebiges exponentielle Wachstum (wir erhalten den Verlauf “<span class="math inline">\(2^x\)</span>” indem wir <span class="math inline">\(\beta_0 = \text{ln}(a) = 0\)</span> und <span class="math inline">\(\beta_1=\text{ln}(b)c = \text{ln}(2)\)</span> wählen; also <span class="math inline">\(a=1, b=2\)</span> und <span class="math inline">\(c=1\)</span>). Gleichzeitig bedeutet dies, dass, durch Logarithmieren, <span class="math display">\[\text{ln}(f(x)) = \beta_0 + \beta_1x\]</span> eine lineare Funktion ist, welche wir ganz einfach mit einer Regressionsanalyse, also <code>lm</code> in <code>R</code>, untersuchen können! Wir können somit sagen, dass wir durch Logarithmieren von <span class="math inline">\(f(x)\)</span> in der Lage sind, das exponentielle Wachstum zu <em>Linearisieren</em>, also das exponentielle Wachstum in eine lineare Funktion zu transformieren, welche mit Auswertungsinstrumenten für lineare Funktionen untersucht werden können. Wahnsinn, oder? Dies bedeutet, dass wir nach Logarithmieren der abhängigen Variable in der Lage sind die gesamte Klasse der exponentiellen Funktionen/des exponentiellen Wachstums für die Modellierung unserer Daten zu verwenden. Die folgenden zwei Grafiken verdeutlichen dies (Der folgende Block ist gedacht, dass Sie diesen kopieren und die Inputparameter verändern und sich den Effekt auf die Grafiken ansehen; die horizontale gestrichelte Linien repräsentiert jeweils den Wert <span class="math inline">\(a\)</span> bzw. <span class="math inline">\(\text{ln}(a)\)</span>, an welchem die Kurve <span class="math inline">\(f\)</span> bzw. <span class="math inline">\(\ln(f)\)</span> die y-Achse schneiden):</p>
<pre class="r"><code>##################
#### Einstellen der Koeffizienten und berechnen von f(x)
#### 
x &lt;- seq(-1,2,0.1) # x = Variablen (als Zahlen zwischen -1 und 2)
a &lt;- 2   # Vorfaktor, der die Ausprägung an der Stelle x=0 beschreibt
b &lt;- 3   #  Basis des exponentiellen Wachstums
c &lt;- 1.5 # *eigentlich redundanter* Ratenparameter
f &lt;- a*b^(c*x) # f(x), eine exponentiell-wachsende Funktion in x

##################
#### Plot von f(x) vs. x
#### 
plot(x = x, y = f, type = &quot;l&quot;, col = &quot;blue&quot;, lwd = 2, main = &quot;Plot von f(x) vs. x&quot;) # plotte f(x) gegen x
abline(v = 0, lwd = 0.7) # y-Achse, v = 0 zeichnet eine vertikale Linie bei x = 0
abline(h = a, lty = 3) # im Punkt a schneidet f (das exponentielle Wachstum) die y-Achse (x=0), h = a zeichnet zu y = a eine horizontale Linie</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-3-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>##################
#### Plot von ln(f(x)) vs. x
#### 
plot(x = x, y = log(f), type = &quot;l&quot;, col = &quot;blue&quot;, lwd = 2, main = &quot;Plot von ln(f(x)) vs. x&quot;) # plotte ln(f(x)) gegen x
abline(v = 0, lwd = 0.7) # y-Achse, v = 0 zeichnet eine vertikale Linie bei x = 0
abline(h = log(a), lty = 3)  # im Punkt log(a) schneidet log(f) (das linearisierte exponentielle Wachstum) die y-Achse (x=0), h =llog(a) zeichnet zu y = log(a) eine horizontale Linie</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-3-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>All dies bedeutet nun, dass wir durch eine sehr simple Transformation der Daten, Schlüsse über exponientielles Wachstum treffen können. Dies schauen wir uns nun an einem inhaltlichen Beispiel an!</p>
<div id="das-modellieren-von-exponentiellem-wachstum-am-beispiel-der-weltbevölkerung-von-1800-bis-2020" class="section level3">
<h3>Das Modellieren von exponentiellem Wachstum am Beispiel der Weltbevölkerung von 1800 bis 2020</h3>
<p>Nun können wir beispielsweise die Entwicklung der Weltbevölkerung von 1800 bis 2020 modellieren. Dazu müssen wir zunächst die Daten laden:
Die Dokumentation des Datensatzes mit Datenquellen sind hier einzusehen: <a href="https://www.gapminder.org/data/documentation/gd003/">gapminder.org-Dokumentationen</a>. Sie können den im Folgenden verwendeten <a href="https://pandar.netlify.app/post/WorldPopulation.rda"><svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 512 512"><path d="M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z"/></svg> Datensatz “WorldPopulation.rda” hier herunterladen</a>.</p>
<div id="daten-laden" class="section level4">
<h4>Daten laden</h4>
<p>Wir laden zunächst die Daten: entweder lokal von Ihrem Rechner:</p>
<pre class="r"><code>load(&quot;C:/Users/Musterfrau/Desktop/WorldPopulation.rda&quot;)</code></pre>
<p>oder wir laden sie direkt über die Website:</p>
<pre class="r"><code>load(url(&quot;https://pandar.netlify.app/post/WorldPopulation.rda&quot;))</code></pre>
<p>Nun sollte in <code>R</code>-Studio oben rechts in dem Fenster unter der Rubrik “Data” unser Datensatz mit dem Namen “<em>WorldPopulation</em>” erscheinen.</p>
</div>
<div id="überblick-über-die-daten" class="section level4">
<h4>Überblick über die Daten</h4>
<p>Schauen wir uns die Daten an:</p>
<pre class="r"><code>head(WorldPopulation)</code></pre>
<pre><code>##   Year Population
## 1 1800  982454635
## 2 1801  985895135
## 3 1802  989555435
## 4 1803  992954135
## 5 1804  995485735
## 6 1805 1000098535</code></pre>
<p>In der ersten Spalte steht das Jahr; in der 2. die Weltbevölkerungsgröße. Wir wollen uns dies grafisch ansehen. Dazu verwenden wir <code>ggplot</code>, um die Population (<code>Population</code>) gegen das Jahr (<code>Year</code>) abzutragen und zwar als Punkte mit <code>geom_point()</code>. Sie können Grafiken mit <code>ggplot2</code> in der <a href="/post/grafiken-mit-ggplot2">zugehörigen Sitzung</a> wiederholen.</p>
<pre class="r"><code>ggplot(data = WorldPopulation, aes(x = Year, y = Population))+geom_point()</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Das Diagramm lässt deutlich einen nichtlinearen Anstieg der Weltbevölkerung von 1800 bis 2020 vermuten. Auffällig ist auch der leichte Knick, der um 1950 zu vermuten ist und ab welchem die Bevölkerung, deskriptiv gesehen, noch stärker wächst. Dieser Knick ist zum Teil durch das Ende des Krieges, aber auch durch modernere Landwirtschaft und das Aufkommen von neuen Medikamenten (z.B. Penicilline) zu erklären.</p>
</div>
</div>
<div id="lineares-modell-für-das-bevölkerungswachstum" class="section level3">
<h3>Lineares Modell für das Bevölkerungswachstum</h3>
<p>Wir wollen uns naiverweise ein lineares Regressionmodell, also einen linearen Verlauf, der Weltbevölkerung vorhergesagt durch das Jahr, ansehen.</p>
<pre class="r"><code>ggplot(data = WorldPopulation, aes(x = Year, y = Population))+
     geom_point()+geom_smooth(method=&quot;lm&quot;, formula = &quot;y~x&quot;)         # plotte linearen Verlauf </code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>m_l &lt;- lm(Population ~ Year, data = WorldPopulation) # linearer Verlauf
summary(m_l)  </code></pre>
<pre><code>## 
## Call:
## lm(formula = Population ~ Year, data = WorldPopulation)
## 
## Residuals:
##        Min         1Q     Median         3Q        Max 
## -1.128e+09 -7.964e+08 -1.629e+08  6.811e+08  2.313e+09 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -4.646e+10  1.801e+09  -25.79   &lt;2e-16 ***
## Year         2.569e+07  9.426e+05   27.26   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 8.94e+08 on 219 degrees of freedom
## Multiple R-squared:  0.7723, Adjusted R-squared:  0.7713 
## F-statistic: 742.9 on 1 and 219 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="r"><code>#########
### Normalverteilung der Residuen?
##
res &lt;- studres(m_l) # Studentisierte Residuen als Objekt speichern
df_res &lt;- data.frame(res) # als Data.Frame für ggplot
# Grafisch: Histogramm mit Normalverteilungskurve
ggplot(data = df_res, aes(x = res)) + 
     geom_histogram(aes(y =..density..),
                    bins = 10,                    # Wie viele Balken sollen gezeichnet werden?
                    colour = &quot;blue&quot;,              # Welche Farbe sollen die Linien der Balken haben?
                    fill = &quot;skyblue&quot;) +           # Wie sollen die Balken gefüllt sein?
     stat_function(fun = dnorm, args = list(mean = mean(res), sd = sd(res)), col = &quot;darkblue&quot;) + # Füge die Normalverteilungsdiche &quot;dnorm&quot; hinzu und nutze den empirischen Mittelwert und die empirische Standardabweichung &quot;args = list(mean = mean(res), sd = sd(res))&quot;, wähle dunkelblau als Linienfarbe
     labs(title = &quot;Histogramm der Residuen mit Normalverteilungsdichte\n für das lineare Modell&quot;, x = &quot;Residuen&quot;) # Füge eigenen Titel und Achsenbeschriftung hinzu</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-8-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Durch <code>+ geom_smooth(method="lm", formula = "y~x")</code>, kann mit <code>ggplot</code> ein linearer Trend inklusive Konfidenzintervall hinzugefügt werden. Obwohl ein linearer Verlauf sehr unwahrscheinlich erscheint, können mit dem linearen Modell bereits 77.23% der Variation der Bevölkerungsdichte durch die Jahreszahl erklärt werden (entnommen aus der Summary des linearen Modells unter <code>Multiple R-squared:  0.7723</code>). Wie der Grafik deutlich zu entnehmen ist, sind die Residuen in dieser Regressionsanalyse stark abhängig von der Jahreszahl (negatives Residuum von ca. 1860-1970 und positive Residuen sonst; <em>Wiederholung</em>: <span class="math inline">\(\varepsilon_i=Y_i-\hat{Y}_i\)</span>, wobei <span class="math inline">\(\hat{Y}_i\)</span> der vorhergesagte Wert ist, das Vorzeichen erhalten wir also, indem wir uns überlegen, wann die Daten oberhalb oder unterhalb der vorhergesagten Geraden liegen). Auch wenn wir uns das zugehörige Histogramm der Residuen ansehen, widerspricht dieses der Annahme auf Normalverteilung. In <a href="#AppendixA">Appendix A</a> ist auch ein quadratische Trend hinzugefügt, da wir ja in der vergangenen Sitzung zu <a href="/post/quadratische-und-moderierte-regression">quadratischer oder moderierter Regression</a> gesehen hatten, dass durch das Hinzufügen von quadratischen Effekten die Vorhersage des Kriteriums verbessert werden kann. Wir interessieren uns jetzt aber erstmal für das exponentielle Wachstum!</p>
</div>
<div id="exponentielles-modell-für-das-bevölkerungswachstum" class="section level3">
<h3>Exponentielles Modell für das Bevölkerungswachstum</h3>
<p>Nun wollen wir prüfen, ob ein exponentieller Verlauf die Daten besser beschreibt. Dazu müssen wir zunächst die Weltpopulation logarithmieren und können anschließend ein lineares Modell verwenden. Wir transformieren hierzu die Variablen und speichern diese als weitere Spalte in unserem Datensatz mit dem Namen <code>log_Population</code> ab:</p>
<pre class="r"><code>WorldPopulation$log_Population &lt;- log(WorldPopulation$Population) # Logarithmus der Weltbevölkerung</code></pre>
<p>Wir wollen anschließend ein einfaches Regressionsmodell schätzen, in welchem die logarithmierte Bevölkerungszahl die abhängige Variable darstellt. Das <code>lm</code> Objekt speichern wir hierzu unter dem Namen <code>m_log</code> ab und schauen uns die <code>summary</code> für <code>m_log</code> an.</p>
<pre class="r"><code>m_log &lt;- lm(log_Population ~ Year, data = WorldPopulation) # lineares Modell mit log(y) als AV (logarithmische Skala)
summary(m_log)</code></pre>
<pre><code>## 
## Call:
## lm(formula = log_Population ~ Year, data = WorldPopulation)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.20453 -0.16471 -0.02055  0.15678  0.27406 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) 3.781382   0.328712   11.50   &lt;2e-16 ***
## Year        0.009265   0.000172   53.87   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.1631 on 219 degrees of freedom
## Multiple R-squared:  0.9298, Adjusted R-squared:  0.9295 
## F-statistic:  2902 on 1 and 219 DF,  p-value: &lt; 2.2e-16</code></pre>
<p><em>Es wäre auch möglich gewesen, die Daten nicht vorher zu transformieren, sondern einfach, wie in der letzten Sitzung erwähnt, <code>I(log(...))</code> auf die abhängige Variable anzuwenden:</em></p>
<pre class="r"><code>m_log2 &lt;- lm(I(log(Population)) ~ Year, data = WorldPopulation) # lineares Modell mit log(y) als AV (logarithmische Skala)
summary(m_log2)</code></pre>
<pre><code>## 
## Call:
## lm(formula = I(log(Population)) ~ Year, data = WorldPopulation)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.20453 -0.16471 -0.02055  0.15678  0.27406 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) 3.781382   0.328712   11.50   &lt;2e-16 ***
## Year        0.009265   0.000172   53.87   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.1631 on 219 degrees of freedom
## Multiple R-squared:  0.9298, Adjusted R-squared:  0.9295 
## F-statistic:  2902 on 1 and 219 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Das lineare Modell für die logarithmierte Bevölkerungsdichte scheint gut zu den Daten zu passen. Insgesamt können 92.98 % der Variation in den Daten durch den Zeitverlauf erklärt werden — deutlich mehr, als durch den linearen Verlauf! Die zugehörige Grafik des logarithmierten Modells sieht so aus:</p>
<pre class="r"><code>ggplot(data = WorldPopulation, aes(x = Year, y = log_Population))+
     geom_point()+geom_smooth(method=&quot;lm&quot;, formula = &quot;y~x&quot;, col = &quot;red&quot;)+
  labs(title = &quot;Logarithmierte Weltbevölkerung vs. Jahr&quot;)</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>So sind die Ergebnisse aber sehr schwer mit dem linearen Trend zu vergleichen. Wir wollen die Vorhersage auch retransformiert plotten, um sie mit dem linearen Verlauf grafisch vergleichen zu können. Dazu müssen wir die vorhergesagten Werte unseres logarithmischen Modells verwenden und mit mit der Umkehrfunktion des Logarithmus retransformieren. Diese können wir einem <code>lm</code>-Objekt mit <code>predict</code> entlocken. <code>predict</code> berechnet die vorhergesagten Kriteriumswerte via <span class="math inline">\(\hat{Y}_i=\hat{\beta}_0+\hat{\beta}_1X_i\)</span>, wobei für unser Beispiel <span class="math inline">\(Y_i=\)</span> ln(Bevölkerung) im <span class="math inline">\(i\)</span>-ten Jahr und <span class="math inline">\(X_i=\)</span> <span class="math inline">\(i\)</span>-tes Jahr gilt. Da wir zuvor logarithmiert hatten, müssen wir nun die Exponentialfunktion auf unsere vorhergesagten Werte anwenden: also quasi: <span class="math inline">\(e^{\hat{Y}_i}\)</span>, bzw. <span class="math inline">\(e^{\hat{\beta}_0+\hat{\beta}_1X_i}\)</span>. Wir nennen die neue Variable <code>pred_Pop_exp</code>, wobei <code>pred</code> für <em>predicted</em> und <code>Pop_exp</code> für <em>exponentielles Populationswachstum</em> steht:</p>
<pre class="r"><code>WorldPopulation$pred_Pop_exp &lt;- exp(predict(m_log)) # Abspeichern der retransformierten vorhergesagten Werten (wieder auf der Skala der Weltbevölkerung)
head(WorldPopulation)</code></pre>
<pre><code>##   Year Population log_Population pred_Pop_exp
## 1 1800  982454635       20.70556    768019076
## 2 1801  985895135       20.70906    775168245
## 3 1802  989555435       20.71277    782383962
## 4 1803  992954135       20.71620    789666848
## 5 1804  995485735       20.71874    797017526
## 6 1805 1000098535       20.72336    804436629</code></pre>
<p>Dem Datensatz haben wir nun eine neue Spalte hinzugefügt, welche die vorhergesagten Populationswerte enthält (retransformiert; nicht mehr in Log-Skala). Nun schauen wir uns den exponentiellen sowie den linearen Trend für die Bevölkerungszahl an:</p>
<pre class="r"><code>ggplot(data = WorldPopulation, aes(x = Year, y = Population))+
     geom_point()+geom_smooth(method=&quot;lm&quot;, formula = &quot;y~x&quot;)+         # plotte linearen Verlauf 
     geom_line(aes(x = Year, y = pred_Pop_exp), col = &quot;red&quot;, lwd = 1.5)</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-14-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Das Diagramm der retransformierten vorhergesagten Werten signalisiert, dass ein exponentielles Wachstumsmodell die Daten gut beschreibt. Wir können die Parameter des logarithmischen Modells auch in die Bevölkerungsskala (weg von der log-Skala) übersetzen. Dazu nutzen wir wieder eine Logarithmus/Exponentenregel: <span class="math inline">\(e^{a+b}=e^ae^b\)</span>. Also ist <span class="math inline">\(e^{\hat{\beta_0}}\)</span> die Bevölkerung zum Jahr 0 und <span class="math inline">\(e^{\hat{\beta}_1}\)</span> die Veränderung der Bevölkerung (multiplikativ), wenn die Jahreszahl um eine Einheit erhöht wird. Wir können dies leicht wie folgt umsetzen:</p>
<pre class="r"><code>exp(coef(m_log))</code></pre>
<pre><code>## (Intercept)        Year 
##   43.876618    1.009309</code></pre>
<p>Hier entlocken wir zunächst dem Objekt <code>m_log</code> die Koeffizienten unseres Modells und wenden anschließend die Exponentialfunktion darauf an. Die Bevölkerung im Jahre 0 lag laut Modell bei 44 Personen und wächst jede Jahr (multiplikativ) um den Faktor 1.0093. Wir erkennen, dass das Modell nicht sehr realistische Vorhersagen für das Jahr 0 treffen kann. Das ist also zu ignorieren, da das Jahr 0 1800 Jahre vom Beobachtungszeitraum entfernt liegt. Schauen wir uns lieber die Veränderung von Jahr zu Jahr an. Der multiplikative Veränderungsfaktor von 1.0093 zeigt uns, dass die Bevölkerung laut Modell jedes Jahr (die Interpretation für Regressionen bleibt gleich, wir erhöhen den Prädiktor um 1 und schauen, wie sich das Kriterium verändert!) um 9.3‰ (Achtung, hier steht Promille, das sind 0.93%) steigt (das haben wir am positiven Vorzeichen von <span class="math inline">\(\hat{\beta}_1\)</span> erkannt, bzw. das erkennen wir auch daran, dass <span class="math inline">\(e^{\hat{\beta}_1}&gt;1\)</span> gilt). Das erscheint zunächst als super wenig, aber die Bevölkerungszahlen im tatsächlich beobachteten Zeitraum liegen zwischen knapp unterhalb einer Milliarde und 7 Milliarden. Von einer Milliarde sind 0.93% immerhin 9300000 (9.3 Millionen) und von 7 Milliarden entsprechend das 7-fache!</p>
<p>Die Vorhersage erscheint augenscheinlich sehr viel besser als der lineare Trend. Wir schauen uns dazu die Residuen des logarithmischen Modells an.</p>
<pre class="r"><code>residualPlot(m_log, col = &quot;red&quot;) # Residualplot</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/exercise_resid_mlog-solution-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Dem Residualplot ist zu entnehmen, dass ggf. sogar ein nicht-linearer Verlauf angemessen wäre. Wir gehen dieser Vermutung nach, indem wir dem Log-Plot einen quadratischen Verlauf hinzufügen. Auch dem <code>geom_smooth</code> Befehl kann einfach das modifizierte Regressionsmodell übergeben werden. Dem Argument <code>formula</code> müssen wir dazu jediglich die Formel für die Regression übergeben, wobei <code>y</code> das Kriterium und <code>poly(x,2)</code> (dies hatten wir in der vergangen Sitzung zu <a href="/post/quadratische-und-moderierte-regression">quadratischer oder moderierter Regression</a> kennengelernt) der Prädiktor mit linearem und quadratischen Anteil beschreibt. Mit <code>col = "gold3"</code> wird die neue Linie auch extra eingefärbt.</p>
<pre class="r"><code>ggplot(data = WorldPopulation, aes(x = Year, y = log_Population))+
     geom_point()+geom_smooth(method=&quot;lm&quot;, formula = &quot;y~x&quot;, col = &quot;red&quot;)+
  geom_smooth(method=&quot;lm&quot;, formula = &quot;y~poly(x,2)&quot;, col = &quot;gold3&quot;)+
  labs(title = &quot;Logarithmierte Weltbevölkerung vs. Jahr&quot;)</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-16-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Vielleicht wächst die Bevölkerung sogar schneller als exponentiell? Die gelbe Linie im logarithmierten Plot lässt dies vermuten. Um dies genauer zu untersuchen fügen wir in das logarithmierte Modell einen quadratischen Trend der Zeit ein.</p>
</div>
<div id="quadratisch-exponentielles-modell-für-das-bevölkerungswachstum" class="section level3">
<h3>Quadratisch-exponentielles Modell für das Bevölkerungswachstum</h3>
<p>Dies wollen wir schätzen, indem wir im Regressionsmodell der logarithmierten Populationsgröße einen quadratischen Trend (<code>poly(...,2)</code>) für die Zeit definieren. Das Modell nennen wir, mein unbegrenztes Einfallsreichtum beweisend, <code>m_log_quad</code>:</p>
<pre class="r"><code>m_log_quad &lt;- lm(log_Population ~ poly(Year, 2), data = WorldPopulation) # lineares Modell mit log(y) als AV (logarithmische Skala)
summary(m_log_quad)</code></pre>
<pre><code>## 
## Call:
## lm(formula = log_Population ~ poly(Year, 2), data = WorldPopulation)
## 
## Residuals:
##       Min        1Q    Median        3Q       Max 
## -0.097348 -0.037302  0.008814  0.039090  0.070984 
## 
## Coefficients:
##                 Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)    21.478533   0.003111 6903.34   &lt;2e-16 ***
## poly(Year, 2)1  8.787459   0.046253  189.99   &lt;2e-16 ***
## poly(Year, 2)2  2.315495   0.046253   50.06   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.04625 on 218 degrees of freedom
## Multiple R-squared:  0.9944, Adjusted R-squared:  0.9943 
## F-statistic: 1.93e+04 on 2 and 218 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Wir können dieses Modell nun gegen <code>m_log</code> testen und so die Modellverbesserung des quadratisch exponentiellen Verlaufs auf Signifikanz prüfen (und zwar mit dem <code>anova</code>-Befehl).</p>
<pre class="r"><code>anova(m_log, m_log_quad)</code></pre>
<pre><code>## Analysis of Variance Table
## 
## Model 1: log_Population ~ Year
## Model 2: log_Population ~ poly(Year, 2)
##   Res.Df    RSS Df Sum of Sq      F    Pr(&gt;F)    
## 1    219 5.8279                                  
## 2    218 0.4664  1    5.3615 2506.1 &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Durch den quadratisch-exponentiellen Verlauf (bzw. den quadratischen Verlauf in den logarithmierten Daten) lassen sich 99.44% der Variation der Bevölkerungsdichte erklären, was einem signifikantem Varianzinkrement von 6.46% im Vergleich zum reinen exponentiellen Verlaufsmodell entspricht. Interessant zu sehen ist, dass fast 100% der Variation im Datensatz erklärbar ist. Eine Übersicht über <span class="math inline">\(R^2\)</span> in den Modellen ist in <a href="#AppendixB">Appendix B</a> einzusehen.</p>
<p>Stellen wir dies grafisch dar. Dazu müssen wir wieder die Vorhersage abspeichern. Diese können wir einem <code>lm</code>-Objekt mit <code>predict</code> entlocken. Wir nennen die neue Variable einfach <code>pred_Pop_exp_quad</code>.</p>
<pre class="r"><code>WorldPopulation$pred_Pop_exp_quad &lt;- exp(predict(m_log_quad)) # Abspeichern der retransformierten vorhergesagten Werten (wieder auf der Skala der Weltbevölkerung)
head(WorldPopulation)</code></pre>
<pre><code>##   Year Population log_Population pred_Pop_exp pred_Pop_exp_quad
## 1 1800  982454635       20.70556    768019076        1082904426
## 2 1801  985895135       20.70906    775168245        1082790682
## 3 1802  989555435       20.71277    782383962        1082769604
## 4 1803  992954135       20.71620    789666848        1082841189
## 5 1804  995485735       20.71874    797017526        1083005453
## 6 1805 1000098535       20.72336    804436629        1083262439</code></pre>
<p>Dem Datensatz haben wir nun eine neue Spalte hinzugefügt, welche die vorhergesagten Populationswerte enthält, die durch das quadratisch-exponentielle Modell vorhergesagt werden (retransformiert; nicht mehr in Log-Skala). Im Folgenden ist die finale Grafik mit dem linearen, exponentiellen und dem quadratisch-exponentiellen Verlauf dargestellt. Außerdem schauen wir uns den Residuenplot des quadratisch-exponentiellen Modells an (in logarithmierter Skala, in welcher das Modell auch geschätzt wurde!).</p>
<pre class="r"><code>ggplot(data = WorldPopulation, aes(x = Year, y = Population))+
     geom_point()+geom_smooth(method=&quot;lm&quot;, formula = &quot;y~x&quot;)+         # plotte linearen Verlauf 
     geom_line(aes(x = Year, y = pred_Pop_exp), col = &quot;red&quot;, lwd = 1.5)+
     geom_line(aes(x = Year, y = pred_Pop_exp_quad), col = &quot;gold3&quot;, lwd = 2)</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code># nur quadratisch-exponentiell
ggplot(data = WorldPopulation, aes(x = Year, y = Population))+
     geom_point()+
     geom_line(aes(x = Year, y = pred_Pop_exp_quad), col = &quot;gold3&quot;, lwd = 2)+
  labs(title = &quot;Beobachtetes und durch das quadratisch-exponentielle Modell\n vorhergesagtes Bevölkerungswachstum&quot;)</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-18-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code># Residuenplot
residualPlot(m_log_quad)</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-18-3.png" width="672" style="display: block; margin: auto;" /></p>
<p>Es ist deutlich zu sehen, dass der Knick um 1950 durch das quadratisch-exponentielle Wachstum am besten darzustellen/ zu modellieren ist. Die Residuenplots zeigen außerdem, dass auch hier die Residuen nicht vollständig unsystematisch sind. Dennoch ist die Resiudalvarianz sehr klein. Dies erkennen wir an der y-Achse.</p>
<p>Da die Modelle des linearen und des exponentiellen bzw. quadratisch-exponentiellen Verlaufs nicht geschachtelt sind (<em>sie gehen nicht auseinander hervor und sind nicht durch Restringieren, bzw. Nullsetzen, von Regressionsparametern aus einander überführbar</em>), können sie nicht inferenzstatistisch miteinander verglichen werden. Da das quadratisch-exponentielle Modell mehr Variation aufklärt als die übrigen Modelle und auch grafisch besser zum Verlauf der Daten passt (<em>besonders von 1800 bis ca. 1850 sagt das quadratische Modell ein Verkleinern der Bevölkerung vorher</em>), entscheiden wir uns final für dieses. Allerdings beschreibt ein solches Modell die Daten oft nur lokal am besten — das bedeutet so viel wie, dass wenn wir sehr weit in die Vergangenheit oder Zukunft schauen, sagt dieses Modell ggf. die Bevölkerung nicht mehr sinnvoll vorher.</p>
</div>
<div id="parameterinterpretation-des-quadratisch-exponentielles-modell-für-das-bevölkerungswachstum" class="section level3">
<h3>Parameterinterpretation des quadratisch-exponentielles Modell für das Bevölkerungswachstum</h3>
<p>Was bedeuten nun die Parameter in unserem quadratisch-exponentiellen Modell? Der Regressionskoeffizient des linearen Trends von <code>poly</code> liegt bei 8.79 und der Koeffizient des quadratischen Trends bei 2.32. Dies spricht für ein <strong>beschleunigtes exponentielles Wachstum</strong>. Nach diesem Vorhersagemodell scheinen die Menschen sich schneller als exponentiell zu vermehren (zumindest von 1800 bis 2020). Eine Übersicht über die Modelle sehen Sie in <a href="#AppendixC">Appendix C</a>.</p>
<p>Wären beide Koeffizienten negativ, so würde dies für <em>beschleunigten exponentiellen Zerfall/Abnahme</em> sprechen. Ist der Koeffizient des quadratische Trends negativ, wird von <em>exponentiellem Wachstum mit Dämpfung</em> gesprochen.</p>
<p>Final ist zu sagen, dass die Menschheit am wahrscheinlichsten exponentiell wächst. Ein quadratisches Modell ist im Allgemeinen nicht sinnvoll (siehe <a href="#AppendixA">Appendix A</a>). Da wir uns in dieser Übung nur einen kleine Zeitausschnitt angesehen haben, kam es zu diesen Abweichungen. Allerdings würde das geschätzte quadratische Modell für das Jahr <code>0</code> eine Bevölkerungszahl von 7.88<span class="math inline">\(*10^{11}\)</span> vorhersagen, was absolut nicht sinnvoll ist.</p>
<p>Den gesamten <code>R</code>-Code, der in dieser Sitzung genutzt wird, können Sie <a href="https://raw.githubusercontent.com/jpirmer/PsyBSc7/master/R-Scripts/PsyBSc7_Reg5_RCode.R"><svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 512 512"><path d="M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z"/></svg> hier herunterladen</a>.</p>
<hr />
</div>
</div>
<div id="AppendixA" class="section level2">
<h2>Appendix A</h2>
<details>
<p><summary><strong>Quadratisches Modell für das Bevölkerungswachstum</strong></summary></p>
<p>Vielleicht ist in den Daten anstatt eines exponentiellen Trends ein quadratischer Effekt versteckt? Wir möchten dem auf den Grund gehen und nutzen wieder die Funktion <code>poly</code>, um ein Polynom 2. Grades (eine quadratische Funktion) der Jahreszahl in unsere Analysen mit aufzunehmen.</p>
<pre class="r"><code>m_q &lt;- lm(Population ~ poly(Year,2), data = WorldPopulation) # quadratischer Verlauf
summary(m_q)</code></pre>
<pre><code>## 
## Call:
## lm(formula = Population ~ poly(Year, 2), data = WorldPopulation)
## 
## Residuals:
##        Min         1Q     Median         3Q        Max 
## -646432518 -267430205   89039661  288698332  475103733 
## 
## Coefficients:
##                 Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)    2.617e+09  2.120e+07  123.47   &lt;2e-16 ***
## poly(Year, 2)1 2.437e+10  3.152e+08   77.32   &lt;2e-16 ***
## poly(Year, 2)2 1.238e+10  3.152e+08   39.30   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 315200000 on 218 degrees of freedom
## Multiple R-squared:  0.9718, Adjusted R-squared:  0.9716 
## F-statistic:  3761 on 2 and 218 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Das Varianzinkrement im Vergleich zum linearen Verlauf beläuft sich auf:</p>
<pre class="r"><code>summary(m_q)$r.squared - summary(m_l)$r.squared  # Inkrement </code></pre>
<pre><code>## [1] 0.1995076</code></pre>
<p>Da der Parameter des quadratischen Anteils signifikant ist, gehen wir davon aus, dass das Modell durch den quadratischen Verlauf verbessert wird. Wir sichern dies noch einmal mit einem Modellvergleich ab:</p>
<pre class="r"><code>anova(m_l, m_q)</code></pre>
<pre><code>## Analysis of Variance Table
## 
## Model 1: Population ~ Year
## Model 2: Population ~ poly(Year, 2)
##   Res.Df        RSS Df  Sum of Sq      F    Pr(&gt;F)    
## 1    219 1.7504e+20                                   
## 2    218 2.1652e+19  1 1.5338e+20 1544.3 &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Dies ist der Modellvergleich des linearen und des quadratischen Modells. Hier sollte dem anova-Befehl immer das “kleinere” (restriktivere) Modell (mit weniger Prädiktoren und Parametern, die zu schätzen sind) zuerst übergeben werden. Hier: <code>m_l</code>, da sonst die df negativ sind und auch die Änderung in den <code>Sum of Sq</code> (Quadratsumme) negativ sind! <code>R</code> erkennt dies zwar und testet trotzdem die richtige Differenz auf Signifikanz, aber wir wollen uns besser vollständig korrekt aneignen!</p>
<p>Auch dem <code>geom_smooth</code> Befehl kann einfach das modifizierte Regressionsmodell übergeben werden. Stellen Sie die Weltbevölkerung sowie das lineare und das quadratische Modell dar und färben Sie die Kurve in dunkelblau (<code>col = "darkblue"</code>).</p>
<pre class="r"><code>ggplot(data = WorldPopulation, aes(x = Year, y = Population))+
     geom_point()+geom_smooth(method=&quot;lm&quot;, formula = &quot;y~x&quot;)+         # plotte linearen Verlauf 
     geom_smooth(method=&quot;lm&quot;, formula = &quot;y~poly(x,2)&quot;, col = &quot;darkblue&quot;)  # plotte quadratischen Verlauf</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/exercise_graph_pop_quad-solution-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Durch den quadratischen Verlauf lassen sich 97.18% der Variation der Bevölkerungsdichte erklären, was einem signifikantem Varianzinkrement von 19.95% entspricht (<em>mit einer Irrtumswahrscheinlichkeit von 5% ist das Inkrement in der Population nicht null.</em> Dies ist äquivialent zu folgdender Aussage: <em>mit einer Irrtumswahrscheinlichkeit von 5% ist der Effektparameter (der Regressionskoeffizient) des quadratischen Verlaufs in der Population nicht null</em>; dies spricht folglich für einen quadratischen im Gegensatz zu einem linearen Verlauf). Der Grafik ist deutlich zu entnehmen, dass der quadratische Verlauf nicht weit vom empirischen entfernt liegt.</p>
<p>Den quadratischen Verlauf können wir, wie auch den linearen, nicht inferenzstatistisch gegen den exponentiellen Verlauf testen. Dies liegt daran, dass die Modelle nicht auseinander hervorgehen (sie sind nicht geschachtelt). Allerdings war es so, dass das lineare Modell für die logarithmierte Bevölkerungsdichte zwar gut zu den Daten zu passen schien. Insgesamt können 92.98 % der Variation in den Daten durch den Zeitverlauf erklärt werden — das war allerdings etwas weniger als durch das quadratische Wachstum, durch welches 97.18 % der Variation in den Daten durch den Zeitverlauf erklärt werden konnten.</p>
<pre class="r"><code>ggplot(data = WorldPopulation, aes(x = Year, y = Population))+
     geom_point()+geom_smooth(method=&quot;lm&quot;, formula = &quot;y~x&quot;)+         # plotte linearen Verlauf 
     geom_smooth(method=&quot;lm&quot;, formula = &quot;y~poly(x,2)&quot;, col = &quot;darkblue&quot;)+  # plotte quadratischen Verlauf
     geom_line(aes(x = Year, y = pred_Pop_exp), col = &quot;red&quot;, lwd = 1.5)</code></pre>
<p><img src="/post/2021-04-14_Regression-V_files/figure-html/unnamed-chunk-22-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Das Diagramm der retransformierten vorhergesagten Werten signalisiert, dass ein exponentielles Wachstumsmodell die Daten gut beschreibt, allerdings scheint der quadratische Trend vor allem ab ca. 1975 die Daten besser zu beschreiben.</p>
</details>
</div>
<div id="AppendixB" class="section level2">
<h2>Appendix B</h2>
<details>
<p><summary><strong>Übersicht über erklärte Varianzanteile</strong></summary></p>
<p>Hier sind nochmals die Anteile erklärter Varianz der Bevölkerungsdichte über die Zeit in den vier betrachteten Modellen dargestellt:</p>
<pre class="r"><code>R2 &lt;- rbind(summary(m_l)$r.squared,
            summary(m_q)$r.squared,
            summary(m_log)$r.squared,
            summary(m_log_quad)$r.squared)
rownames(R2) &lt;- c(&quot;linear&quot;, &quot;quadratisch&quot;, &quot;exponentiell (log. Modell)&quot;, &quot;quadratisch-exponentiell (quadratisches log. Modell)&quot;)
colnames(R2) &lt;- &quot;R^2&quot;
round(R2, 4)</code></pre>
<pre><code>##                                                         R^2
## linear                                               0.7723
## quadratisch                                          0.9718
## exponentiell (log. Modell)                           0.9298
## quadratisch-exponentiell (quadratisches log. Modell) 0.9944</code></pre>
</details>
</div>
<div id="AppendixC" class="section level2">
<h2>Appendix C</h2>
<details>
<p><summary><strong>Übersicht über die Modelle</strong></summary></p>
<p>Die angenommenen Modell pro Messzeitpunkt <span class="math inline">\(i\)</span> sind von der Konzeption deutlich verschieden. Insbesondere der Regressionfehler ist an einer anderen Stelle:</p>
<ul>
<li><p><strong>Lineares Modell</strong>: <span class="math inline">\(Y_i = \beta_0 + \beta_1t_i + \varepsilon_i\)</span></p></li>
<li><p><strong>Quadratisches Modell</strong>: <span class="math inline">\(Y_i = \beta_0 + \beta_1t_i^* + \beta_2t_i^{*2} + \varepsilon_i\)</span>. Hier wurde mit <code>poly(...,2)</code> eine Transformation der Variable Zeit vorgenommen, was hier durch “<span class="math inline">\(^*\)</span>” dargestellt werden soll.</p></li>
<li><p><strong>Logarithmisches Modell</strong>: <span class="math inline">\(\text{ln}(Y_i) = \beta_0 + \beta_1t_i + \varepsilon_i\)</span> bzw. retransformiert <span class="math inline">\(Y_i = e^{\beta_0 + \beta_1t_i + \varepsilon_i} = e^{\beta_0} e^{\beta_1t_i} \ e^{\varepsilon_i}\)</span>. Diesem Modell ist zu entnehmen, dass sich der Fehler in Abhängigkeit von der Ausprägung der unabhängigen Variablen (hier: <span class="math inline">\(t_i\)</span>) unterschiedlich stark auf das Kriterium (die abhängige Variable, hier die Bevölkerungszahl) auswirkt - er hängt also mit der Ausprägung der unabhängigen Variable zusammen. Dies ist im logarithmierten Modell nicht mehr der Fall; es handelt sich hier bis auf die Transformation der abhängigen Variable um ein “normales” Regressionsmodell: Hier verliert sich diese Beziehung zwischen unabhängiger Variable und Fehler!</p></li>
<li><p><strong>Logarithmisches Modell mit quadratischem Term</strong>: <span class="math inline">\(\text{ln}(Y_i) = \beta_0 + \beta_1t_i^* + \beta_2t_i^{*2} + \varepsilon_i\)</span> bzw. retransformiert <span class="math inline">\(Y_i = e^{\beta_0 + \beta_1t_i^* + \beta_2t_i^{*2} + \varepsilon_i}\)</span>. Hier wurde mit <code>poly(...,2)</code> eine Transformation der Variable Zeit vorgenommen, was hier durch “<span class="math inline">\(^*\)</span>” dargestellt werden soll.</p></li>
</ul>
</details>
</div>
