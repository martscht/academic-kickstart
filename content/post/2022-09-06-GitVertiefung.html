---
title: Git-Vertiefung 
date: '2022-09-06'
slug: vertiefung
categories:
  - "gitintro"
tags: []
subtitle: ''
summary: ''
authors: [nehler, schloter, rouchi]
featured: no
header:
  image: "/header/smartgit.jpg" 
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/282666)"
projects: []
publishDate: '2022-09-06'
---



<div id="weiterführende-funktionen" class="section level1">
<h1>Weiterführende Funktionen</h1>
<p><span style="color: darkred;"><strong>Git</strong></span> und <span style="color: darkred;"><strong>SmartGit</strong></span> können natürlich noch viel mehr als ihr es in den letzten Abschnitten gelernt habt. In diesem Kapitel stehen ein paar der nützlichsten Funktionen, die beide Instanzen noch zu bieten haben. Unter anderem auch wie man den letzten <code>Commit</code> rückgängig machen kann, wenn man einen Fehler gemacht hat.</p>
<div id="discard" class="section level5">
<h5><code>Discard</code></h5>
<p>Über <code>discard</code>, können wir Änderungen, die wir an den Dateien vorgenommen haben, verwerfen. Wir würden dadurch wieder zu der Version der Datei zurückkehren, die im letzten <code>commit</code> enthalten ist. Wichtig ist, dass es somit hier um Änderungen an der Datei geht, die noch nicht in einem <code>commit</code> verarbeitet wurden.</p>
<p>Um das Ganze zu testen, müssen wir zunächst eine Änderung an einer lokalen Datei vornehmen. Beispielsweise fügen wir in unsere Auswertungsdatei eine neue Zeile Code ein.</p>
<p><img src="/post/smartgit_discard_filechange2.png" /></p>
<p>Die Änderung wird nun in <span style="color: darkred;"><strong>SmartGit</strong></span> angezeigt, indem die Datei als “Modified” bezeichnet wird.</p>
<p><img src="/post/smartgit_discard_modified.png" /></p>
<p>Nun könnten wir die Änderungen in der Datei in einen <code>commit</code> packen und dann auch einen <code>push</code> durchführen. In diesem Fall gehen wir nun aber davon aus, dass wir bemerken, dass unsere Änderung nicht gut ist und wieder rückgängig gemacht werden sollte. Natürlich könnte man die Datei öffnen und die Zeile einfach wieder raus löschen. Das ist in diesem Fall recht simpel, kann aber bei komplexeren Änderungen sehr langwierig sein. Hier kann man über <code>discard</code> nun also sehr schnell zum Stand des letzten <code>commit</code> zurückkehren. Der Button für den <code>discard</code> ist auch in der Werkzeugsleiste enthalten. Am besten wählt ihr vor dem Klicken die betreffende/n Datei/en bereits aus.</p>
<p><img src="/post/smartgit_discard_symbol.png" /></p>
<p>Bei der Auswahl gibt es im Dialogfenster dann zwei Unteroptionen:</p>
<ol style="list-style-type: decimal">
<li><strong>Discard</strong>: Wenn die Veränderungen nicht mehr benötigt werden, reicht diese Option aus. Hier werden alle Änderungen rückgängig gemacht und die Datei ist wieder auf dem alten Stand des letzten <code>commits</code>.</li>
<li><strong>Discard to Stash</strong>: Hierbei wird die veränderte Datei nicht unwiderruflich gelöscht, sondern dem <code>Stash</code> - quasi einem Papierkorb - hinzugefügt. Von hier aus können die veränderten Dateien wieder abgerufen werden, falls man sie doch noch benötigt.</li>
</ol>
<p><img src="/post/smartgit_discard_options.png" /></p>
<p>Die bessere Option müsst ihr also von Fall zu Fall selbst wählen. Da es bei der Auswahl von <code>discard</code> keine weiteren Schritte geht, gibt es dazu auch keine weitere Aussage und wir wählen im Tutorial jetzt <em>Discard to Stash</em>. Es folgt eine kleine Änderung in der <span style="color: darkred;"><strong>SmartGit</strong></span>-Ansicht und zwar im Fenster zu den <strong>Branches</strong>. Hier erscheint der neue Punkt <strong>Stashes</strong>. Wenn wir auf diesen draufklicken, werden Datum und Uhrzeit angezeigt.</p>
<p><img src="/post/smartgit_discard_branches.png" /></p>
<p>Mit einem Rechtsklick werden die Optionen zum Umgang mit dem <code>stash</code> angezeigt. Man kann sich den Inhalt nochmal mit <em>Show Content in Log</em> anschauen oder den Stash mittels <em>Rename Stash…</em> umbenennen. Anhand von <em>Apply Stash…</em> kann die verworfenen Änderung wieder vorgenommen werden.</p>
<p><img src="/post/smartgit_discard_apply.png" /></p>
<p>Hier wird nochmal darin unterschieden, ob der <code>stash</code> nach dem Wiedereinfügen bestehen bleibt (<strong>Apply</strong>) oder ob der Eintrag dann verworfen wird (<strong>Apply &amp; Drop</strong>). Zum Testen klicken wir nun einmal auf <em>Apply &amp; Drop</em>.</p>
<p><img src="/post/smartgit_discard_overview.png" /></p>
<p>Wir sehen nun, dass die Datei zur Datenauswertung wieder als “Modified” angezeigt wird. Weiterhin ist der <code>stash</code> aus der Anzeige der <code>Branches</code> verschwunden (dies wäre bei nur <strong>Apply</strong> nicht passiert). Da die Änderung an unserer Auswertungsdatei aber nicht wichtig ist, wollen wir sie jetzt endgültig rückgäng machen. Wir wählen also wieder <em>Discard</em> und als Option diesmal das reine <code>discard</code>. Damit ist die Datei wieder auf dem Stand des letzten <code>commit</code>.</p>
<p>Das Alles kann man natürlich auch “Old-School” über das Terminal machen. Hierzu wechselt ihr im Terminal auf euer <span style="color: darkred;"><strong>Git</strong></span>-Repository.
Mit <code>git status</code> könnt ihr euch die Änderungen in eurem Repository anschauen.</p>
<p><img src="/post/smartgit_discard_modifiedTerminal.png" />
Wie ihr auf dem Bild sehen könnt, zeigt uns das Terminal auch mit “modified” an, dass etwas an unserer Datei geändert wurde.</p>
<p>Hier gibt es jetzt dieselben zwei Optionen, wie bei <span style="color: darkred;"><strong>SmartGit</strong></span>.</p>
<ol style="list-style-type: decimal">
<li><p><code>git reset -hard</code> und dann <code>git clean -fxd</code>: ist genau dasselbe wie <strong>Discard</strong> in <span style="color: darkred;"><strong>SmartGit</strong></span>. Eure Änderungen werden permanent gelöscht und ihr kehrt wieder auf den Stand des letzten <code>commit</code> zurück.</p></li>
<li><p><code>git stash</code>: entspricht <strong>Discard to Stash</strong>. Eure Veränderungen werden also erstmal einem “Papierkorb” hinzugefügt und nicht direkt gelöscht.</p></li>
</ol>
</div>
<div id="git-revert" class="section level5">
<h5><code>git revert</code></h5>
<p>Dieser Befehl ist eine sichere Methode, um einen <code>Commit</code> rückgängig zu machen. Was genau passiert, werden wir uns in einem Beispiel ansehen. Nehmen wir an, dass wir in unsere Datenauswertung etwas Falsches reingeschrieben haben:</p>
<p><img src="/post/smartgit_revert.png" />
Das ist uns aber erst aufgefallen, als wir die Änderung schon in einen <code>Commit</code>gepackt haben. Jetzt wollen wir diesen <code>Commit</code> rückgängig machen.
Hierzu öffnen wir über das Terminal unser <span style="color: darkred;"><strong>Git</strong></span>-Repository und führen den Befehl <code>git revert HEAD</code>aus. Wenn wir jetzt unser Log checken, steht da Folgendes:</p>
<p><img src="/post/smartgit_DoRevert.png" />
<span style="color: darkred;"><strong>Git</strong></span> hat also einen neuen <code>Commit</code> erstellt, der den Alten rückgängig gemacht hat. Das Projekt wurde also nicht auf seinen Status vor dem <code>Commit</code> zurückgesetzt, sondern nur der letzte <code>Commit</code>. Der “Revert”-<code>Commit</code> repräsentiert denselben Status unseres Projekts wie der <code>Commit</code> vor unserem ungewollten <code>Commit</code>.</p>
<p><img src="/post/smartgit_RevertFlowchart2.png" />
Das gibt uns nun die Möglichkeit, doch noch mit dem ungewollten <code>Commit</code> arbeiten zu können, falls wir unsere Meinung ändern sollten.</p>
<p>Wenn ihr das in <span style="color: darkred;"><strong>SmartGit</strong></span> machen wollt, müsst ihr oben in der Toolleiste auf <em>Branch</em> und dann <em>Revert</em> gehen. Hier seht ihr nun ganz oben euren letzten <code>Commit</code>, den wir rückgängig machen wollen. Dafür müsst ihr dann nur noch auf “Revert&amp;Commit” gehen.
Schaut ihr euch nun den <code>Commit</code>-Verlauf an, werdet ihr ganz oben den <code>Commit</code>sehen, der euren Alten rückgängig gemacht hat.</p>
<p><img src="/post/smartgit_SmartGit_Revert.png" /></p>
</div>
<div id="git-reset" class="section level5">
<h5><code>git reset</code></h5>
<p>Mit <code>$git reset --hard [Commit]</code> wird der Verlauf auf diesen ausgewählten <code>Commit</code> zurückgesetzt. Die ungewollten <code>Commits</code> kann man im Log nicht mehr sehen (wie es oben der Fall ist). Das Log könnt ihr euch mit <code>git log</code> anzeigen lassen, mit “q” (quit) könnt ihr es wieder verlassen. In die Klammer setzt ihr die “Nummer” des vorherigen <code>Commits</code> ein, der hier “Gewollte Änderung” heißt. Diese erfahrt ihr über das Log und sieht so aus: 3fb082aec25dacb664762cec505aba79528b55cf. Wenn ihr nach dem Ausführen des Befehls nun wieder in euer Log schaut, ist euer neuer <code>Commit</code> nicht mehr da.</p>
<p><img src="/post/smartgit_git_reset.png" /></p>
<p><img src="/post/smartgit_git_reset_HEAD.png" /></p>
<p>Wie kann man den letzten <code>Commit</code> auf <span style="color: darkred;"><strong>SmartGit</strong></span> rückgängig machen? Indem ihr in <span style="color: darkred;"><strong>SmartGit</strong></span> auf <em>Local</em>, oben in der Leiste geht und dann nur noch auf <code>Undo last Commit</code> klickt. Damit kehrt ihr wieder auf den Stand vor diesem <code>Commit</code> zurück.</p>
<p><img src="/post/smartgit_git_reset_Flowchart.png" /></p>
<p>Den Unterschied zu <code>git revert</code> seht ihr in diesem Flowchart. Der Befehl <code>git revert</code> erstellt für euren gelöschten <code>Commit</code> einen Neuen, der den alten umkehrt (schaut euch dazu auch nochmal das Flowchart für <code>git revert</code> an). Der <em>HEAD</em>-Zeiger bewegt sich also vorwärts auf den neuen <code>Commit</code>, der den Zustand vor eurem ungewollten <code>Commit</code> wiederspiegelt.
Bei <code>git reset</code> bewegt sich der <em>HEAD</em>-Zeiger rückwärts. Der ungewollte <code>Commit</code> wird vollständig gelöscht, auch aus dem Log. Ihr kehrt tatsächlich zu eurem alten <code>Commit</code> zurück und nicht nur auf eine “Kopie” davon.</p>
</div>
<div id="fetch" class="section level5">
<h5><code>Fetch</code></h5>
<p><code>Fetch</code> ist euch vielleicht schon beim Befehl <code>pull</code> als Option aufgefallen. Dort konntet ihr euch zwischen <strong>Pull</strong> und <strong>Fetch Only</strong> entscheiden.</p>
<p><img src="/post/smartgit_pull.png" /></p>
<p>Der Unterschied zwischen den beiden Optionen besteht darin, dass beim <strong>Fetch</strong> lediglich die Informationen darüber abgerufen werden, ob seit unserem letzten <code>push</code> Veränderungen an dem Projekt vorgenommen wurden und welche genau das sind. Bei <code>pull</code> hingegen werden, wie wir es gesehen haben, sowohl diese Information abgerufen als auch alle Veränderungen auf unseren lokalen Ordner übertragen. Somit arbeiten wir direkt mit den veränderten Dateien weiter, während wir bei <code>Fetch</code> noch auf unserem eigenen letzten Stand bleiben.</p>
<!-- Kann man diese Erklärung noch spezifizieren? __ Finde die Erklärung eigentlich soweit gut, in welche Richtung spezifizieren?-->
<p>Mit <code>fetch</code> können wir also einen Überblick über die Veränderungen erhalten, die seit unserem letzten <code>pull</code> von den anderen Kollaborator:innen vorgenommen wurden und auf <span style="color: darkred;"><strong>GitHub</strong></span> gepushed wurden. Wir können dann nach der Betrachtung überlegen, ob wir die Änderungen auch übernehmen möchten. Beachtet jedoch, dass es zu Konflikten kommen kann, wenn ihr eine Datei nicht aktualisiert, sie dann auf andere Weise selbst verändert und versucht, einen <code>push</code> durchzuführen. Dann muss in mühsamer Kleinarbeit der Konflikt gelöst werden. Daher ist der Einsatz von <code>fetch</code> eher beschränkt.</p>
</div>
<div id="gitignore" class="section level5">
<h5><code>gitignore</code></h5>
<p>Eine weitere nützliche Funktionalität ist die Verwendung von <code>gitignore</code>, die wir euch anhand der stets präsenten <strong>.Rhistory</strong> erläutern. Wie wir bereits beschrieben haben, ist die Datei <strong>.Rhistory</strong> eine eigene Historien-Dokumentation über durchgeführte Befehle in <span style="color: darkred;"><strong>R</strong></span>, aber für die Arbeit unnötig. Trotzdem ist sie stets in der Anzeige <code>Files</code> in <span style="color: darkred;"><strong>SmartGit</strong></span> enthalten, wo sie als “Untracked” angezeigt wird. Bisher haben wir sie stets manuell ignoriert, was aber keine zufriedenstellende Lösung ist. Weiterhin kann man Dateien mit Rechtsklick und <code>Delete</code> einfach löschen. Aber bei der nächsten Arbeit mit <span style="color: darkred;"><strong>R</strong></span> würde sie wieder auftauchen. Wir müssen <span style="color: darkred;"><strong>Git</strong></span> also berichten, dass dies eine unwichtige Datei ist, die in alle Aktionen nicht einbezogen werden soll, wofür <code>gitignore</code> gemacht ist.</p>
<p>In einer Datei mit dem Namen <code>.gitignore</code> können Benennungen von Dateien festgelegt werden, die von <span style="color: darkred;"><strong>Git</strong></span> - wie es der Name sagt - ignoriert werden. Es ist im Endeffekt eine Liste mit vielen Einträgen. Man kann die <code>.gitignore</code>-Datei mit einem normalen Texteditor erstellen, wobei dabei manchmal Probleme auftauchen, da keine Zeichen vor dem <code>.</code> im Dateinamen sind oder die Datei als <strong>.gitignore.txt</strong> abgespeichert wird, wodurch sie nicht funktioniert. Auch <span style="color: darkred;"><strong>GitHub</strong></span> bietet eine Option zum Erstellen dieser Datei. Wir wollen aber betrachten, wie <span style="color: darkred;"><strong>SmartGit</strong></span> uns dabei behilflich sein kann.</p>
<ol style="list-style-type: decimal">
<li>Wir machen einen Rechtsklick auf die Datei und wählen jetzt die Option <em>Ignore</em>.</li>
<li>In dem Fenster, was sich jetzt öffnet, haben wir zwei Optionen. Wir können entweder die Datei spezifisch zum Ignorieren auswählen (<em>Ignore explicitly (e.g. ‘Makefile’)</em>) oder alle Dateien mit ähnlichem Muster. Um die Muster kümmern wir uns später nochmal und wählen jetzt erstmal spezifisch die Datei. Wir lassen auch den Rest auf den Standardeinstellungen und bestätigen.</li>
</ol>
<p><img src="/post/smartgit_ignore.png" />
3. Im <strong>Files</strong>-Feld verschwindet nun die Datei <strong>.Rhistory</strong>. Die neue Datei wird uns aber nicht direkt angezeigt. Um sie zu betrachten, wählen wir erst <em>View</em> und dann <em>Show ignored Files</em>. In der <code>File</code> Übersicht werden nun sowohl <strong>.gitignore</strong> als auch <strong>.Rhistory</strong> angezeigt. Wenn wir die Datei <strong>.gitignore</strong> mit Linksklick anwählen, sehen wir in den <strong>Changes</strong> auch ihren Inhalt. Dort werden sowohl <strong>.gitignore</strong> als auch <strong>.Rhistory</strong> angezeigt.</p>
<p><img src="/post/smartgit_gitignore_files.png" />
<img src="/post/smartgit_gitignore_changes.png" /></p>
<ol start="4" style="list-style-type: decimal">
<li>Standardmäßig ignoriert sich die <code>.gitignore</code>-Datei also auch selbst. Das heißt, dass Änderungen nicht getracked werden und sie auch nicht in einem <code>push</code> auf <span style="color: darkred;"><strong>GitHub</strong></span> enthalten sein kann. Jede:r Teilnehmende am Projekt hätte demnach entweder eine eigene Version der Datei oder auch gar keine, wenn er:sie keine erstellt hat. Wir möchten die Datei jedoch ins Tracking mit aufnehmen. Daher machen wir einen Rechtsklick auf die Datei und klicken <em>Open</em>, wodurch sie in einem Texteditor geöffnet wird. Dort entfernen wir dann die Zeile, in der <code>.gitignore</code> genannt ist und speichern. Der Status der Datei ist nun nicht mehr “Ignored”, sondern “Untracked”.</li>
</ol>
<p><img src="/post/smartgit_gitignore_editor.png" />
<img src="/post/smartgit_gitignore_stage.png" /></p>
<ol start="5" style="list-style-type: decimal">
<li>Im letzten Schritt können wir nun zunächst die ignorierten Dateien über die Auswahl in <em>View</em> wieder verstecken. Zusätzlich müssen wir die <code>.gitignore</code>-Datei in einen <code>commit</code> packen und diesen auch direkt über <em>Commit &amp; Push</em> mit <span style="color: darkred;"><strong>GitHub</strong></span> synchronisieren. Damit ist die Erstellung der Datei abgeschlossen.</li>
</ol>
<p><img src="/post/smartgit_gitignore_commit.png" /></p>
<p>Die Liste von ignorierten Dateien kann stets geändert werden. Dabei beginnt jeder Name einer Datei in einer neuen Zeile. Wir haben schon angemerkt, dass man neben präzisen Dateinamen auch Muster ausschließen kann. Beispielsweise sind Datensätze teilweise sehr große Objekte oder enthalten Daten, die nicht online gestellt werden sollten. Trotzdem wollen wir sie meist am selben Ort wie die Auswertungsskripts haben. Eine Aufnahme in die Liste der ignorierten Dateien ist hierbei optimal. Nehmen wir an, die Daten heißen “a.RData” und “b.RData”. Nun könnte man natürlich einfach beide Namen in die <code>.gitignore</code>-Datei eintragen. Man kann aber auch den Stern <code>*</code> als Platzhalter nutzen.</p>
<pre><code>*.RData</code></pre>
<p>Somit werden alle Dateien mit dieser Endung ignoriert. Nehmen wir an, dass wir eine weitere Datei “c.RData” haben, die keine persönlichen Informationen enthält und auch nicht zu groß ist. Diese würde nun auch ignoriert werden, obwohl sie es nicht soll. Ausnahmen in <code>.gitignore</code> können über ein Ausrufezeichen gesteuert werden <code>!</code>.</p>
<pre><code>!c.RData</code></pre>
<p>Nun wird nur die eine Daten-Datei getracked. Manchmal gibt es in einem Repository auch Unterordner, die alle Dateien erhalten, die für das Tracking nicht wichtig sind. Diese können dann gemeinsam über den zugehörigen Ordnernamen ausgeschlossen werden.</p>
<pre><code>Ordnername/*</code></pre>
<p><code>.gitignore</code> ist also hilfreich zum Ordnung halten und kann gleichzeitig persönliche Daten vor einem Upload schützen.</p>
</div>
<div id="conflict-solver" class="section level5">
<h5><code>Conflict Solver</code></h5>
<p>Der Conflict Solver ist keine immer einsetzbare Funktion. Um diesen benutzen zu können, muss man erstmal einen Konflikt haben. Konflikte können bspw. entstehen, wenn zwei Personen diesselbe Zeile derselben Datei ändern oder eine Person die Datei löscht, während ein andere diese ändert.</p>
<p>Für <span style="color: darkred;"><strong>Git</strong></span> ist natürlich nicht direkt klar, welche der beiden Änderungen nun richtig ist. Dies wird durch das Anzeigen eines Konfliktes gelöst. Im Kontext der Arbeit mit <span style="color: darkred;"><strong>GitHub</strong></span> muss die Person, die als zweites Änderungen an einer Datei pushen will, den Konflikt lösen. Dies ist generell erstmal logisch, da bei den ersten Änderungen natürlich kein Konflikt auftritt und <span style="color: darkred;"><strong>Git</strong></span> nicht in die Zukunft schauen kann. Mit <span style="color: darkred;"><strong>SmartGit</strong></span> wird das Lösen eines Konfliktes zum Glück erleichtert - wir wollen dies an einem Beispiel betrachten.</p>
<p><strong>Konflikt erstellen</strong></p>
<p>Um einen Konflikt lösen zu können, muss man natürlich erstmal einen erstellen. Dafür braucht ihr ein lokales <span style="color: darkred;"><strong>Git</strong></span>-Repository, das mit einem Remote-Repository auf <span style="color: darkred;"><strong>GitHub</strong></span> verbunden ist. Wir werden jetzt einen Konflikt in der Datei “Datenauswertung” erzeugen. Das funktioniert wie folgt:</p>
<ol style="list-style-type: decimal">
<li><p>Unsere Datei “Datenauswertung” existiert lokal und auf <span style="color: darkred;"><strong>GitHub</strong></span>. Natürlich könntet ihr auch eine neue Datei erstellen, aber in diesem Fall bleiben wir bei unserem Beispiel. Wichtig ist nur, dass die Datei lokal und auf <span style="color: darkred;"><strong>GitHub</strong></span> auf demselben Stand vorliegt.</p></li>
<li><p>Geht auf <span style="color: darkred;"><strong>GitHub</strong></span> und ändert etwas an der Datei (hier in Zeile 20) und speichert diese Änderungen. Wir gehen jetzt gedanklich davon aus, dass eine andere Person in euerm Team, einen <code>shapiro.test()</code> machen möchte und diesen auch schon remote hinterlegt hat.</p></li>
</ol>
<p><img src="/post/smartgit_GitHub_Änderungen.png" />
3. Jetzt ändert ihr lokal etwas in der Datei (auch in Zeile 20). Ihr selbst wollt also einen <code>t.test()</code> mit den Daten durchführen.</p>
<p><img src="/post/smartgit_KonfliktLokal2.png" />
4. Öffnet <span style="color: darkred;"><strong>SmartGit</strong></span> und führt nur einen <code>Commit</code> durch, aber noch keinen <code>Push</code>.</p>
<p><img src="/post/smartgit_KonfliktCommit.png" />
5. Versucht jetzt einen <em>Push</em> durchzuführen. Es müsste euch folgende Warnung angezeigt werden:</p>
<p><img src="/post/smartgit_PushFehlermeldung.png" />
<span style="color: darkred;"><strong>SmartGit</strong></span> sagt uns, dass wir zuerst einen <em>Pull</em> durchführen sollen (<em>hint: to the same ref. You may want to first integrate the remote changes</em>).
Wenn ihr das jetzt macht, ist ein Konflikt entstanden.</p>
<p><img src="/post/smartgit_KonfliktEntstanden.png" /></p>
<p><strong>Konflikt Lösen</strong></p>
<p>Nachdem <span style="color: darkred;"><strong>SmartGit</strong></span> den Konflikt in der Datei erkannt hat, wird es euch rechts unten automatisch eine Leiste zur möglichen Konfliktlösung anzeigen.</p>
<p>Die einfachsten zwei Optionen zwischen denen man wählen kann, um den Konflikt zu lösen sind: <em>Take Ours</em> oder <em>Take Theirs</em>.
Dabei entscheidet man sich entweder komplett für seine eigene Version oder die der andere Person.</p>
<p>Das ist natürlich problematisch, wenn man sowohl die Eigenen als auch die des Anderen behalten will. Hier kommt jetzt der <code>Conflict Solver</code> ins Spiel. Den Button dazu findet ihr in dem Bereich unten rechts, dort wo ihr auch schon die Optionen <em>Take Ours</em> und <em>Take Theirs</em> aufgefunden habt.</p>
<p><img src="/post/smartgit_ConflictSolver.png" /></p>
<!-- Wie wird dieser gestartet? Automatisch, wenn Git Konflikt registriert, steht oben-->
<p>Nachdem ihr den <code>Conflict Solver</code> gestartet habt, öffnet sich ein weiteres Fenster. Links sieht man unsere eigenen Veränderungen, rechts die der anderen Person und in der Mitte eine mögliche Lösung des Konflikts.</p>
<p><img src="/post/smartgit_ConflictSolver3.png" />
Hier werden beide Veränderungen zusammen in der Datei angezeigt. Falls noch nicht genau ersichtlich ist, wer welche Veränderungen getätigt hat, geht man links oben auf <em>Base Changes</em>. Damit erhält man bei großen Veränderungen einen besseren Überblick. Bei unserem Beispiel ist das nicht nötig.</p>
<p>Wir wollen jetzt die Version mit dem <code>shapiro.test()</code> nehmen. Dafür klicken wir auf den Pfeil neben der Zeile und “ziehen” sie in die Mitte.</p>
<p><img src="/post/smartgit_KonfliktLösung2.png" />
Die Datei in der Mitte sieht jetzt so aus wie wir sie haben wollten. Also gehen wir auf <em>Save</em> und schließen dann den <code>Conflict Solver</code>. Dabei taucht folgende Meldung auf:</p>
<p><img src="/post/smartgit_StageCommit.png" />
Hier klickt man auf <em>Stage</em>, um den Konflikt zu lösen. <em>Stage</em> bereitet die Datei für einen <code>Commit</code> vor, lädt sie also ins <em>Staging Environment</em> wie wir aus dem <strong>Git-Intro</strong> wissen. Würden wir auf <em>Don´t Stage</em> klicken, hätten wir zwar unsere Veränderungen in der Datei, aber sie würden beim nächsten <code>Commit</code> nicht auftauchen.<br />
Anschließend führt ihr einen <code>Commit</code> durch und einen <code>Push</code>, um die neue Datei auch auf <span style="color: darkred;"><strong>GitHub</strong></span> zu haben.</p>
<p>Der Konflikt wurde erfolgreich gelöst!</p>
</div>
</div>
<div id="fazit-und-ausblick" class="section level1">
<h1>Fazit und Ausblick</h1>
<p>Wie ihr sicherlich gesehen habt, sind <span style="color: darkred;"><strong>Git</strong></span> und <span style="color: darkred;"><strong>SmartGit</strong></span> umfangreicher als es auf den ersten Blick scheint. Denn auch dieses Kapitel hat das ganze Ausmaß nur angerissen. Falls ihr euch mal einen Überblick über alle Funktionen von <span style="color: darkred;"><strong>Git</strong></span> schaffen wollt, schaut in die offizielle <span style="color: darkred;"><strong>Git</strong></span>-Dokumentation rein.</p>
<!-- Folgende Kommentare sind erstmal nicht an dich -->
<!-- Unterschied zwische Rebase und Revert -->
<!-- bei einem wird alles was neuer war, als der Zeitpunkt zu dem man zurück geht, gelöscht und ist nicht zugreifbar -->
<!-- bei dem anderen wird der Rückgang zu dem alten Punkt als neuer Punkt im Working Tree angelegt. -->
</div>
